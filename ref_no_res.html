<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Playable Ad</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #1a1a2e;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #game-container {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
  </style>
  <script type="module" crossorigin="">
    var Ip = Object.defineProperty;
    var bp = (i, e, t) => (e in i ? Ip(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t));
    var V = (i, e, t) => bp(i, typeof e != 'symbol' ? e + '' : e, t);
    (function () {
      const e = document.createElement('link').relList;
      if (e && e.supports && e.supports('modulepreload')) return;
      for (const r of document.querySelectorAll('link[rel="modulepreload"]')) A(r);
      new MutationObserver((r) => {
        for (const s of r)
          if (s.type === 'childList') for (const n of s.addedNodes) n.tagName === 'LINK' && n.rel === 'modulepreload' && A(n);
      }).observe(document, { childList: !0, subtree: !0 });
      function t(r) {
        const s = {};
        return (
          r.integrity && (s.integrity = r.integrity),
          r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
          r.crossOrigin === 'use-credentials'
            ? (s.credentials = 'include')
            : r.crossOrigin === 'anonymous'
              ? (s.credentials = 'omit')
              : (s.credentials = 'same-origin'),
          s
        );
      }
      function A(r) {
        if (r.ep) return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s);
      }
    })();
    const yp = 'modulepreload',
      xp = function (i, e) {
        return new URL(i, e).href;
      },
      mo = {},
      QA = function (e, t, A) {
        let r = Promise.resolve();
        if (t && t.length > 0) {
          let n = function (u) {
            return Promise.all(
              u.map((o) =>
                Promise.resolve(o).then(
                  (c) => ({ status: 'fulfilled', value: c }),
                  (c) => ({ status: 'rejected', reason: c })
                )
              )
            );
          };
          const a = document.getElementsByTagName('link'),
            l = document.querySelector('meta[property=csp-nonce]'),
            h = l?.nonce || l?.getAttribute('nonce');
          r = n(
            t.map((u) => {
              if (((u = xp(u, A)), u in mo)) return;
              mo[u] = !0;
              const o = u.endsWith('.css'),
                c = o ? '[rel="stylesheet"]' : '';
              if (!!A)
                for (let g = a.length - 1; g >= 0; g--) {
                  const p = a[g];
                  if (p.href === u && (!o || p.rel === 'stylesheet')) return;
                }
              else if (document.querySelector(`link[href="${u}"]${c}`)) return;
              const f = document.createElement('link');
              if (
                ((f.rel = o ? 'stylesheet' : yp),
                  o || (f.as = 'script'),
                  (f.crossOrigin = ''),
                  (f.href = u),
                  h && f.setAttribute('nonce', h),
                  document.head.appendChild(f),
                  o)
              )
                return new Promise((g, p) => {
                  f.addEventListener('load', g),
                    f.addEventListener('error', () => p(new Error(`Unable to preload CSS for ${u}`)));
                });
            })
          );
        }
        function s(n) {
          const a = new Event('vite:preloadError', { cancelable: !0 });
          if (((a.payload = n), window.dispatchEvent(a), !a.defaultPrevented)) throw n;
        }
        return r.then((n) => {
          for (const a of n || []) a.status === 'rejected' && s(a.reason);
          return e().catch(s);
        });
      };
    var M = ((i) => (
      (i.Application = 'application'),
      (i.WebGLPipes = 'webgl-pipes'),
      (i.WebGLPipesAdaptor = 'webgl-pipes-adaptor'),
      (i.WebGLSystem = 'webgl-system'),
      (i.WebGPUPipes = 'webgpu-pipes'),
      (i.WebGPUPipesAdaptor = 'webgpu-pipes-adaptor'),
      (i.WebGPUSystem = 'webgpu-system'),
      (i.CanvasSystem = 'canvas-system'),
      (i.CanvasPipesAdaptor = 'canvas-pipes-adaptor'),
      (i.CanvasPipes = 'canvas-pipes'),
      (i.Asset = 'asset'),
      (i.LoadParser = 'load-parser'),
      (i.ResolveParser = 'resolve-parser'),
      (i.CacheParser = 'cache-parser'),
      (i.DetectionParser = 'detection-parser'),
      (i.MaskEffect = 'mask-effect'),
      (i.BlendMode = 'blend-mode'),
      (i.TextureSource = 'texture-source'),
      (i.Environment = 'environment'),
      (i.ShapeBuilder = 'shape-builder'),
      (i.Batcher = 'batcher'),
      i
    ))(M || {});
    const As = (i) => {
      if (typeof i == 'function' || (typeof i == 'object' && i.extension)) {
        if (!i.extension) throw new Error('Extension class must have an extension object');
        i = { ...(typeof i.extension != 'object' ? { type: i.extension } : i.extension), ref: i };
      }
      if (typeof i == 'object') i = { ...i };
      else throw new Error('Invalid extension type');
      return typeof i.type == 'string' && (i.type = [i.type]), i;
    },
      IA = (i, e) => As(i).priority ?? e,
      Q = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...i) {
          return (
            i.map(As).forEach((e) => {
              e.type.forEach((t) => this._removeHandlers[t]?.(e));
            }),
            this
          );
        },
        add(...i) {
          return (
            i.map(As).forEach((e) => {
              e.type.forEach((t) => {
                const A = this._addHandlers,
                  r = this._queue;
                A[t] ? A[t]?.(e) : ((r[t] = r[t] || []), r[t]?.push(e));
              });
            }),
            this
          );
        },
        handle(i, e, t) {
          const A = this._addHandlers,
            r = this._removeHandlers;
          if (A[i] || r[i]) throw new Error(`Extension type ${i} already has a handler`);
          (A[i] = e), (r[i] = t);
          const s = this._queue;
          return s[i] && (s[i]?.forEach((n) => e(n)), delete s[i]), this;
        },
        handleByMap(i, e) {
          return this.handle(
            i,
            (t) => {
              t.name && (e[t.name] = t.ref);
            },
            (t) => {
              t.name && delete e[t.name];
            }
          );
        },
        handleByNamedList(i, e, t = -1) {
          return this.handle(
            i,
            (A) => {
              e.findIndex((s) => s.name === A.name) >= 0 ||
                (e.push({ name: A.name, value: A.ref }), e.sort((s, n) => IA(n.value, t) - IA(s.value, t)));
            },
            (A) => {
              const r = e.findIndex((s) => s.name === A.name);
              r !== -1 && e.splice(r, 1);
            }
          );
        },
        handleByList(i, e, t = -1) {
          return this.handle(
            i,
            (A) => {
              e.includes(A.ref) || (e.push(A.ref), e.sort((r, s) => IA(s, t) - IA(r, t)));
            },
            (A) => {
              const r = e.indexOf(A.ref);
              r !== -1 && e.splice(r, 1);
            }
          );
        },
        mixin(i, ...e) {
          for (const t of e) Object.defineProperties(i.prototype, Object.getOwnPropertyDescriptors(t));
        },
      },
      Yl = {
        extension: { type: M.Environment, name: 'browser', priority: -1 },
        test: () => !0,
        load: async () => {
          await QA(() => Promise.resolve().then(() => _q), void 0, import.meta.url);
        },
      },
      Dl = {
        extension: { type: M.Environment, name: 'webworker', priority: 0 },
        test: () => typeof self < 'u' && self.WorkerGlobalScope !== void 0,
        load: async () => {
          await QA(() => Promise.resolve().then(() => $q), void 0, import.meta.url);
        },
      };
    class le {
      constructor(e, t, A) {
        (this._x = t || 0), (this._y = A || 0), (this._observer = e);
      }
      clone(e) {
        return new le(e ?? this._observer, this._x, this._y);
      }
      set(e = 0, t = e) {
        return (this._x !== e || this._y !== t) && ((this._x = e), (this._y = t), this._observer._onUpdate(this)), this;
      }
      copyFrom(e) {
        return (this._x !== e.x || this._y !== e.y) && ((this._x = e.x), (this._y = e.y), this._observer._onUpdate(this)), this;
      }
      copyTo(e) {
        return e.set(this._x, this._y), e;
      }
      equals(e) {
        return e.x === this._x && e.y === this._y;
      }
      toString() {
        return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
      }
      get x() {
        return this._x;
      }
      set x(e) {
        this._x !== e && ((this._x = e), this._observer._onUpdate(this));
      }
      get y() {
        return this._y;
      }
      set y(e) {
        this._y !== e && ((this._y = e), this._observer._onUpdate(this));
      }
    }
    var pA =
      typeof globalThis < 'u'
        ? globalThis
        : typeof window < 'u'
          ? window
          : typeof global < 'u'
            ? global
            : typeof self < 'u'
              ? self
              : {};
    function Ol(i) {
      return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, 'default') ? i.default : i;
    }
    var Sr = { exports: {} },
      So;
    function vp() {
      return (
        So ||
        ((So = 1),
          (function (i) {
            var e = Object.prototype.hasOwnProperty,
              t = '~';
            function A() { }
            Object.create && ((A.prototype = Object.create(null)), new A().__proto__ || (t = !1));
            function r(l, h, u) {
              (this.fn = l), (this.context = h), (this.once = u || !1);
            }
            function s(l, h, u, o, c) {
              if (typeof u != 'function') throw new TypeError('The listener must be a function');
              var d = new r(u, o || l, c),
                f = t ? t + h : h;
              return (
                l._events[f]
                  ? l._events[f].fn
                    ? (l._events[f] = [l._events[f], d])
                    : l._events[f].push(d)
                  : ((l._events[f] = d), l._eventsCount++),
                l
              );
            }
            function n(l, h) {
              --l._eventsCount === 0 ? (l._events = new A()) : delete l._events[h];
            }
            function a() {
              (this._events = new A()), (this._eventsCount = 0);
            }
            (a.prototype.eventNames = function () {
              var h = [],
                u,
                o;
              if (this._eventsCount === 0) return h;
              for (o in (u = this._events)) e.call(u, o) && h.push(t ? o.slice(1) : o);
              return Object.getOwnPropertySymbols ? h.concat(Object.getOwnPropertySymbols(u)) : h;
            }),
              (a.prototype.listeners = function (h) {
                var u = t ? t + h : h,
                  o = this._events[u];
                if (!o) return [];
                if (o.fn) return [o.fn];
                for (var c = 0, d = o.length, f = new Array(d); c < d; c++) f[c] = o[c].fn;
                return f;
              }),
              (a.prototype.listenerCount = function (h) {
                var u = t ? t + h : h,
                  o = this._events[u];
                return o ? (o.fn ? 1 : o.length) : 0;
              }),
              (a.prototype.emit = function (h, u, o, c, d, f) {
                var g = t ? t + h : h;
                if (!this._events[g]) return !1;
                var p = this._events[g],
                  m = arguments.length,
                  S,
                  q;
                if (p.fn) {
                  switch ((p.once && this.removeListener(h, p.fn, void 0, !0), m)) {
                    case 1:
                      return p.fn.call(p.context), !0;
                    case 2:
                      return p.fn.call(p.context, u), !0;
                    case 3:
                      return p.fn.call(p.context, u, o), !0;
                    case 4:
                      return p.fn.call(p.context, u, o, c), !0;
                    case 5:
                      return p.fn.call(p.context, u, o, c, d), !0;
                    case 6:
                      return p.fn.call(p.context, u, o, c, d, f), !0;
                  }
                  for (q = 1, S = new Array(m - 1); q < m; q++) S[q - 1] = arguments[q];
                  p.fn.apply(p.context, S);
                } else {
                  var E = p.length,
                    b;
                  for (q = 0; q < E; q++)
                    switch ((p[q].once && this.removeListener(h, p[q].fn, void 0, !0), m)) {
                      case 1:
                        p[q].fn.call(p[q].context);
                        break;
                      case 2:
                        p[q].fn.call(p[q].context, u);
                        break;
                      case 3:
                        p[q].fn.call(p[q].context, u, o);
                        break;
                      case 4:
                        p[q].fn.call(p[q].context, u, o, c);
                        break;
                      default:
                        if (!S) for (b = 1, S = new Array(m - 1); b < m; b++) S[b - 1] = arguments[b];
                        p[q].fn.apply(p[q].context, S);
                    }
                }
                return !0;
              }),
              (a.prototype.on = function (h, u, o) {
                return s(this, h, u, o, !1);
              }),
              (a.prototype.once = function (h, u, o) {
                return s(this, h, u, o, !0);
              }),
              (a.prototype.removeListener = function (h, u, o, c) {
                var d = t ? t + h : h;
                if (!this._events[d]) return this;
                if (!u) return n(this, d), this;
                var f = this._events[d];
                if (f.fn) f.fn === u && (!c || f.once) && (!o || f.context === o) && n(this, d);
                else {
                  for (var g = 0, p = [], m = f.length; g < m; g++)
                    (f[g].fn !== u || (c && !f[g].once) || (o && f[g].context !== o)) && p.push(f[g]);
                  p.length ? (this._events[d] = p.length === 1 ? p[0] : p) : n(this, d);
                }
                return this;
              }),
              (a.prototype.removeAllListeners = function (h) {
                var u;
                return (
                  h
                    ? ((u = t ? t + h : h), this._events[u] && n(this, u))
                    : ((this._events = new A()), (this._eventsCount = 0)),
                  this
                );
              }),
              (a.prototype.off = a.prototype.removeListener),
              (a.prototype.addListener = a.prototype.on),
              (a.prefixed = t),
              (a.EventEmitter = a),
              (i.exports = a);
          })(Sr)),
        Sr.exports
      );
    }
    var Cp = vp();
    const ye = Ol(Cp),
      Ll = Math.PI * 2,
      jl = 180 / Math.PI,
      Zl = Math.PI / 180;
    class H {
      constructor(e = 0, t = 0) {
        (this.x = 0), (this.y = 0), (this.x = e), (this.y = t);
      }
      clone() {
        return new H(this.x, this.y);
      }
      copyFrom(e) {
        return this.set(e.x, e.y), this;
      }
      copyTo(e) {
        return e.set(this.x, this.y), e;
      }
      equals(e) {
        return e.x === this.x && e.y === this.y;
      }
      set(e = 0, t = e) {
        return (this.x = e), (this.y = t), this;
      }
      toString() {
        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
      }
      static get shared() {
        return (qr.x = 0), (qr.y = 0), qr;
      }
    }
    const qr = new H();
    class R {
      constructor(e = 1, t = 0, A = 0, r = 1, s = 0, n = 0) {
        (this.array = null), (this.a = e), (this.b = t), (this.c = A), (this.d = r), (this.tx = s), (this.ty = n);
      }
      fromArray(e) {
        (this.a = e[0]), (this.b = e[1]), (this.c = e[3]), (this.d = e[4]), (this.tx = e[2]), (this.ty = e[5]);
      }
      set(e, t, A, r, s, n) {
        return (this.a = e), (this.b = t), (this.c = A), (this.d = r), (this.tx = s), (this.ty = n), this;
      }
      toArray(e, t) {
        this.array || (this.array = new Float32Array(9));
        const A = t || this.array;
        return (
          e
            ? ((A[0] = this.a),
              (A[1] = this.b),
              (A[2] = 0),
              (A[3] = this.c),
              (A[4] = this.d),
              (A[5] = 0),
              (A[6] = this.tx),
              (A[7] = this.ty),
              (A[8] = 1))
            : ((A[0] = this.a),
              (A[1] = this.c),
              (A[2] = this.tx),
              (A[3] = this.b),
              (A[4] = this.d),
              (A[5] = this.ty),
              (A[6] = 0),
              (A[7] = 0),
              (A[8] = 1)),
          A
        );
      }
      apply(e, t) {
        t = t || new H();
        const A = e.x,
          r = e.y;
        return (t.x = this.a * A + this.c * r + this.tx), (t.y = this.b * A + this.d * r + this.ty), t;
      }
      applyInverse(e, t) {
        t = t || new H();
        const A = this.a,
          r = this.b,
          s = this.c,
          n = this.d,
          a = this.tx,
          l = this.ty,
          h = 1 / (A * n + s * -r),
          u = e.x,
          o = e.y;
        return (t.x = n * h * u + -s * h * o + (l * s - a * n) * h), (t.y = A * h * o + -r * h * u + (-l * A + a * r) * h), t;
      }
      translate(e, t) {
        return (this.tx += e), (this.ty += t), this;
      }
      scale(e, t) {
        return (this.a *= e), (this.d *= t), (this.c *= e), (this.b *= t), (this.tx *= e), (this.ty *= t), this;
      }
      rotate(e) {
        const t = Math.cos(e),
          A = Math.sin(e),
          r = this.a,
          s = this.c,
          n = this.tx;
        return (
          (this.a = r * t - this.b * A),
          (this.b = r * A + this.b * t),
          (this.c = s * t - this.d * A),
          (this.d = s * A + this.d * t),
          (this.tx = n * t - this.ty * A),
          (this.ty = n * A + this.ty * t),
          this
        );
      }
      append(e) {
        const t = this.a,
          A = this.b,
          r = this.c,
          s = this.d;
        return (
          (this.a = e.a * t + e.b * r),
          (this.b = e.a * A + e.b * s),
          (this.c = e.c * t + e.d * r),
          (this.d = e.c * A + e.d * s),
          (this.tx = e.tx * t + e.ty * r + this.tx),
          (this.ty = e.tx * A + e.ty * s + this.ty),
          this
        );
      }
      appendFrom(e, t) {
        const A = e.a,
          r = e.b,
          s = e.c,
          n = e.d,
          a = e.tx,
          l = e.ty,
          h = t.a,
          u = t.b,
          o = t.c,
          c = t.d;
        return (
          (this.a = A * h + r * o),
          (this.b = A * u + r * c),
          (this.c = s * h + n * o),
          (this.d = s * u + n * c),
          (this.tx = a * h + l * o + t.tx),
          (this.ty = a * u + l * c + t.ty),
          this
        );
      }
      setTransform(e, t, A, r, s, n, a, l, h) {
        return (
          (this.a = Math.cos(a + h) * s),
          (this.b = Math.sin(a + h) * s),
          (this.c = -Math.sin(a - l) * n),
          (this.d = Math.cos(a - l) * n),
          (this.tx = e - (A * this.a + r * this.c)),
          (this.ty = t - (A * this.b + r * this.d)),
          this
        );
      }
      prepend(e) {
        const t = this.tx;
        if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
          const A = this.a,
            r = this.c;
          (this.a = A * e.a + this.b * e.c),
            (this.b = A * e.b + this.b * e.d),
            (this.c = r * e.a + this.d * e.c),
            (this.d = r * e.b + this.d * e.d);
        }
        return (this.tx = t * e.a + this.ty * e.c + e.tx), (this.ty = t * e.b + this.ty * e.d + e.ty), this;
      }
      decompose(e) {
        const t = this.a,
          A = this.b,
          r = this.c,
          s = this.d,
          n = e.pivot,
          a = -Math.atan2(-r, s),
          l = Math.atan2(A, t),
          h = Math.abs(a + l);
        return (
          h < 1e-5 || Math.abs(Ll - h) < 1e-5
            ? ((e.rotation = l), (e.skew.x = e.skew.y = 0))
            : ((e.rotation = 0), (e.skew.x = a), (e.skew.y = l)),
          (e.scale.x = Math.sqrt(t * t + A * A)),
          (e.scale.y = Math.sqrt(r * r + s * s)),
          (e.position.x = this.tx + (n.x * t + n.y * r)),
          (e.position.y = this.ty + (n.x * A + n.y * s)),
          e
        );
      }
      invert() {
        const e = this.a,
          t = this.b,
          A = this.c,
          r = this.d,
          s = this.tx,
          n = e * r - t * A;
        return (
          (this.a = r / n),
          (this.b = -t / n),
          (this.c = -A / n),
          (this.d = e / n),
          (this.tx = (A * this.ty - r * s) / n),
          (this.ty = -(e * this.ty - t * s) / n),
          this
        );
      }
      isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
      }
      identity() {
        return (this.a = 1), (this.b = 0), (this.c = 0), (this.d = 1), (this.tx = 0), (this.ty = 0), this;
      }
      clone() {
        const e = new R();
        return (e.a = this.a), (e.b = this.b), (e.c = this.c), (e.d = this.d), (e.tx = this.tx), (e.ty = this.ty), e;
      }
      copyTo(e) {
        return (e.a = this.a), (e.b = this.b), (e.c = this.c), (e.d = this.d), (e.tx = this.tx), (e.ty = this.ty), e;
      }
      copyFrom(e) {
        return (this.a = e.a), (this.b = e.b), (this.c = e.c), (this.d = e.d), (this.tx = e.tx), (this.ty = e.ty), this;
      }
      equals(e) {
        return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty;
      }
      toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      }
      static get IDENTITY() {
        return kp.identity();
      }
      static get shared() {
        return Up.identity();
      }
    }
    const Up = new R(),
      kp = new R(),
      Et = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
      Vt = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
      Tt = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
      It = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
      is = [],
      Xl = [],
      si = Math.sign;
    function Rp() {
      for (let i = 0; i < 16; i++) {
        const e = [];
        is.push(e);
        for (let t = 0; t < 16; t++) {
          const A = si(Et[i] * Et[t] + Tt[i] * Vt[t]),
            r = si(Vt[i] * Et[t] + It[i] * Vt[t]),
            s = si(Et[i] * Tt[t] + Tt[i] * It[t]),
            n = si(Vt[i] * Tt[t] + It[i] * It[t]);
          for (let a = 0; a < 16; a++)
            if (Et[a] === A && Vt[a] === r && Tt[a] === s && It[a] === n) {
              e.push(a);
              break;
            }
        }
      }
      for (let i = 0; i < 16; i++) {
        const e = new R();
        e.set(Et[i], Vt[i], Tt[i], It[i], 0, 0), Xl.push(e);
      }
    }
    Rp();
    const j = {
      E: 0,
      SE: 1,
      S: 2,
      SW: 3,
      W: 4,
      NW: 5,
      N: 6,
      NE: 7,
      MIRROR_VERTICAL: 8,
      MAIN_DIAGONAL: 10,
      MIRROR_HORIZONTAL: 12,
      REVERSE_DIAGONAL: 14,
      uX: (i) => Et[i],
      uY: (i) => Vt[i],
      vX: (i) => Tt[i],
      vY: (i) => It[i],
      inv: (i) => (i & 8 ? i & 15 : -i & 7),
      add: (i, e) => is[i][e],
      sub: (i, e) => is[i][j.inv(e)],
      rotate180: (i) => i ^ 4,
      isVertical: (i) => (i & 3) === 2,
      byDirection: (i, e) =>
        Math.abs(i) * 2 <= Math.abs(e)
          ? e >= 0
            ? j.S
            : j.N
          : Math.abs(e) * 2 <= Math.abs(i)
            ? i > 0
              ? j.E
              : j.W
            : e > 0
              ? i > 0
                ? j.SE
                : j.SW
              : i > 0
                ? j.NE
                : j.NW,
      matrixAppendRotationInv: (i, e, t = 0, A = 0) => {
        const r = Xl[j.inv(e)];
        (r.tx = t), (r.ty = A), i.append(r);
      },
      transformRectCoords: (i, e, t, A) => {
        const { x: r, y: s, width: n, height: a } = i,
          { x: l, y: h, width: u, height: o } = e;
        return t === j.E
          ? (A.set(r + l, s + h, n, a), A)
          : t === j.S
            ? A.set(u - s - a + l, r + h, a, n)
            : t === j.W
              ? A.set(u - r - n + l, o - s - a + h, n, a)
              : t === j.N
                ? A.set(s + l, o - r - n + h, a, n)
                : A.set(r + l, s + h, n, a);
      },
    },
      ni = [new H(), new H(), new H(), new H()];
    class F {
      constructor(e = 0, t = 0, A = 0, r = 0) {
        (this.type = 'rectangle'),
          (this.x = Number(e)),
          (this.y = Number(t)),
          (this.width = Number(A)),
          (this.height = Number(r));
      }
      get left() {
        return this.x;
      }
      get right() {
        return this.x + this.width;
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.height;
      }
      isEmpty() {
        return this.left === this.right || this.top === this.bottom;
      }
      static get EMPTY() {
        return new F(0, 0, 0, 0);
      }
      clone() {
        return new F(this.x, this.y, this.width, this.height);
      }
      copyFromBounds(e) {
        return (this.x = e.minX), (this.y = e.minY), (this.width = e.maxX - e.minX), (this.height = e.maxY - e.minY), this;
      }
      copyFrom(e) {
        return (this.x = e.x), (this.y = e.y), (this.width = e.width), (this.height = e.height), this;
      }
      copyTo(e) {
        return e.copyFrom(this), e;
      }
      contains(e, t) {
        return this.width <= 0 || this.height <= 0
          ? !1
          : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
      }
      strokeContains(e, t, A, r = 0.5) {
        const { width: s, height: n } = this;
        if (s <= 0 || n <= 0) return !1;
        const a = this.x,
          l = this.y,
          h = A * (1 - r),
          u = A - h,
          o = a - h,
          c = a + s + h,
          d = l - h,
          f = l + n + h,
          g = a + u,
          p = a + s - u,
          m = l + u,
          S = l + n - u;
        return e >= o && e <= c && t >= d && t <= f && !(e > g && e < p && t > m && t < S);
      }
      intersects(e, t) {
        if (!t) {
          const B = this.x < e.x ? e.x : this.x;
          if ((this.right > e.right ? e.right : this.right) <= B) return !1;
          const x = this.y < e.y ? e.y : this.y;
          return (this.bottom > e.bottom ? e.bottom : this.bottom) > x;
        }
        const A = this.left,
          r = this.right,
          s = this.top,
          n = this.bottom;
        if (r <= A || n <= s) return !1;
        const a = ni[0].set(e.left, e.top),
          l = ni[1].set(e.left, e.bottom),
          h = ni[2].set(e.right, e.top),
          u = ni[3].set(e.right, e.bottom);
        if (h.x <= a.x || l.y <= a.y) return !1;
        const o = Math.sign(t.a * t.d - t.b * t.c);
        if (
          o === 0 ||
          (t.apply(a, a),
            t.apply(l, l),
            t.apply(h, h),
            t.apply(u, u),
            Math.max(a.x, l.x, h.x, u.x) <= A ||
            Math.min(a.x, l.x, h.x, u.x) >= r ||
            Math.max(a.y, l.y, h.y, u.y) <= s ||
            Math.min(a.y, l.y, h.y, u.y) >= n)
        )
          return !1;
        const c = o * (l.y - a.y),
          d = o * (a.x - l.x),
          f = c * A + d * s,
          g = c * r + d * s,
          p = c * A + d * n,
          m = c * r + d * n;
        if (Math.max(f, g, p, m) <= c * a.x + d * a.y || Math.min(f, g, p, m) >= c * u.x + d * u.y) return !1;
        const S = o * (a.y - h.y),
          q = o * (h.x - a.x),
          E = S * A + q * s,
          b = S * r + q * s,
          T = S * A + q * n,
          I = S * r + q * n;
        return !(Math.max(E, b, T, I) <= S * a.x + q * a.y || Math.min(E, b, T, I) >= S * u.x + q * u.y);
      }
      pad(e = 0, t = e) {
        return (this.x -= e), (this.y -= t), (this.width += e * 2), (this.height += t * 2), this;
      }
      fit(e) {
        const t = Math.max(this.x, e.x),
          A = Math.min(this.x + this.width, e.x + e.width),
          r = Math.max(this.y, e.y),
          s = Math.min(this.y + this.height, e.y + e.height);
        return (this.x = t), (this.width = Math.max(A - t, 0)), (this.y = r), (this.height = Math.max(s - r, 0)), this;
      }
      ceil(e = 1, t = 0.001) {
        const A = Math.ceil((this.x + this.width - t) * e) / e,
          r = Math.ceil((this.y + this.height - t) * e) / e;
        return (
          (this.x = Math.floor((this.x + t) * e) / e),
          (this.y = Math.floor((this.y + t) * e) / e),
          (this.width = A - this.x),
          (this.height = r - this.y),
          this
        );
      }
      scale(e, t = e) {
        return (this.x *= e), (this.y *= t), (this.width *= e), (this.height *= t), this;
      }
      enlarge(e) {
        const t = Math.min(this.x, e.x),
          A = Math.max(this.x + this.width, e.x + e.width),
          r = Math.min(this.y, e.y),
          s = Math.max(this.y + this.height, e.y + e.height);
        return (this.x = t), (this.width = A - t), (this.y = r), (this.height = s - r), this;
      }
      getBounds(e) {
        return e || (e = new F()), e.copyFrom(this), e;
      }
      containsRect(e) {
        if (this.width <= 0 || this.height <= 0) return !1;
        const t = e.x,
          A = e.y,
          r = e.x + e.width,
          s = e.y + e.height;
        return (
          t >= this.x &&
          t < this.x + this.width &&
          A >= this.y &&
          A < this.y + this.height &&
          r >= this.x &&
          r < this.x + this.width &&
          s >= this.y &&
          s < this.y + this.height
        );
      }
      set(e, t, A, r) {
        return (this.x = e), (this.y = t), (this.width = A), (this.height = r), this;
      }
      toString() {
        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      }
    }
    const Mr = { default: -1 };
    function z(i = 'default') {
      return Mr[i] === void 0 && (Mr[i] = -1), ++Mr[i];
    }
    const qo = new Set(),
      W = '8.0.0',
      Hl = '8.3.4',
      Ft = { quiet: !1, noColor: !1 },
      P = (i, e, t = 3) => {
        if (Ft.quiet || qo.has(e)) return;
        let A = new Error().stack;
        const r = `${e}
Deprecated since v${i}`,
          s = typeof console.groupCollapsed == 'function' && !Ft.noColor;
        typeof A > 'u' ||
          (A = A.split(
            `
`
          ).splice(t).join(`
`)),
          qo.add(e);
      };
    Object.defineProperties(P, {
      quiet: {
        get: () => Ft.quiet,
        set: (i) => {
          Ft.quiet = i;
        },
        enumerable: !0,
        configurable: !1,
      },
      noColor: {
        get: () => Ft.noColor,
        set: (i) => {
          Ft.noColor = i;
        },
        enumerable: !0,
        configurable: !1,
      },
    });
    const Ds = () => { };
    function xt(i) {
      return (
        (i += i === 0 ? 1 : 0), --i, (i |= i >>> 1), (i |= i >>> 2), (i |= i >>> 4), (i |= i >>> 8), (i |= i >>> 16), i + 1
      );
    }
    function rs(i) {
      return !(i & (i - 1)) && !!i;
    }
    function wA(i) {
      const e = {};
      for (const t in i) i[t] !== void 0 && (e[t] = i[t]);
      return e;
    }
    const Mo = Object.create(null);
    function Bp(i) {
      const e = Mo[i];
      return e === void 0 && (Mo[i] = z('resource')), e;
    }
    const zl = class _l extends ye {
      constructor(e = {}) {
        super(),
          (this._resourceType = 'textureSampler'),
          (this._touched = 0),
          (this._maxAnisotropy = 1),
          (this.destroyed = !1),
          (e = { ..._l.defaultOptions, ...e }),
          (this.addressMode = e.addressMode),
          (this.addressModeU = e.addressModeU ?? this.addressModeU),
          (this.addressModeV = e.addressModeV ?? this.addressModeV),
          (this.addressModeW = e.addressModeW ?? this.addressModeW),
          (this.scaleMode = e.scaleMode),
          (this.magFilter = e.magFilter ?? this.magFilter),
          (this.minFilter = e.minFilter ?? this.minFilter),
          (this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter),
          (this.lodMinClamp = e.lodMinClamp),
          (this.lodMaxClamp = e.lodMaxClamp),
          (this.compare = e.compare),
          (this.maxAnisotropy = e.maxAnisotropy ?? 1);
      }
      set addressMode(e) {
        (this.addressModeU = e), (this.addressModeV = e), (this.addressModeW = e);
      }
      get addressMode() {
        return this.addressModeU;
      }
      set wrapMode(e) {
        P(W, 'TextureStyle.wrapMode is now TextureStyle.addressMode'), (this.addressMode = e);
      }
      get wrapMode() {
        return this.addressMode;
      }
      set scaleMode(e) {
        (this.magFilter = e), (this.minFilter = e), (this.mipmapFilter = e);
      }
      get scaleMode() {
        return this.magFilter;
      }
      set maxAnisotropy(e) {
        (this._maxAnisotropy = Math.min(e, 16)), this._maxAnisotropy > 1 && (this.scaleMode = 'linear');
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      get _resourceId() {
        return this._sharedResourceId || this._generateResourceId();
      }
      update() {
        this.emit('change', this), (this._sharedResourceId = null);
      }
      _generateResourceId() {
        const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        return (this._sharedResourceId = Bp(e)), this._resourceId;
      }
      destroy() {
        (this.destroyed = !0), this.emit('destroy', this), this.emit('change', this), this.removeAllListeners();
      }
    };
    zl.defaultOptions = { addressMode: 'clamp-to-edge', scaleMode: 'linear' };
    let Je = zl;
    const $l = class eh extends ye {
      constructor(e = {}) {
        super(),
          (this.options = e),
          (this.uid = z('textureSource')),
          (this._resourceType = 'textureSource'),
          (this._resourceId = z('resource')),
          (this.uploadMethodId = 'unknown'),
          (this._resolution = 1),
          (this.pixelWidth = 1),
          (this.pixelHeight = 1),
          (this.width = 1),
          (this.height = 1),
          (this.sampleCount = 1),
          (this.mipLevelCount = 1),
          (this.autoGenerateMipmaps = !1),
          (this.format = 'rgba8unorm'),
          (this.dimension = '2d'),
          (this.antialias = !1),
          (this._touched = 0),
          (this._batchTick = -1),
          (this._textureBindLocation = -1),
          (e = { ...eh.defaultOptions, ...e }),
          (this.label = e.label ?? ''),
          (this.resource = e.resource),
          (this.autoGarbageCollect = e.autoGarbageCollect),
          (this._resolution = e.resolution),
          e.width
            ? (this.pixelWidth = e.width * this._resolution)
            : (this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1),
          e.height
            ? (this.pixelHeight = e.height * this._resolution)
            : (this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1),
          (this.width = this.pixelWidth / this._resolution),
          (this.height = this.pixelHeight / this._resolution),
          (this.format = e.format),
          (this.dimension = e.dimensions),
          (this.mipLevelCount = e.mipLevelCount),
          (this.autoGenerateMipmaps = e.autoGenerateMipmaps),
          (this.sampleCount = e.sampleCount),
          (this.antialias = e.antialias),
          (this.alphaMode = e.alphaMode),
          (this.style = new Je(wA(e))),
          (this.destroyed = !1),
          this._refreshPOT();
      }
      get source() {
        return this;
      }
      get style() {
        return this._style;
      }
      set style(e) {
        this.style !== e &&
          (this._style?.off('change', this._onStyleChange, this),
            (this._style = e),
            this._style?.on('change', this._onStyleChange, this),
            this._onStyleChange());
      }
      set maxAnisotropy(e) {
        this._style.maxAnisotropy = e;
      }
      get maxAnisotropy() {
        return this._style.maxAnisotropy;
      }
      get addressMode() {
        return this._style.addressMode;
      }
      set addressMode(e) {
        this._style.addressMode = e;
      }
      get repeatMode() {
        return this._style.addressMode;
      }
      set repeatMode(e) {
        this._style.addressMode = e;
      }
      get magFilter() {
        return this._style.magFilter;
      }
      set magFilter(e) {
        this._style.magFilter = e;
      }
      get minFilter() {
        return this._style.minFilter;
      }
      set minFilter(e) {
        this._style.minFilter = e;
      }
      get mipmapFilter() {
        return this._style.mipmapFilter;
      }
      set mipmapFilter(e) {
        this._style.mipmapFilter = e;
      }
      get lodMinClamp() {
        return this._style.lodMinClamp;
      }
      set lodMinClamp(e) {
        this._style.lodMinClamp = e;
      }
      get lodMaxClamp() {
        return this._style.lodMaxClamp;
      }
      set lodMaxClamp(e) {
        this._style.lodMaxClamp = e;
      }
      _onStyleChange() {
        this.emit('styleChange', this);
      }
      update() {
        if (this.resource) {
          const e = this._resolution;
          if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return;
        }
        this.emit('update', this);
      }
      destroy() {
        (this.destroyed = !0),
          this.emit('destroy', this),
          this.emit('change', this),
          this._style && (this._style.destroy(), (this._style = null)),
          (this.uploadMethodId = null),
          (this.resource = null),
          this.removeAllListeners();
      }
      unload() {
        (this._resourceId = z('resource')), this.emit('change', this), this.emit('unload', this);
      }
      get resourceWidth() {
        const { resource: e } = this;
        return e.naturalWidth || e.videoWidth || e.displayWidth || e.width;
      }
      get resourceHeight() {
        const { resource: e } = this;
        return e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(e) {
        this._resolution !== e &&
          ((this._resolution = e), (this.width = this.pixelWidth / e), (this.height = this.pixelHeight / e));
      }
      resize(e, t, A) {
        A || (A = this._resolution), e || (e = this.width), t || (t = this.height);
        const r = Math.round(e * A),
          s = Math.round(t * A);
        return (
          (this.width = r / A),
          (this.height = s / A),
          (this._resolution = A),
          this.pixelWidth === r && this.pixelHeight === s
            ? !1
            : (this._refreshPOT(),
              (this.pixelWidth = r),
              (this.pixelHeight = s),
              this.emit('resize', this),
              (this._resourceId = z('resource')),
              this.emit('change', this),
              !0)
        );
      }
      updateMipmaps() {
        this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit('updateMipmaps', this);
      }
      set wrapMode(e) {
        this._style.wrapMode = e;
      }
      get wrapMode() {
        return this._style.wrapMode;
      }
      set scaleMode(e) {
        this._style.scaleMode = e;
      }
      get scaleMode() {
        return this._style.scaleMode;
      }
      _refreshPOT() {
        this.isPowerOfTwo = rs(this.pixelWidth) && rs(this.pixelHeight);
      }
      static test(e) {
        throw new Error('Unimplemented');
      }
    };
    $l.defaultOptions = {
      resolution: 1,
      format: 'bgra8unorm',
      alphaMode: 'premultiply-alpha-on-upload',
      dimensions: '2d',
      mipLevelCount: 1,
      autoGenerateMipmaps: !1,
      sampleCount: 1,
      antialias: !1,
      autoGarbageCollect: !1,
    };
    let ne = $l;
    class Di extends ne {
      constructor(e) {
        const t = e.resource || new Float32Array(e.width * e.height * 4);
        let A = e.format;
        A ||
          (t instanceof Float32Array
            ? (A = 'rgba32float')
            : t instanceof Int32Array || t instanceof Uint32Array
              ? (A = 'rgba32uint')
              : t instanceof Int16Array || t instanceof Uint16Array
                ? (A = 'rgba16uint')
                : (t instanceof Int8Array, (A = 'bgra8unorm'))),
          super({ ...e, resource: t, format: A }),
          (this.uploadMethodId = 'buffer');
      }
      static test(e) {
        return (
          e instanceof Int8Array ||
          e instanceof Uint8Array ||
          e instanceof Uint8ClampedArray ||
          e instanceof Int16Array ||
          e instanceof Uint16Array ||
          e instanceof Int32Array ||
          e instanceof Uint32Array ||
          e instanceof Float32Array
        );
      }
    }
    Di.extension = M.TextureSource;
    const Eo = new R();
    class Os {
      constructor(e, t) {
        (this.mapCoord = new R()),
          (this.uClampFrame = new Float32Array(4)),
          (this.uClampOffset = new Float32Array(2)),
          (this._textureID = -1),
          (this._updateID = 0),
          (this.clampOffset = 0),
          typeof t > 'u' ? (this.clampMargin = e.width < 10 ? 0 : 0.5) : (this.clampMargin = t),
          (this.isSimple = !1),
          (this.texture = e);
      }
      get texture() {
        return this._texture;
      }
      set texture(e) {
        this.texture !== e &&
          (this._texture?.removeListener('update', this.update, this),
            (this._texture = e),
            this._texture.addListener('update', this.update, this),
            this.update());
      }
      multiplyUvs(e, t) {
        t === void 0 && (t = e);
        const A = this.mapCoord;
        for (let r = 0; r < e.length; r += 2) {
          const s = e[r],
            n = e[r + 1];
          (t[r] = s * A.a + n * A.c + A.tx), (t[r + 1] = s * A.b + n * A.d + A.ty);
        }
        return t;
      }
      update() {
        const e = this._texture;
        this._updateID++;
        const t = e.uvs;
        this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0);
        const A = e.orig,
          r = e.trim;
        r && (Eo.set(A.width / r.width, 0, 0, A.height / r.height, -r.x / r.width, -r.y / r.height), this.mapCoord.append(Eo));
        const s = e.source,
          n = this.uClampFrame,
          a = this.clampMargin / s._resolution,
          l = this.clampOffset / s._resolution;
        return (
          (n[0] = (e.frame.x + a + l) / s.width),
          (n[1] = (e.frame.y + a + l) / s.height),
          (n[2] = (e.frame.x + e.frame.width - a + l) / s.width),
          (n[3] = (e.frame.y + e.frame.height - a + l) / s.height),
          (this.uClampOffset[0] = this.clampOffset / s.pixelWidth),
          (this.uClampOffset[1] = this.clampOffset / s.pixelHeight),
          (this.isSimple = e.frame.width === s.width && e.frame.height === s.height && e.rotate === 0),
          !0
        );
      }
    }
    class v extends ye {
      constructor({
        source: e,
        label: t,
        frame: A,
        orig: r,
        trim: s,
        defaultAnchor: n,
        defaultBorders: a,
        rotate: l,
        dynamic: h,
      } = {}) {
        if (
          (super(),
            (this.uid = z('texture')),
            (this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }),
            (this.frame = new F()),
            (this.noFrame = !1),
            (this.dynamic = !1),
            (this.isTexture = !0),
            (this.label = t),
            (this.source = e?.source ?? new ne()),
            (this.noFrame = !A),
            A)
        )
          this.frame.copyFrom(A);
        else {
          const { width: u, height: o } = this._source;
          (this.frame.width = u), (this.frame.height = o);
        }
        (this.orig = r || this.frame),
          (this.trim = s),
          (this.rotate = l ?? 0),
          (this.defaultAnchor = n),
          (this.defaultBorders = a),
          (this.destroyed = !1),
          (this.dynamic = h || !1),
          this.updateUvs();
      }
      set source(e) {
        this._source && this._source.off('resize', this.update, this),
          (this._source = e),
          e.on('resize', this.update, this),
          this.emit('update', this);
      }
      get source() {
        return this._source;
      }
      get textureMatrix() {
        return this._textureMatrix || (this._textureMatrix = new Os(this)), this._textureMatrix;
      }
      get width() {
        return this.orig.width;
      }
      get height() {
        return this.orig.height;
      }
      updateUvs() {
        const { uvs: e, frame: t } = this,
          { width: A, height: r } = this._source,
          s = t.x / A,
          n = t.y / r,
          a = t.width / A,
          l = t.height / r;
        let h = this.rotate;
        if (h) {
          const u = a / 2,
            o = l / 2,
            c = s + u,
            d = n + o;
          (h = j.add(h, j.NW)),
            (e.x0 = c + u * j.uX(h)),
            (e.y0 = d + o * j.uY(h)),
            (h = j.add(h, 2)),
            (e.x1 = c + u * j.uX(h)),
            (e.y1 = d + o * j.uY(h)),
            (h = j.add(h, 2)),
            (e.x2 = c + u * j.uX(h)),
            (e.y2 = d + o * j.uY(h)),
            (h = j.add(h, 2)),
            (e.x3 = c + u * j.uX(h)),
            (e.y3 = d + o * j.uY(h));
        } else (e.x0 = s), (e.y0 = n), (e.x1 = s + a), (e.y1 = n), (e.x2 = s + a), (e.y2 = n + l), (e.x3 = s), (e.y3 = n + l);
      }
      destroy(e = !1) {
        this._source && (this._source.off('resize', this.update, this), e && (this._source.destroy(), (this._source = null))),
          (this._textureMatrix = null),
          (this.destroyed = !0),
          this.emit('destroy', this),
          this.removeAllListeners();
      }
      update() {
        this.noFrame && ((this.frame.width = this._source.width), (this.frame.height = this._source.height)),
          this.updateUvs(),
          this.emit('update', this);
      }
      get baseTexture() {
        return P(W, 'Texture.baseTexture is now Texture.source'), this._source;
      }
    }
    v.EMPTY = new v({ label: 'EMPTY', source: new ne({ label: 'EMPTY' }) });
    v.EMPTY.destroy = Ds;
    v.WHITE = new v({
      source: new Di({
        resource: new Uint8Array([255, 255, 255, 255]),
        width: 1,
        height: 1,
        alphaMode: 'premultiply-alpha-on-upload',
        label: 'WHITE',
      }),
      label: 'WHITE',
    });
    v.WHITE.destroy = Ds;
    function Ls(i, e, t) {
      const { width: A, height: r } = t.orig,
        s = t.trim;
      if (s) {
        const n = s.width,
          a = s.height;
        (i.minX = s.x - e._x * A), (i.maxX = i.minX + n), (i.minY = s.y - e._y * r), (i.maxY = i.minY + a);
      } else (i.minX = -e._x * A), (i.maxX = i.minX + A), (i.minY = -e._y * r), (i.maxY = i.minY + r);
    }
    const Vo = new R();
    class de {
      constructor(e = 1 / 0, t = 1 / 0, A = -1 / 0, r = -1 / 0) {
        (this.minX = 1 / 0),
          (this.minY = 1 / 0),
          (this.maxX = -1 / 0),
          (this.maxY = -1 / 0),
          (this.matrix = Vo),
          (this.minX = e),
          (this.minY = t),
          (this.maxX = A),
          (this.maxY = r);
      }
      isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
      }
      get rectangle() {
        this._rectangle || (this._rectangle = new F());
        const e = this._rectangle;
        return (
          this.minX > this.maxX || this.minY > this.maxY
            ? ((e.x = 0), (e.y = 0), (e.width = 0), (e.height = 0))
            : e.copyFromBounds(this),
          e
        );
      }
      clear() {
        return (this.minX = 1 / 0), (this.minY = 1 / 0), (this.maxX = -1 / 0), (this.maxY = -1 / 0), (this.matrix = Vo), this;
      }
      set(e, t, A, r) {
        (this.minX = e), (this.minY = t), (this.maxX = A), (this.maxY = r);
      }
      addFrame(e, t, A, r, s) {
        s || (s = this.matrix);
        const n = s.a,
          a = s.b,
          l = s.c,
          h = s.d,
          u = s.tx,
          o = s.ty;
        let c = this.minX,
          d = this.minY,
          f = this.maxX,
          g = this.maxY,
          p = n * e + l * t + u,
          m = a * e + h * t + o;
        p < c && (c = p),
          m < d && (d = m),
          p > f && (f = p),
          m > g && (g = m),
          (p = n * A + l * t + u),
          (m = a * A + h * t + o),
          p < c && (c = p),
          m < d && (d = m),
          p > f && (f = p),
          m > g && (g = m),
          (p = n * e + l * r + u),
          (m = a * e + h * r + o),
          p < c && (c = p),
          m < d && (d = m),
          p > f && (f = p),
          m > g && (g = m),
          (p = n * A + l * r + u),
          (m = a * A + h * r + o),
          p < c && (c = p),
          m < d && (d = m),
          p > f && (f = p),
          m > g && (g = m),
          (this.minX = c),
          (this.minY = d),
          (this.maxX = f),
          (this.maxY = g);
      }
      addRect(e, t) {
        this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t);
      }
      addBounds(e, t) {
        this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t);
      }
      addBoundsMask(e) {
        (this.minX = this.minX > e.minX ? this.minX : e.minX),
          (this.minY = this.minY > e.minY ? this.minY : e.minY),
          (this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX),
          (this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY);
      }
      applyMatrix(e) {
        const t = this.minX,
          A = this.minY,
          r = this.maxX,
          s = this.maxY,
          { a: n, b: a, c: l, d: h, tx: u, ty: o } = e;
        let c = n * t + l * A + u,
          d = a * t + h * A + o;
        (this.minX = c),
          (this.minY = d),
          (this.maxX = c),
          (this.maxY = d),
          (c = n * r + l * A + u),
          (d = a * r + h * A + o),
          (this.minX = c < this.minX ? c : this.minX),
          (this.minY = d < this.minY ? d : this.minY),
          (this.maxX = c > this.maxX ? c : this.maxX),
          (this.maxY = d > this.maxY ? d : this.maxY),
          (c = n * t + l * s + u),
          (d = a * t + h * s + o),
          (this.minX = c < this.minX ? c : this.minX),
          (this.minY = d < this.minY ? d : this.minY),
          (this.maxX = c > this.maxX ? c : this.maxX),
          (this.maxY = d > this.maxY ? d : this.maxY),
          (c = n * r + l * s + u),
          (d = a * r + h * s + o),
          (this.minX = c < this.minX ? c : this.minX),
          (this.minY = d < this.minY ? d : this.minY),
          (this.maxX = c > this.maxX ? c : this.maxX),
          (this.maxY = d > this.maxY ? d : this.maxY);
      }
      fit(e) {
        return (
          this.minX < e.left && (this.minX = e.left),
          this.maxX > e.right && (this.maxX = e.right),
          this.minY < e.top && (this.minY = e.top),
          this.maxY > e.bottom && (this.maxY = e.bottom),
          this
        );
      }
      fitBounds(e, t, A, r) {
        return (
          this.minX < e && (this.minX = e),
          this.maxX > t && (this.maxX = t),
          this.minY < A && (this.minY = A),
          this.maxY > r && (this.maxY = r),
          this
        );
      }
      pad(e, t = e) {
        return (this.minX -= e), (this.maxX += e), (this.minY -= t), (this.maxY += t), this;
      }
      ceil() {
        return (
          (this.minX = Math.floor(this.minX)),
          (this.minY = Math.floor(this.minY)),
          (this.maxX = Math.ceil(this.maxX)),
          (this.maxY = Math.ceil(this.maxY)),
          this
        );
      }
      clone() {
        return new de(this.minX, this.minY, this.maxX, this.maxY);
      }
      scale(e, t = e) {
        return (this.minX *= e), (this.minY *= t), (this.maxX *= e), (this.maxY *= t), this;
      }
      get x() {
        return this.minX;
      }
      set x(e) {
        const t = this.maxX - this.minX;
        (this.minX = e), (this.maxX = e + t);
      }
      get y() {
        return this.minY;
      }
      set y(e) {
        const t = this.maxY - this.minY;
        (this.minY = e), (this.maxY = e + t);
      }
      get width() {
        return this.maxX - this.minX;
      }
      set width(e) {
        this.maxX = this.minX + e;
      }
      get height() {
        return this.maxY - this.minY;
      }
      set height(e) {
        this.maxY = this.minY + e;
      }
      get left() {
        return this.minX;
      }
      get right() {
        return this.maxX;
      }
      get top() {
        return this.minY;
      }
      get bottom() {
        return this.maxY;
      }
      get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
      }
      get isValid() {
        return this.minX + this.minY !== 1 / 0;
      }
      addVertexData(e, t, A, r) {
        let s = this.minX,
          n = this.minY,
          a = this.maxX,
          l = this.maxY;
        r || (r = this.matrix);
        const h = r.a,
          u = r.b,
          o = r.c,
          c = r.d,
          d = r.tx,
          f = r.ty;
        for (let g = t; g < A; g += 2) {
          const p = e[g],
            m = e[g + 1],
            S = h * p + o * m + d,
            q = u * p + c * m + f;
          (s = S < s ? S : s), (n = q < n ? q : n), (a = S > a ? S : a), (l = q > l ? q : l);
        }
        (this.minX = s), (this.minY = n), (this.maxX = a), (this.maxY = l);
      }
      containsPoint(e, t) {
        return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t;
      }
      toString() {
        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
      }
      copyFrom(e) {
        return (this.minX = e.minX), (this.minY = e.minY), (this.maxX = e.maxX), (this.maxY = e.maxY), this;
      }
    }
    var Np = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) },
      He = function (i) {
        return typeof i == 'string' ? i.length > 0 : typeof i == 'number';
      },
      he = function (i, e, t) {
        return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * i) / t + 0;
      },
      Qe = function (i, e, t) {
        return e === void 0 && (e = 0), t === void 0 && (t = 1), i > t ? t : i > e ? i : e;
      },
      th = function (i) {
        return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360;
      },
      To = function (i) {
        return { r: Qe(i.r, 0, 255), g: Qe(i.g, 0, 255), b: Qe(i.b, 0, 255), a: Qe(i.a) };
      },
      Er = function (i) {
        return { r: he(i.r), g: he(i.g), b: he(i.b), a: he(i.a, 3) };
      },
      Qp = /^#([0-9a-f]{3,8})$/i,
      ai = function (i) {
        var e = i.toString(16);
        return e.length < 2 ? '0' + e : e;
      },
      Ah = function (i) {
        var e = i.r,
          t = i.g,
          A = i.b,
          r = i.a,
          s = Math.max(e, t, A),
          n = s - Math.min(e, t, A),
          a = n ? (s === e ? (t - A) / n : s === t ? 2 + (A - e) / n : 4 + (e - t) / n) : 0;
        return { h: 60 * (a < 0 ? a + 6 : a), s: s ? (n / s) * 100 : 0, v: (s / 255) * 100, a: r };
      },
      ih = function (i) {
        var e = i.h,
          t = i.s,
          A = i.v,
          r = i.a;
        (e = (e / 360) * 6), (t /= 100), (A /= 100);
        var s = Math.floor(e),
          n = A * (1 - t),
          a = A * (1 - (e - s) * t),
          l = A * (1 - (1 - e + s) * t),
          h = s % 6;
        return { r: 255 * [A, a, n, n, l, A][h], g: 255 * [l, A, A, a, n, n][h], b: 255 * [n, n, l, A, A, a][h], a: r };
      },
      Io = function (i) {
        return { h: th(i.h), s: Qe(i.s, 0, 100), l: Qe(i.l, 0, 100), a: Qe(i.a) };
      },
      bo = function (i) {
        return { h: he(i.h), s: he(i.s), l: he(i.l), a: he(i.a, 3) };
      },
      yo = function (i) {
        return ih(
          ((t = (e = i).s),
            { h: e.h, s: (t *= ((A = e.l) < 50 ? A : 100 - A) / 100) > 0 ? ((2 * t) / (A + t)) * 100 : 0, v: A + t, a: e.a })
        );
        var e, t, A;
      },
      vA = function (i) {
        return {
          h: (e = Ah(i)).h,
          s: (r = ((200 - (t = e.s)) * (A = e.v)) / 100) > 0 && r < 200 ? ((t * A) / 100 / (r <= 100 ? r : 200 - r)) * 100 : 0,
          l: r / 2,
          a: e.a,
        };
        var e, t, A, r;
      },
      wp =
        /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      Pp =
        /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      Jp =
        /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      Gp =
        /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
      ss = {
        string: [
          [
            function (i) {
              var e = Qp.exec(i);
              return e
                ? (i = e[1]).length <= 4
                  ? {
                    r: parseInt(i[0] + i[0], 16),
                    g: parseInt(i[1] + i[1], 16),
                    b: parseInt(i[2] + i[2], 16),
                    a: i.length === 4 ? he(parseInt(i[3] + i[3], 16) / 255, 2) : 1,
                  }
                  : i.length === 6 || i.length === 8
                    ? {
                      r: parseInt(i.substr(0, 2), 16),
                      g: parseInt(i.substr(2, 2), 16),
                      b: parseInt(i.substr(4, 2), 16),
                      a: i.length === 8 ? he(parseInt(i.substr(6, 2), 16) / 255, 2) : 1,
                    }
                    : null
                : null;
            },
            'hex',
          ],
          [
            function (i) {
              var e = Jp.exec(i) || Gp.exec(i);
              return e
                ? e[2] !== e[4] || e[4] !== e[6]
                  ? null
                  : To({
                    r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                    g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                    b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                    a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1),
                  })
                : null;
            },
            'rgb',
          ],
          [
            function (i) {
              var e = wp.exec(i) || Pp.exec(i);
              if (!e) return null;
              var t,
                A,
                r = Io({
                  h: ((t = e[1]), (A = e[2]), A === void 0 && (A = 'deg'), Number(t) * (Np[A] || 1)),
                  s: Number(e[3]),
                  l: Number(e[4]),
                  a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1),
                });
              return yo(r);
            },
            'hsl',
          ],
        ],
        object: [
          [
            function (i) {
              var e = i.r,
                t = i.g,
                A = i.b,
                r = i.a,
                s = r === void 0 ? 1 : r;
              return He(e) && He(t) && He(A) ? To({ r: Number(e), g: Number(t), b: Number(A), a: Number(s) }) : null;
            },
            'rgb',
          ],
          [
            function (i) {
              var e = i.h,
                t = i.s,
                A = i.l,
                r = i.a,
                s = r === void 0 ? 1 : r;
              if (!He(e) || !He(t) || !He(A)) return null;
              var n = Io({ h: Number(e), s: Number(t), l: Number(A), a: Number(s) });
              return yo(n);
            },
            'hsl',
          ],
          [
            function (i) {
              var e = i.h,
                t = i.s,
                A = i.v,
                r = i.a,
                s = r === void 0 ? 1 : r;
              if (!He(e) || !He(t) || !He(A)) return null;
              var n = (function (a) {
                return { h: th(a.h), s: Qe(a.s, 0, 100), v: Qe(a.v, 0, 100), a: Qe(a.a) };
              })({ h: Number(e), s: Number(t), v: Number(A), a: Number(s) });
              return ih(n);
            },
            'hsv',
          ],
        ],
      },
      xo = function (i, e) {
        for (var t = 0; t < e.length; t++) {
          var A = e[t][0](i);
          if (A) return [A, e[t][1]];
        }
        return [null, void 0];
      },
      Wp = function (i) {
        return typeof i == 'string'
          ? xo(i.trim(), ss.string)
          : typeof i == 'object' && i !== null
            ? xo(i, ss.object)
            : [null, void 0];
      },
      Vr = function (i, e) {
        var t = vA(i);
        return { h: t.h, s: Qe(t.s + 100 * e, 0, 100), l: t.l, a: t.a };
      },
      Tr = function (i) {
        return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255;
      },
      vo = function (i, e) {
        var t = vA(i);
        return { h: t.h, s: t.s, l: Qe(t.l + 100 * e, 0, 100), a: t.a };
      },
      ns = (function () {
        function i(e) {
          (this.parsed = Wp(e)[0]), (this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 });
        }
        return (
          (i.prototype.isValid = function () {
            return this.parsed !== null;
          }),
          (i.prototype.brightness = function () {
            return he(Tr(this.rgba), 2);
          }),
          (i.prototype.isDark = function () {
            return Tr(this.rgba) < 0.5;
          }),
          (i.prototype.isLight = function () {
            return Tr(this.rgba) >= 0.5;
          }),
          (i.prototype.toHex = function () {
            return (
              (e = Er(this.rgba)),
              (t = e.r),
              (A = e.g),
              (r = e.b),
              (n = (s = e.a) < 1 ? ai(he(255 * s)) : ''),
              '#' + ai(t) + ai(A) + ai(r) + n
            );
            var e, t, A, r, s, n;
          }),
          (i.prototype.toRgb = function () {
            return Er(this.rgba);
          }),
          (i.prototype.toRgbString = function () {
            return (
              (e = Er(this.rgba)),
              (t = e.r),
              (A = e.g),
              (r = e.b),
              (s = e.a) < 1 ? 'rgba(' + t + ', ' + A + ', ' + r + ', ' + s + ')' : 'rgb(' + t + ', ' + A + ', ' + r + ')'
            );
            var e, t, A, r, s;
          }),
          (i.prototype.toHsl = function () {
            return bo(vA(this.rgba));
          }),
          (i.prototype.toHslString = function () {
            return (
              (e = bo(vA(this.rgba))),
              (t = e.h),
              (A = e.s),
              (r = e.l),
              (s = e.a) < 1 ? 'hsla(' + t + ', ' + A + '%, ' + r + '%, ' + s + ')' : 'hsl(' + t + ', ' + A + '%, ' + r + '%)'
            );
            var e, t, A, r, s;
          }),
          (i.prototype.toHsv = function () {
            return (e = Ah(this.rgba)), { h: he(e.h), s: he(e.s), v: he(e.v), a: he(e.a, 3) };
            var e;
          }),
          (i.prototype.invert = function () {
            return We({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a });
            var e;
          }),
          (i.prototype.saturate = function (e) {
            return e === void 0 && (e = 0.1), We(Vr(this.rgba, e));
          }),
          (i.prototype.desaturate = function (e) {
            return e === void 0 && (e = 0.1), We(Vr(this.rgba, -e));
          }),
          (i.prototype.grayscale = function () {
            return We(Vr(this.rgba, -1));
          }),
          (i.prototype.lighten = function (e) {
            return e === void 0 && (e = 0.1), We(vo(this.rgba, e));
          }),
          (i.prototype.darken = function (e) {
            return e === void 0 && (e = 0.1), We(vo(this.rgba, -e));
          }),
          (i.prototype.rotate = function (e) {
            return e === void 0 && (e = 15), this.hue(this.hue() + e);
          }),
          (i.prototype.alpha = function (e) {
            return typeof e == 'number' ? We({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e }) : he(this.rgba.a, 3);
            var t;
          }),
          (i.prototype.hue = function (e) {
            var t = vA(this.rgba);
            return typeof e == 'number' ? We({ h: e, s: t.s, l: t.l, a: t.a }) : he(t.h);
          }),
          (i.prototype.isEqual = function (e) {
            return this.toHex() === We(e).toHex();
          }),
          i
        );
      })(),
      We = function (i) {
        return i instanceof ns ? i : new ns(i);
      },
      Co = [],
      Kp = function (i) {
        i.forEach(function (e) {
          Co.indexOf(e) < 0 && (e(ns, ss), Co.push(e));
        });
      };
    function Fp(i, e) {
      var t = {
        white: '#ffffff',
        bisque: '#ffe4c4',
        blue: '#0000ff',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        azure: '#f0ffff',
        whitesmoke: '#f5f5f5',
        papayawhip: '#ffefd5',
        plum: '#dda0dd',
        blanchedalmond: '#ffebcd',
        black: '#000000',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gainsboro: '#dcdcdc',
        cornsilk: '#fff8dc',
        cornflowerblue: '#6495ed',
        burlywood: '#deb887',
        aquamarine: '#7fffd4',
        beige: '#f5f5dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkkhaki: '#bdb76b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        peachpuff: '#ffdab9',
        darkmagenta: '#8b008b',
        darkred: '#8b0000',
        darkorchid: '#9932cc',
        darkorange: '#ff8c00',
        darkslateblue: '#483d8b',
        gray: '#808080',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        wheat: '#f5deb3',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        ghostwhite: '#f8f8ff',
        darkviolet: '#9400d3',
        magenta: '#ff00ff',
        green: '#008000',
        dodgerblue: '#1e90ff',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        blueviolet: '#8a2be2',
        forestgreen: '#228b22',
        lawngreen: '#7cfc00',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        fuchsia: '#ff00ff',
        brown: '#a52a2a',
        maroon: '#800000',
        mediumblue: '#0000cd',
        lightcoral: '#f08080',
        darkturquoise: '#00ced1',
        lightcyan: '#e0ffff',
        ivory: '#fffff0',
        lightyellow: '#ffffe0',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        linen: '#faf0e6',
        mediumaquamarine: '#66cdaa',
        lemonchiffon: '#fffacd',
        lime: '#00ff00',
        khaki: '#f0e68c',
        mediumseagreen: '#3cb371',
        limegreen: '#32cd32',
        mediumspringgreen: '#00fa9a',
        lightskyblue: '#87cefa',
        lightblue: '#add8e6',
        midnightblue: '#191970',
        lightpink: '#ffb6c1',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        mintcream: '#f5fffa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        navajowhite: '#ffdead',
        navy: '#000080',
        mediumvioletred: '#c71585',
        powderblue: '#b0e0e6',
        palegoldenrod: '#eee8aa',
        oldlace: '#fdf5e6',
        paleturquoise: '#afeeee',
        mediumturquoise: '#48d1cc',
        mediumorchid: '#ba55d3',
        rebeccapurple: '#663399',
        lightsteelblue: '#b0c4de',
        mediumslateblue: '#7b68ee',
        thistle: '#d8bfd8',
        tan: '#d2b48c',
        orchid: '#da70d6',
        mediumpurple: '#9370db',
        purple: '#800080',
        pink: '#ffc0cb',
        skyblue: '#87ceeb',
        springgreen: '#00ff7f',
        palegreen: '#98fb98',
        red: '#ff0000',
        yellow: '#ffff00',
        slateblue: '#6a5acd',
        lavenderblush: '#fff0f5',
        peru: '#cd853f',
        palevioletred: '#db7093',
        violet: '#ee82ee',
        teal: '#008080',
        slategray: '#708090',
        slategrey: '#708090',
        aliceblue: '#f0f8ff',
        darkseagreen: '#8fbc8f',
        darkolivegreen: '#556b2f',
        greenyellow: '#adff2f',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        tomato: '#ff6347',
        silver: '#c0c0c0',
        sienna: '#a0522d',
        lavender: '#e6e6fa',
        lightgreen: '#90ee90',
        orange: '#ffa500',
        orangered: '#ff4500',
        steelblue: '#4682b4',
        royalblue: '#4169e1',
        turquoise: '#40e0d0',
        yellowgreen: '#9acd32',
        salmon: '#fa8072',
        saddlebrown: '#8b4513',
        sandybrown: '#f4a460',
        rosybrown: '#bc8f8f',
        darksalmon: '#e9967a',
        lightgoldenrodyellow: '#fafad2',
        snow: '#fffafa',
        lightgrey: '#d3d3d3',
        lightgray: '#d3d3d3',
        dimgray: '#696969',
        dimgrey: '#696969',
        olivedrab: '#6b8e23',
        olive: '#808000',
      },
        A = {};
      for (var r in t) A[t[r]] = r;
      var s = {};
      (i.prototype.toName = function (n) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return 'transparent';
        var a,
          l,
          h = A[this.toHex()];
        if (h) return h;
        if (n?.closest) {
          var u = this.toRgb(),
            o = 1 / 0,
            c = 'black';
          if (!s.length) for (var d in t) s[d] = new i(t[d]).toRgb();
          for (var f in t) {
            var g = ((a = u), (l = s[f]), Math.pow(a.r - l.r, 2) + Math.pow(a.g - l.g, 2) + Math.pow(a.b - l.b, 2));
            g < o && ((o = g), (c = f));
          }
          return c;
        }
      }),
        e.string.push([
          function (n) {
            var a = n.toLowerCase(),
              l = a === 'transparent' ? '#0000' : t[a];
            return l ? new i(l).toRgb() : null;
          },
          'name',
        ]);
    }
    Kp([Fp]);
    const zt = class bA {
      constructor(e = 16777215) {
        (this._value = null),
          (this._components = new Float32Array(4)),
          this._components.fill(1),
          (this._int = 16777215),
          (this.value = e);
      }
      get red() {
        return this._components[0];
      }
      get green() {
        return this._components[1];
      }
      get blue() {
        return this._components[2];
      }
      get alpha() {
        return this._components[3];
      }
      setValue(e) {
        return (this.value = e), this;
      }
      set value(e) {
        if (e instanceof bA)
          (this._value = this._cloneSource(e._value)), (this._int = e._int), this._components.set(e._components);
        else {
          if (e === null) throw new Error('Cannot set Color#value to null');
          (this._value === null || !this._isSourceEqual(this._value, e)) &&
            ((this._value = this._cloneSource(e)), this._normalize(this._value));
        }
      }
      get value() {
        return this._value;
      }
      _cloneSource(e) {
        return typeof e == 'string' || typeof e == 'number' || e instanceof Number || e === null
          ? e
          : Array.isArray(e) || ArrayBuffer.isView(e)
            ? e.slice(0)
            : typeof e == 'object' && e !== null
              ? { ...e }
              : e;
      }
      _isSourceEqual(e, t) {
        const A = typeof e;
        if (A !== typeof t) return !1;
        if (A === 'number' || A === 'string' || e instanceof Number) return e === t;
        if ((Array.isArray(e) && Array.isArray(t)) || (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)))
          return e.length !== t.length ? !1 : e.every((s, n) => s === t[n]);
        if (e !== null && t !== null) {
          const s = Object.keys(e),
            n = Object.keys(t);
          return s.length !== n.length ? !1 : s.every((a) => e[a] === t[a]);
        }
        return e === t;
      }
      toRgba() {
        const [e, t, A, r] = this._components;
        return { r: e, g: t, b: A, a: r };
      }
      toRgb() {
        const [e, t, A] = this._components;
        return { r: e, g: t, b: A };
      }
      toRgbaString() {
        const [e, t, A] = this.toUint8RgbArray();
        return `rgba(${e},${t},${A},${this.alpha})`;
      }
      toUint8RgbArray(e) {
        const [t, A, r] = this._components;
        return (
          this._arrayRgb || (this._arrayRgb = []),
          e || (e = this._arrayRgb),
          (e[0] = Math.round(t * 255)),
          (e[1] = Math.round(A * 255)),
          (e[2] = Math.round(r * 255)),
          e
        );
      }
      toArray(e) {
        this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
        const [t, A, r, s] = this._components;
        return (e[0] = t), (e[1] = A), (e[2] = r), (e[3] = s), e;
      }
      toRgbArray(e) {
        this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
        const [t, A, r] = this._components;
        return (e[0] = t), (e[1] = A), (e[2] = r), e;
      }
      toNumber() {
        return this._int;
      }
      toBgrNumber() {
        const [e, t, A] = this.toUint8RgbArray();
        return (A << 16) + (t << 8) + e;
      }
      toLittleEndianNumber() {
        const e = this._int;
        return (e >> 16) + (e & 65280) + ((e & 255) << 16);
      }
      multiply(e) {
        const [t, A, r, s] = bA._temp.setValue(e)._components;
        return (
          (this._components[0] *= t),
          (this._components[1] *= A),
          (this._components[2] *= r),
          (this._components[3] *= s),
          this._refreshInt(),
          (this._value = null),
          this
        );
      }
      premultiply(e, t = !0) {
        return (
          t && ((this._components[0] *= e), (this._components[1] *= e), (this._components[2] *= e)),
          (this._components[3] = e),
          this._refreshInt(),
          (this._value = null),
          this
        );
      }
      toPremultiplied(e, t = !0) {
        if (e === 1) return (255 << 24) + this._int;
        if (e === 0) return t ? 0 : this._int;
        let A = (this._int >> 16) & 255,
          r = (this._int >> 8) & 255,
          s = this._int & 255;
        return (
          t && ((A = (A * e + 0.5) | 0), (r = (r * e + 0.5) | 0), (s = (s * e + 0.5) | 0)),
          ((e * 255) << 24) + (A << 16) + (r << 8) + s
        );
      }
      toHex() {
        const e = this._int.toString(16);
        return `#${'000000'.substring(0, 6 - e.length) + e}`;
      }
      toHexa() {
        const t = Math.round(this._components[3] * 255).toString(16);
        return this.toHex() + '00'.substring(0, 2 - t.length) + t;
      }
      setAlpha(e) {
        return (this._components[3] = this._clamp(e)), this;
      }
      _normalize(e) {
        let t, A, r, s;
        if ((typeof e == 'number' || e instanceof Number) && e >= 0 && e <= 16777215) {
          const n = e;
          (t = ((n >> 16) & 255) / 255), (A = ((n >> 8) & 255) / 255), (r = (n & 255) / 255), (s = 1);
        } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4)
          (e = this._clamp(e)), ([t, A, r, s = 1] = e);
        else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4)
          (e = this._clamp(e, 0, 255)), ([t, A, r, s = 255] = e), (t /= 255), (A /= 255), (r /= 255), (s /= 255);
        else if (typeof e == 'string' || typeof e == 'object') {
          if (typeof e == 'string') {
            const a = bA.HEX_PATTERN.exec(e);
            a && (e = `#${a[2]}`);
          }
          const n = We(e);
          n.isValid() && (({ r: t, g: A, b: r, a: s } = n.rgba), (t /= 255), (A /= 255), (r /= 255));
        }
        if (t !== void 0)
          (this._components[0] = t),
            (this._components[1] = A),
            (this._components[2] = r),
            (this._components[3] = s),
            this._refreshInt();
        else throw new Error(`Unable to convert color ${e}`);
      }
      _refreshInt() {
        this._clamp(this._components);
        const [e, t, A] = this._components;
        this._int = ((e * 255) << 16) + ((t * 255) << 8) + ((A * 255) | 0);
      }
      _clamp(e, t = 0, A = 1) {
        return typeof e == 'number'
          ? Math.min(Math.max(e, t), A)
          : (e.forEach((r, s) => {
            e[s] = Math.min(Math.max(r, t), A);
          }),
            e);
      }
      static isColorLike(e) {
        return (
          typeof e == 'number' ||
          typeof e == 'string' ||
          e instanceof Number ||
          e instanceof bA ||
          Array.isArray(e) ||
          e instanceof Uint8Array ||
          e instanceof Uint8ClampedArray ||
          e instanceof Float32Array ||
          (e.r !== void 0 && e.g !== void 0 && e.b !== void 0) ||
          (e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0) ||
          (e.h !== void 0 && e.s !== void 0 && e.l !== void 0) ||
          (e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0) ||
          (e.h !== void 0 && e.s !== void 0 && e.v !== void 0) ||
          (e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0)
        );
      }
    };
    zt.shared = new zt();
    zt._temp = new zt();
    zt.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    let $ = zt;
    const rh = { cullArea: null, cullable: !1, cullableChildren: !0 };
    let Ir = 0;
    const Uo = 500;
    function N(...i) {
      Ir !== Uo && Ir++;
    }
    const kt = {
      _registeredResources: new Set(),
      register(i) {
        this._registeredResources.add(i);
      },
      unregister(i) {
        this._registeredResources.delete(i);
      },
      release() {
        this._registeredResources.forEach((i) => i.clear());
      },
      get registeredCount() {
        return this._registeredResources.size;
      },
      isRegistered(i) {
        return this._registeredResources.has(i);
      },
      reset() {
        this._registeredResources.clear();
      },
    };
    class sh {
      constructor(e, t) {
        (this._pool = []), (this._count = 0), (this._index = 0), (this._classType = e), t && this.prepopulate(t);
      }
      prepopulate(e) {
        for (let t = 0; t < e; t++) this._pool[this._index++] = new this._classType();
        this._count += e;
      }
      get(e) {
        let t;
        return this._index > 0 ? (t = this._pool[--this._index]) : ((t = new this._classType()), this._count++), t.init?.(e), t;
      }
      return(e) {
        e.reset?.(), (this._pool[this._index++] = e);
      }
      get totalSize() {
        return this._count;
      }
      get totalFree() {
        return this._index;
      }
      get totalUsed() {
        return this._count - this._index;
      }
      clear() {
        if (this._pool.length > 0 && this._pool[0].destroy) for (let e = 0; e < this._index; e++) this._pool[e].destroy();
        (this._pool.length = 0), (this._count = 0), (this._index = 0);
      }
    }
    class nh {
      constructor() {
        this._poolsByClass = new Map();
      }
      prepopulate(e, t) {
        this.getPool(e).prepopulate(t);
      }
      get(e, t) {
        return this.getPool(e).get(t);
      }
      return(e) {
        this.getPool(e.constructor).return(e);
      }
      getPool(e) {
        return this._poolsByClass.has(e) || this._poolsByClass.set(e, new sh(e)), this._poolsByClass.get(e);
      }
      stats() {
        const e = {};
        return (
          this._poolsByClass.forEach((t) => {
            const A = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name;
            e[A] = { free: t.totalFree, used: t.totalUsed, size: t.totalSize };
          }),
          e
        );
      }
      clear() {
        this._poolsByClass.forEach((e) => e.clear()), this._poolsByClass.clear();
      }
    }
    const se = new nh();
    kt.register(se);
    const ah = {
      get isCachedAsTexture() {
        return !!this.renderGroup?.isCachedAsTexture;
      },
      cacheAsTexture(i) {
        typeof i == 'boolean' && i === !1
          ? this.disableRenderGroup()
          : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(i === !0 ? {} : i));
      },
      updateCacheTexture() {
        this.renderGroup?.updateCacheTexture();
      },
      get cacheAsBitmap() {
        return this.isCachedAsTexture;
      },
      set cacheAsBitmap(i) {
        P('v8.6.0', 'cacheAsBitmap is deprecated, use cacheAsTexture instead.'), this.cacheAsTexture(i);
      },
    };
    function js(i, e, t) {
      const A = i.length;
      let r;
      if (e >= A || t === 0) return;
      t = e + t > A ? A - e : t;
      const s = A - t;
      for (r = e; r < s; ++r) i[r] = i[r + t];
      i.length = s;
    }
    const oh = {
      allowChildren: !0,
      removeChildren(i = 0, e) {
        const t = e ?? this.children.length,
          A = t - i,
          r = [];
        if (A > 0 && A <= t) {
          for (let n = t - 1; n >= i; n--) {
            const a = this.children[n];
            a && (r.push(a), (a.parent = null));
          }
          js(this.children, i, t);
          const s = this.renderGroup || this.parentRenderGroup;
          s && s.removeChildren(r);
          for (let n = 0; n < r.length; ++n) {
            const a = r[n];
            a.parentRenderLayer?.detach(a), this.emit('childRemoved', a, this, n), r[n].emit('removed', this);
          }
          return r.length > 0 && this._didViewChangeTick++, r;
        } else if (A === 0 && this.children.length === 0) return r;
        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
      },
      removeChildAt(i) {
        const e = this.getChildAt(i);
        return this.removeChild(e);
      },
      getChildAt(i) {
        if (i < 0 || i >= this.children.length) throw new Error(`getChildAt: Index (${i}) does not exist.`);
        return this.children[i];
      },
      setChildIndex(i, e) {
        if (e < 0 || e >= this.children.length)
          throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
        this.getChildIndex(i), this.addChildAt(i, e);
      },
      getChildIndex(i) {
        const e = this.children.indexOf(i);
        if (e === -1) throw new Error('The supplied Container must be a child of the caller');
        return e;
      },
      addChildAt(i, e) {
        this.allowChildren || P(W, 'addChildAt: Only Containers will be allowed to add children in v8.0.0');
        const { children: t } = this;
        if (e < 0 || e > t.length) throw new Error(`${i}addChildAt: The index ${e} supplied is out of bounds ${t.length}`);
        if (i.parent) {
          const r = i.parent.children.indexOf(i);
          if (i.parent === this && r === e) return i;
          r !== -1 && i.parent.children.splice(r, 1);
        }
        e === t.length ? t.push(i) : t.splice(e, 0, i), (i.parent = this), (i.didChange = !0), (i._updateFlags = 15);
        const A = this.renderGroup || this.parentRenderGroup;
        return (
          A && A.addChild(i),
          this.sortableChildren && (this.sortDirty = !0),
          this.emit('childAdded', i, this, e),
          i.emit('added', this),
          i
        );
      },
      swapChildren(i, e) {
        if (i === e) return;
        const t = this.getChildIndex(i),
          A = this.getChildIndex(e);
        (this.children[t] = e), (this.children[A] = i);
        const r = this.renderGroup || this.parentRenderGroup;
        r && (r.structureDidChange = !0), this._didContainerChangeTick++;
      },
      removeFromParent() {
        this.parent?.removeChild(this);
      },
      reparentChild(...i) {
        return i.length === 1
          ? this.reparentChildAt(i[0], this.children.length)
          : (i.forEach((e) => this.reparentChildAt(e, this.children.length)), i[0]);
      },
      reparentChildAt(i, e) {
        if (i.parent === this) return this.setChildIndex(i, e), i;
        const t = i.worldTransform.clone();
        i.removeFromParent(), this.addChildAt(i, e);
        const A = this.worldTransform.clone();
        return A.invert(), t.prepend(A), i.setFromMatrix(t), i;
      },
      replaceChild(i, e) {
        i.updateLocalTransform(),
          this.addChildAt(e, this.getChildIndex(i)),
          e.setFromMatrix(i.localTransform),
          e.updateLocalTransform(),
          this.removeChild(i);
      },
    },
      lh = {
        collectRenderables(i, e, t) {
          (this.parentRenderLayer && this.parentRenderLayer !== t) ||
            this.globalDisplayStatus < 7 ||
            !this.includeInBuild ||
            (this.sortableChildren && this.sortChildren(),
              this.isSimple
                ? this.collectRenderablesSimple(i, e, t)
                : this.renderGroup
                  ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, i)
                  : this.collectRenderablesWithEffects(i, e, t));
        },
        collectRenderablesSimple(i, e, t) {
          const A = this.children,
            r = A.length;
          for (let s = 0; s < r; s++) A[s].collectRenderables(i, e, t);
        },
        collectRenderablesWithEffects(i, e, t) {
          const { renderPipes: A } = e;
          for (let r = 0; r < this.effects.length; r++) {
            const s = this.effects[r];
            A[s.pipe].push(s, this, i);
          }
          this.collectRenderablesSimple(i, e, t);
          for (let r = this.effects.length - 1; r >= 0; r--) {
            const s = this.effects[r];
            A[s.pipe].pop(s, this, i);
          }
        },
      };
    class PA {
      constructor() {
        (this.pipe = 'filter'), (this.priority = 1);
      }
      destroy() {
        for (let e = 0; e < this.filters.length; e++) this.filters[e].destroy();
        (this.filters = null), (this.filterArea = null);
      }
    }
    class hh {
      constructor() {
        (this._effectClasses = []), (this._tests = []), (this._initialized = !1);
      }
      init() {
        this._initialized ||
          ((this._initialized = !0),
            this._effectClasses.forEach((e) => {
              this.add({ test: e.test, maskClass: e });
            }));
      }
      add(e) {
        this._tests.push(e);
      }
      getMaskEffect(e) {
        this._initialized || this.init();
        for (let t = 0; t < this._tests.length; t++) {
          const A = this._tests[t];
          if (A.test(e)) return se.get(A.maskClass, e);
        }
        return e;
      }
      returnMaskEffect(e) {
        se.return(e);
      }
    }
    const Ri = new hh();
    Q.handleByList(M.MaskEffect, Ri._effectClasses);
    const ch = {
      _maskEffect: null,
      _maskOptions: { inverse: !1 },
      _filterEffect: null,
      effects: [],
      _markStructureAsChanged() {
        const i = this.renderGroup || this.parentRenderGroup;
        i && (i.structureDidChange = !0);
      },
      addEffect(i) {
        this.effects.indexOf(i) === -1 &&
          (this.effects.push(i),
            this.effects.sort((t, A) => t.priority - A.priority),
            this._markStructureAsChanged(),
            this._updateIsSimple());
      },
      removeEffect(i) {
        const e = this.effects.indexOf(i);
        e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple());
      },
      set mask(i) {
        const e = this._maskEffect;
        e?.mask !== i &&
          (e && (this.removeEffect(e), Ri.returnMaskEffect(e), (this._maskEffect = null)),
            i != null && ((this._maskEffect = Ri.getMaskEffect(i)), this.addEffect(this._maskEffect)));
      },
      get mask() {
        return this._maskEffect?.mask;
      },
      setMask(i) {
        (this._maskOptions = { ...this._maskOptions, ...i }), i.mask && (this.mask = i.mask), this._markStructureAsChanged();
      },
      set filters(i) {
        !Array.isArray(i) && i && (i = [i]);
        const e = this._filterEffect || (this._filterEffect = new PA());
        i = i;
        const t = i?.length > 0,
          A = e.filters?.length > 0,
          r = t !== A;
        (i = Array.isArray(i) ? i.slice(0) : i),
          (e.filters = Object.freeze(i)),
          r && (t ? this.addEffect(e) : (this.removeEffect(e), (e.filters = i ?? null)));
      },
      get filters() {
        return this._filterEffect?.filters;
      },
      set filterArea(i) {
        this._filterEffect || (this._filterEffect = new PA()), (this._filterEffect.filterArea = i);
      },
      get filterArea() {
        return this._filterEffect?.filterArea;
      },
    },
      uh = {
        label: null,
        get name() {
          return P(W, 'Container.name property has been removed, use Container.label instead'), this.label;
        },
        set name(i) {
          P(W, 'Container.name property has been removed, use Container.label instead'), (this.label = i);
        },
        getChildByName(i, e = !1) {
          return this.getChildByLabel(i, e);
        },
        getChildByLabel(i, e = !1) {
          const t = this.children;
          for (let A = 0; A < t.length; A++) {
            const r = t[A];
            if (r.label === i || (i instanceof RegExp && i.test(r.label))) return r;
          }
          if (e)
            for (let A = 0; A < t.length; A++) {
              const s = t[A].getChildByLabel(i, !0);
              if (s) return s;
            }
          return null;
        },
        getChildrenByLabel(i, e = !1, t = []) {
          const A = this.children;
          for (let r = 0; r < A.length; r++) {
            const s = A[r];
            (s.label === i || (i instanceof RegExp && i.test(s.label))) && t.push(s);
          }
          if (e) for (let r = 0; r < A.length; r++) A[r].getChildrenByLabel(i, !0, t);
          return t;
        },
      },
      Se = se.getPool(R),
      De = se.getPool(de),
      Yp = new R(),
      dh = {
        getFastGlobalBounds(i, e) {
          e || (e = new de()),
            e.clear(),
            this._getGlobalBoundsRecursive(!!i, e, this.parentRenderLayer),
            e.isValid || e.set(0, 0, 0, 0);
          const t = this.renderGroup || this.parentRenderGroup;
          return e.applyMatrix(t.worldTransform), e;
        },
        _getGlobalBoundsRecursive(i, e, t) {
          let A = e;
          if (
            (i && this.parentRenderLayer && this.parentRenderLayer !== t) ||
            this.localDisplayStatus !== 7 ||
            !this.measurable
          )
            return;
          const r = !!this.effects.length;
          if (((this.renderGroup || r) && (A = De.get().clear()), this.boundsArea))
            e.addRect(this.boundsArea, this.worldTransform);
          else {
            if (this.renderPipeId) {
              const n = this.bounds;
              A.addFrame(n.minX, n.minY, n.maxX, n.maxY, this.groupTransform);
            }
            const s = this.children;
            for (let n = 0; n < s.length; n++) s[n]._getGlobalBoundsRecursive(i, A, t);
          }
          if (r) {
            let s = !1;
            const n = this.renderGroup || this.parentRenderGroup;
            for (let a = 0; a < this.effects.length; a++)
              this.effects[a].addBounds && (s || ((s = !0), A.applyMatrix(n.worldTransform)), this.effects[a].addBounds(A, !0));
            s && A.applyMatrix(n.worldTransform.copyTo(Yp).invert()), e.addBounds(A), De.return(A);
          } else this.renderGroup && (e.addBounds(A, this.relativeGroupTransform), De.return(A));
        },
      };
    function Oi(i, e, t) {
      t.clear();
      let A, r;
      return (
        i.parent ? (e ? (A = i.parent.worldTransform) : ((r = Se.get().identity()), (A = Li(i, r)))) : (A = R.IDENTITY),
        fh(i, t, A, e),
        r && Se.return(r),
        t.isValid || t.set(0, 0, 0, 0),
        t
      );
    }
    function fh(i, e, t, A) {
      if (!i.visible || !i.measurable) return;
      let r;
      A ? (r = i.worldTransform) : (i.updateLocalTransform(), (r = Se.get()), r.appendFrom(i.localTransform, t));
      const s = e,
        n = !!i.effects.length;
      if ((n && (e = De.get().clear()), i.boundsArea)) e.addRect(i.boundsArea, r);
      else {
        const a = i.bounds;
        a && !a.isEmpty() && ((e.matrix = r), e.addBounds(a));
        for (let l = 0; l < i.children.length; l++) fh(i.children[l], e, r, A);
      }
      if (n) {
        for (let a = 0; a < i.effects.length; a++) i.effects[a].addBounds?.(e);
        s.addBounds(e, R.IDENTITY), De.return(e);
      }
      A || Se.return(r);
    }
    function Li(i, e) {
      const t = i.parent;
      return t && (Li(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e;
    }
    function Zs(i, e) {
      if (i === 16777215 || !e) return e;
      if (e === 16777215 || !i) return i;
      const t = (i >> 16) & 255,
        A = (i >> 8) & 255,
        r = i & 255,
        s = (e >> 16) & 255,
        n = (e >> 8) & 255,
        a = e & 255,
        l = ((t * s) / 255) | 0,
        h = ((A * n) / 255) | 0,
        u = ((r * a) / 255) | 0;
      return (l << 16) + (h << 8) + u;
    }
    const ko = 16777215;
    function JA(i, e) {
      return i === ko ? e : e === ko ? i : Zs(i, e);
    }
    function CA(i) {
      return ((i & 255) << 16) + (i & 65280) + ((i >> 16) & 255);
    }
    const ph = {
      getGlobalAlpha(i) {
        if (i)
          return this.renderGroup
            ? this.renderGroup.worldAlpha
            : this.parentRenderGroup
              ? this.parentRenderGroup.worldAlpha * this.alpha
              : this.alpha;
        let e = this.alpha,
          t = this.parent;
        for (; t;) (e *= t.alpha), (t = t.parent);
        return e;
      },
      getGlobalTransform(i = new R(), e) {
        if (e) return i.copyFrom(this.worldTransform);
        this.updateLocalTransform();
        const t = Li(this, Se.get().identity());
        return i.appendFrom(this.localTransform, t), Se.return(t), i;
      },
      getGlobalTint(i) {
        if (i)
          return this.renderGroup
            ? CA(this.renderGroup.worldColor)
            : this.parentRenderGroup
              ? CA(JA(this.localColor, this.parentRenderGroup.worldColor))
              : this.tint;
        let e = this.localColor,
          t = this.parent;
        for (; t;) (e = JA(e, t.localColor)), (t = t.parent);
        return CA(e);
      },
    };
    function ji(i, e, t) {
      return e.clear(), t || (t = R.IDENTITY), gh(i, e, t, i, !0), e.isValid || e.set(0, 0, 0, 0), e;
    }
    function gh(i, e, t, A, r) {
      let s;
      if (r) (s = Se.get()), (s = t.copyTo(s));
      else {
        if (!i.visible || !i.measurable) return;
        i.updateLocalTransform();
        const l = i.localTransform;
        (s = Se.get()), s.appendFrom(l, t);
      }
      const n = e,
        a = !!i.effects.length;
      if ((a && (e = De.get().clear()), i.boundsArea)) e.addRect(i.boundsArea, s);
      else {
        i.renderPipeId && ((e.matrix = s), e.addBounds(i.bounds));
        const l = i.children;
        for (let h = 0; h < l.length; h++) gh(l[h], e, s, A, !1);
      }
      if (a) {
        for (let l = 0; l < i.effects.length; l++) i.effects[l].addLocalBounds?.(e, A);
        n.addBounds(e, R.IDENTITY), De.return(e);
      }
      Se.return(s);
    }
    function Xs(i, e) {
      const t = i.children;
      for (let A = 0; A < t.length; A++) {
        const r = t[A],
          s = r.uid,
          n = ((r._didViewChangeTick & 65535) << 16) | (r._didContainerChangeTick & 65535),
          a = e.index;
        (e.data[a] !== s || e.data[a + 1] !== n) && ((e.data[e.index] = s), (e.data[e.index + 1] = n), (e.didChange = !0)),
          (e.index = a + 2),
          r.children.length && Xs(r, e);
      }
      return e.didChange;
    }
    const Dp = new R(),
      mh = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(i, e) {
          const t = Math.sign(this.scale.x) || 1;
          e !== 0 ? (this.scale.x = (i / e) * t) : (this.scale.x = t);
        },
        _setHeight(i, e) {
          const t = Math.sign(this.scale.y) || 1;
          e !== 0 ? (this.scale.y = (i / e) * t) : (this.scale.y = t);
        },
        getLocalBounds() {
          this._localBoundsCacheData ||
            (this._localBoundsCacheData = { data: [], index: 1, didChange: !1, localBounds: new de() });
          const i = this._localBoundsCacheData;
          return (
            (i.index = 1),
            (i.didChange = !1),
            i.data[0] !== this._didViewChangeTick && ((i.didChange = !0), (i.data[0] = this._didViewChangeTick)),
            Xs(this, i),
            i.didChange && ji(this, i.localBounds, Dp),
            i.localBounds
          );
        },
        getBounds(i, e) {
          return Oi(this, i, e || new de());
        },
      },
      Sh = {
        _onRender: null,
        set onRender(i) {
          const e = this.renderGroup || this.parentRenderGroup;
          if (!i) {
            this._onRender && e?.removeOnRender(this), (this._onRender = null);
            return;
          }
          this._onRender || e?.addOnRender(this), (this._onRender = i);
        },
        get onRender() {
          return this._onRender;
        },
      },
      qh = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex() {
          return this._zIndex;
        },
        set zIndex(i) {
          this._zIndex !== i && ((this._zIndex = i), this.depthOfChildModified());
        },
        depthOfChildModified() {
          this.parent && ((this.parent.sortableChildren = !0), (this.parent.sortDirty = !0)),
            this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0);
        },
        sortChildren() {
          this.sortDirty && ((this.sortDirty = !1), this.children.sort(Op));
        },
      };
    function Op(i, e) {
      return i._zIndex - e._zIndex;
    }
    const Mh = {
      getGlobalPosition(i = new H(), e = !1) {
        return (
          this.parent ? this.parent.toGlobal(this._position, i, e) : ((i.x = this._position.x), (i.y = this._position.y)), i
        );
      },
      toGlobal(i, e, t = !1) {
        const A = this.getGlobalTransform(Se.get(), t);
        return (e = A.apply(i, e)), Se.return(A), e;
      },
      toLocal(i, e, t, A) {
        e && (i = e.toGlobal(i, t, A));
        const r = this.getGlobalTransform(Se.get(), A);
        return (t = r.applyInverse(i, t)), Se.return(r), t;
      },
    };
    class Hs {
      constructor() {
        (this.uid = z('instructionSet')),
          (this.instructions = []),
          (this.instructionSize = 0),
          (this.renderables = []),
          (this.gcTick = 0);
      }
      reset() {
        this.instructionSize = 0;
      }
      destroy() {
        (this.instructions.length = 0), (this.renderables.length = 0), (this.renderPipes = null), (this.gcTick = 0);
      }
      add(e) {
        this.instructions[this.instructionSize++] = e;
      }
      log() {
        this.instructions.length = this.instructionSize;
      }
    }
    let Lp = 0;
    class Eh {
      constructor(e) {
        (this._poolKeyHash = Object.create(null)),
          (this._texturePool = {}),
          (this.textureOptions = e || {}),
          (this.enableFullScreen = !1),
          (this.textureStyle = new Je(this.textureOptions));
      }
      createTexture(e, t, A) {
        const r = new ne({ ...this.textureOptions, width: e, height: t, resolution: 1, antialias: A, autoGarbageCollect: !1 });
        return new v({ source: r, label: `texturePool_${Lp++}` });
      }
      getOptimalTexture(e, t, A = 1, r) {
        let s = Math.ceil(e * A - 1e-6),
          n = Math.ceil(t * A - 1e-6);
        (s = xt(s)), (n = xt(n));
        const a = (s << 17) + (n << 1) + (r ? 1 : 0);
        this._texturePool[a] || (this._texturePool[a] = []);
        let l = this._texturePool[a].pop();
        return (
          l || (l = this.createTexture(s, n, r)),
          (l.source._resolution = A),
          (l.source.width = s / A),
          (l.source.height = n / A),
          (l.source.pixelWidth = s),
          (l.source.pixelHeight = n),
          (l.frame.x = 0),
          (l.frame.y = 0),
          (l.frame.width = e),
          (l.frame.height = t),
          l.updateUvs(),
          (this._poolKeyHash[l.uid] = a),
          l
        );
      }
      getSameSizeTexture(e, t = !1) {
        const A = e.source;
        return this.getOptimalTexture(e.width, e.height, A._resolution, t);
      }
      returnTexture(e, t = !1) {
        const A = this._poolKeyHash[e.uid];
        t && (e.source.style = this.textureStyle), this._texturePool[A].push(e);
      }
      clear(e) {
        if (((e = e !== !1), e))
          for (const t in this._texturePool) {
            const A = this._texturePool[t];
            if (A) for (let r = 0; r < A.length; r++) A[r].destroy(!0);
          }
        this._texturePool = {};
      }
    }
    const ce = new Eh();





    kt.register(ce);
    class Bi {
      constructor() {
        (this.renderPipeId = 'renderGroup'),
          (this.root = null),
          (this.canBundle = !1),
          (this.renderGroupParent = null),
          (this.renderGroupChildren = []),
          (this.worldTransform = new R()),
          (this.worldColorAlpha = 4294967295),
          (this.worldColor = 16777215),
          (this.worldAlpha = 1),
          (this.childrenToUpdate = Object.create(null)),
          (this.updateTick = 0),
          (this.gcTick = 0),
          (this.childrenRenderablesToUpdate = { list: [], index: 0 }),
          (this.structureDidChange = !0),
          (this.instructionSet = new Hs()),
          (this._onRenderContainers = []),
          (this.textureNeedsUpdate = !0),
          (this.isCachedAsTexture = !1),
          (this._matrixDirty = 7);
      }
      init(e) {
        (this.root = e), e._onRender && this.addOnRender(e), (e.didChange = !0);
        const t = e.children;
        for (let A = 0; A < t.length; A++) {
          const r = t[A];
          (r._updateFlags = 15), this.addChild(r);
        }
      }
      enableCacheAsTexture(e = {}) {
        (this.textureOptions = e), (this.isCachedAsTexture = !0), (this.textureNeedsUpdate = !0);
      }
      disableCacheAsTexture() {
        (this.isCachedAsTexture = !1), this.texture && (ce.returnTexture(this.texture, !0), (this.texture = null));
      }
      updateCacheTexture() {
        this.textureNeedsUpdate = !0;
        const e = this._parentCacheAsTextureRenderGroup;
        e && !e.textureNeedsUpdate && e.updateCacheTexture();
      }
      reset() {
        this.renderGroupChildren.length = 0;
        for (const e in this.childrenToUpdate) {
          const t = this.childrenToUpdate[e];
          t.list.fill(null), (t.index = 0);
        }
        (this.childrenRenderablesToUpdate.index = 0),
          this.childrenRenderablesToUpdate.list.fill(null),
          (this.root = null),
          (this.updateTick = 0),
          (this.structureDidChange = !0),
          (this._onRenderContainers.length = 0),
          (this.renderGroupParent = null),
          this.disableCacheAsTexture();
      }
      get localTransform() {
        return this.root.localTransform;
      }
      addRenderGroupChild(e) {
        e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e),
          (e.renderGroupParent = this),
          this.renderGroupChildren.push(e);
      }
      _removeRenderGroupChild(e) {
        const t = this.renderGroupChildren.indexOf(e);
        t > -1 && this.renderGroupChildren.splice(t, 1), (e.renderGroupParent = null);
      }
      addChild(e) {
        if (
          ((this.structureDidChange = !0),
            (e.parentRenderGroup = this),
            (e.updateTick = -1),
            e.parent === this.root
              ? (e.relativeRenderGroupDepth = 1)
              : (e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1),
            (e.didChange = !0),
            this.onChildUpdate(e),
            e.renderGroup)
        ) {
          this.addRenderGroupChild(e.renderGroup);
          return;
        }
        e._onRender && this.addOnRender(e);
        const t = e.children;
        for (let A = 0; A < t.length; A++) this.addChild(t[A]);
      }
      removeChild(e) {
        if (
          ((this.structureDidChange = !0),
            e._onRender && (e.renderGroup || this.removeOnRender(e)),
            (e.parentRenderGroup = null),
            e.renderGroup)
        ) {
          this._removeRenderGroupChild(e.renderGroup);
          return;
        }
        const t = e.children;
        for (let A = 0; A < t.length; A++) this.removeChild(t[A]);
      }
      removeChildren(e) {
        for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
      }
      onChildUpdate(e) {
        let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
        t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = { index: 0, list: [] }), (t.list[t.index++] = e);
      }
      updateRenderable(e) {
        e.globalDisplayStatus < 7 ||
          (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), (e.didViewUpdate = !1));
      }
      onChildViewUpdate(e) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e;
      }
      get isRenderable() {
        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
      }
      addOnRender(e) {
        this._onRenderContainers.push(e);
      }
      removeOnRender(e) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1);
      }
      runOnRender(e) {
        for (let t = 0; t < this._onRenderContainers.length; t++) this._onRenderContainers[t]._onRender(e);
      }
      destroy() {
        this.disableCacheAsTexture(),
          (this.renderGroupParent = null),
          (this.root = null),
          (this.childrenRenderablesToUpdate = null),
          (this.childrenToUpdate = null),
          (this.renderGroupChildren = null),
          (this._onRenderContainers = null),
          (this.instructionSet = null);
      }
      getChildren(e = []) {
        const t = this.root.children;
        for (let A = 0; A < t.length; A++) this._getChildren(t[A], e);
        return e;
      }
      _getChildren(e, t = []) {
        if ((t.push(e), e.renderGroup)) return t;
        const A = e.children;
        for (let r = 0; r < A.length; r++) this._getChildren(A[r], t);
        return t;
      }
      invalidateMatrices() {
        this._matrixDirty = 7;
      }
      get inverseWorldTransform() {
        return (this._matrixDirty & 1) === 0
          ? this._inverseWorldTransform
          : ((this._matrixDirty &= -2),
            this._inverseWorldTransform || (this._inverseWorldTransform = new R()),
            this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
      }
      get textureOffsetInverseTransform() {
        return (this._matrixDirty & 2) === 0
          ? this._textureOffsetInverseTransform
          : ((this._matrixDirty &= -3),
            this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new R()),
            this._textureOffsetInverseTransform
              .copyFrom(this.inverseWorldTransform)
              .translate(-this._textureBounds.x, -this._textureBounds.y));
      }
      get inverseParentTextureTransform() {
        if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;
        this._matrixDirty &= -5;
        const e = this._parentCacheAsTextureRenderGroup;
        return e
          ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new R()),
            this._inverseParentTextureTransform
              .copyFrom(this.worldTransform)
              .prepend(e.inverseWorldTransform)
              .translate(-e._textureBounds.x, -e._textureBounds.y))
          : this.worldTransform;
      }
      get cacheToLocalTransform() {
        return this.isCachedAsTexture
          ? this.textureOffsetInverseTransform
          : this._parentCacheAsTextureRenderGroup
            ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform
            : null;
      }
    }
    function Vh(i, e, t = {}) {
      for (const A in e) !t[A] && e[A] !== void 0 && (i[A] = e[A]);
    }
    const br = new le(null),
      oi = new le(null),
      yr = new le(null, 1, 1),
      li = new le(null),
      GA = 1,
      Zi = 2,
      Dt = 4;
    class _ extends ye {
      constructor(e = {}) {
        super(),
          (this.uid = z('renderable')),
          (this._updateFlags = 15),
          (this.renderGroup = null),
          (this.parentRenderGroup = null),
          (this.parentRenderGroupIndex = 0),
          (this.didChange = !1),
          (this.didViewUpdate = !1),
          (this.relativeRenderGroupDepth = 0),
          (this.children = []),
          (this.parent = null),
          (this.includeInBuild = !0),
          (this.measurable = !0),
          (this.isSimple = !0),
          (this.parentRenderLayer = null),
          (this.updateTick = -1),
          (this.localTransform = new R()),
          (this.relativeGroupTransform = new R()),
          (this.groupTransform = this.relativeGroupTransform),
          (this.destroyed = !1),
          (this._position = new le(this, 0, 0)),
          (this._scale = yr),
          (this._pivot = oi),
          (this._origin = li),
          (this._skew = br),
          (this._cx = 1),
          (this._sx = 0),
          (this._cy = 0),
          (this._sy = 1),
          (this._rotation = 0),
          (this.localColor = 16777215),
          (this.localAlpha = 1),
          (this.groupAlpha = 1),
          (this.groupColor = 16777215),
          (this.groupColorAlpha = 4294967295),
          (this.localBlendMode = 'inherit'),
          (this.groupBlendMode = 'normal'),
          (this.localDisplayStatus = 7),
          (this.globalDisplayStatus = 7),
          (this._didContainerChangeTick = 0),
          (this._didViewChangeTick = 0),
          (this._didLocalTransformChangeId = -1),
          (this.effects = []),
          Vh(this, e, { children: !0, parent: !0, effects: !0 }),
          e.children?.forEach((t) => this.addChild(t)),
          e.parent?.addChild(this);
      }
      static mixin(e) {
        P('8.8.0', 'Container.mixin is deprecated, please use extensions.mixin instead.'), Q.mixin(_, e);
      }
      set _didChangeId(e) {
        (this._didViewChangeTick = (e >> 12) & 4095), (this._didContainerChangeTick = e & 4095);
      }
      get _didChangeId() {
        return (this._didContainerChangeTick & 4095) | ((this._didViewChangeTick & 4095) << 12);
      }
      addChild(...e) {
        if ((this.allowChildren || P(W, 'addChild: Only Containers will be allowed to add children in v8.0.0'), e.length > 1)) {
          for (let r = 0; r < e.length; r++) this.addChild(e[r]);
          return e[0];
        }
        const t = e[0],
          A = this.renderGroup || this.parentRenderGroup;
        return t.parent === this
          ? (this.children.splice(this.children.indexOf(t), 1), this.children.push(t), A && (A.structureDidChange = !0), t)
          : (t.parent && t.parent.removeChild(t),
            this.children.push(t),
            this.sortableChildren && (this.sortDirty = !0),
            (t.parent = this),
            (t.didChange = !0),
            (t._updateFlags = 15),
            A && A.addChild(t),
            this.emit('childAdded', t, this, this.children.length - 1),
            t.emit('added', this),
            this._didViewChangeTick++,
            t._zIndex !== 0 && t.depthOfChildModified(),
            t);
      }
      removeChild(...e) {
        if (e.length > 1) {
          for (let r = 0; r < e.length; r++) this.removeChild(e[r]);
          return e[0];
        }
        const t = e[0],
          A = this.children.indexOf(t);
        return (
          A > -1 &&
          (this._didViewChangeTick++,
            this.children.splice(A, 1),
            this.renderGroup
              ? this.renderGroup.removeChild(t)
              : this.parentRenderGroup && this.parentRenderGroup.removeChild(t),
            t.parentRenderLayer && t.parentRenderLayer.detach(t),
            (t.parent = null),
            this.emit('childRemoved', t, this, A),
            t.emit('removed', this)),
          t
        );
      }
      _onUpdate(e) {
        e && e === this._skew && this._updateSkew(),
          this._didContainerChangeTick++,
          !this.didChange && ((this.didChange = !0), this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
      }
      set isRenderGroup(e) {
        !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup());
      }
      get isRenderGroup() {
        return !!this.renderGroup;
      }
      enableRenderGroup() {
        if (this.renderGroup) return;
        const e = this.parentRenderGroup;
        e?.removeChild(this),
          (this.renderGroup = se.get(Bi, this)),
          (this.groupTransform = R.IDENTITY),
          e?.addChild(this),
          this._updateIsSimple();
      }
      disableRenderGroup() {
        if (!this.renderGroup) return;
        const e = this.parentRenderGroup;
        e?.removeChild(this),
          se.return(this.renderGroup),
          (this.renderGroup = null),
          (this.groupTransform = this.relativeGroupTransform),
          e?.addChild(this),
          this._updateIsSimple();
      }
      _updateIsSimple() {
        this.isSimple = !this.renderGroup && this.effects.length === 0;
      }
      get worldTransform() {
        return (
          this._worldTransform || (this._worldTransform = new R()),
          this.renderGroup
            ? this._worldTransform.copyFrom(this.renderGroup.worldTransform)
            : this.parentRenderGroup &&
            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform),
          this._worldTransform
        );
      }
      get x() {
        return this._position.x;
      }
      set x(e) {
        this._position.x = e;
      }
      get y() {
        return this._position.y;
      }
      set y(e) {
        this._position.y = e;
      }
      get position() {
        return this._position;
      }
      set position(e) {
        this._position.copyFrom(e);
      }
      get rotation() {
        return this._rotation;
      }
      set rotation(e) {
        this._rotation !== e && ((this._rotation = e), this._onUpdate(this._skew));
      }
      get angle() {
        return this.rotation * jl;
      }
      set angle(e) {
        this.rotation = e * Zl;
      }
      get pivot() {
        return this._pivot === oi && (this._pivot = new le(this, 0, 0)), this._pivot;
      }
      set pivot(e) {
        this._pivot === oi &&
          ((this._pivot = new le(this, 0, 0)),
            this._origin !== li &&
            N(
              'Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.'
            )),
          typeof e == 'number' ? this._pivot.set(e) : this._pivot.copyFrom(e);
      }
      get skew() {
        return this._skew === br && (this._skew = new le(this, 0, 0)), this._skew;
      }
      set skew(e) {
        this._skew === br && (this._skew = new le(this, 0, 0)), this._skew.copyFrom(e);
      }
      get scale() {
        return this._scale === yr && (this._scale = new le(this, 1, 1)), this._scale;
      }
      set scale(e) {
        this._scale === yr && (this._scale = new le(this, 0, 0)),
          typeof e == 'string' && (e = parseFloat(e)),
          typeof e == 'number' ? this._scale.set(e) : this._scale.copyFrom(e);
      }
      get origin() {
        return this._origin === li && (this._origin = new le(this, 0, 0)), this._origin;
      }
      set origin(e) {
        this._origin === li &&
          ((this._origin = new le(this, 0, 0)),
            this._pivot !== oi &&
            N(
              'Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.'
            )),
          typeof e == 'number' ? this._origin.set(e) : this._origin.copyFrom(e);
      }
      get width() {
        return Math.abs(this.scale.x * this.getLocalBounds().width);
      }
      set width(e) {
        const t = this.getLocalBounds().width;
        this._setWidth(e, t);
      }
      get height() {
        return Math.abs(this.scale.y * this.getLocalBounds().height);
      }
      set height(e) {
        const t = this.getLocalBounds().height;
        this._setHeight(e, t);
      }
      getSize(e) {
        e || (e = {});
        const t = this.getLocalBounds();
        return (e.width = Math.abs(this.scale.x * t.width)), (e.height = Math.abs(this.scale.y * t.height)), e;
      }
      setSize(e, t) {
        const A = this.getLocalBounds();
        typeof e == 'object' ? ((t = e.height ?? e.width), (e = e.width)) : t ?? (t = e),
          e !== void 0 && this._setWidth(e, A.width),
          t !== void 0 && this._setHeight(t, A.height);
      }
      _updateSkew() {
        const e = this._rotation,
          t = this._skew;
        (this._cx = Math.cos(e + t._y)),
          (this._sx = Math.sin(e + t._y)),
          (this._cy = -Math.sin(e - t._x)),
          (this._sy = Math.cos(e - t._x));
      }
      updateTransform(e) {
        return (
          this.position.set(typeof e.x == 'number' ? e.x : this.position.x, typeof e.y == 'number' ? e.y : this.position.y),
          this.scale.set(
            typeof e.scaleX == 'number' ? e.scaleX || 1 : this.scale.x,
            typeof e.scaleY == 'number' ? e.scaleY || 1 : this.scale.y
          ),
          (this.rotation = typeof e.rotation == 'number' ? e.rotation : this.rotation),
          this.skew.set(typeof e.skewX == 'number' ? e.skewX : this.skew.x, typeof e.skewY == 'number' ? e.skewY : this.skew.y),
          this.pivot.set(
            typeof e.pivotX == 'number' ? e.pivotX : this.pivot.x,
            typeof e.pivotY == 'number' ? e.pivotY : this.pivot.y
          ),
          this.origin.set(
            typeof e.originX == 'number' ? e.originX : this.origin.x,
            typeof e.originY == 'number' ? e.originY : this.origin.y
          ),
          this
        );
      }
      setFromMatrix(e) {
        e.decompose(this);
      }
      updateLocalTransform() {
        const e = this._didContainerChangeTick;
        if (this._didLocalTransformChangeId === e) return;
        this._didLocalTransformChangeId = e;
        const t = this.localTransform,
          A = this._scale,
          r = this._pivot,
          s = this._origin,
          n = this._position,
          a = A._x,
          l = A._y,
          h = r._x,
          u = r._y,
          o = -s._x,
          c = -s._y;
        (t.a = this._cx * a),
          (t.b = this._sx * a),
          (t.c = this._cy * l),
          (t.d = this._sy * l),
          (t.tx = n._x - (h * t.a + u * t.c) + (o * t.a + c * t.c) - o),
          (t.ty = n._y - (h * t.b + u * t.d) + (o * t.b + c * t.d) - c);
      }
      set alpha(e) {
        e !== this.localAlpha && ((this.localAlpha = e), (this._updateFlags |= GA), this._onUpdate());
      }
      get alpha() {
        return this.localAlpha;
      }
      set tint(e) {
        const A = $.shared.setValue(e ?? 16777215).toBgrNumber();
        A !== this.localColor && ((this.localColor = A), (this._updateFlags |= GA), this._onUpdate());
      }
      get tint() {
        return CA(this.localColor);
      }
      set blendMode(e) {
        this.localBlendMode !== e &&
          (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            (this._updateFlags |= Zi),
            (this.localBlendMode = e),
            this._onUpdate());
      }
      get blendMode() {
        return this.localBlendMode;
      }
      get visible() {
        return !!(this.localDisplayStatus & 2);
      }
      set visible(e) {
        const t = e ? 2 : 0;
        (this.localDisplayStatus & 2) !== t &&
          (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            (this._updateFlags |= Dt),
            (this.localDisplayStatus ^= 2),
            this._onUpdate());
      }
      get culled() {
        return !(this.localDisplayStatus & 4);
      }
      set culled(e) {
        const t = e ? 0 : 4;
        (this.localDisplayStatus & 4) !== t &&
          (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            (this._updateFlags |= Dt),
            (this.localDisplayStatus ^= 4),
            this._onUpdate());
      }
      get renderable() {
        return !!(this.localDisplayStatus & 1);
      }
      set renderable(e) {
        const t = e ? 1 : 0;
        (this.localDisplayStatus & 1) !== t &&
          ((this._updateFlags |= Dt),
            (this.localDisplayStatus ^= 1),
            this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0),
            this._onUpdate());
      }
      get isRenderable() {
        return this.localDisplayStatus === 7 && this.groupAlpha > 0;
      }
      destroy(e = !1) {
        if (this.destroyed) return;
        this.destroyed = !0;
        let t;
        if (
          (this.children.length && (t = this.removeChildren(0, this.children.length)),
            this.removeFromParent(),
            (this.parent = null),
            (this._maskEffect = null),
            (this._filterEffect = null),
            (this.effects = null),
            (this._position = null),
            (this._scale = null),
            (this._pivot = null),
            (this._origin = null),
            (this._skew = null),
            this.emit('destroyed', this),
            this.removeAllListeners(),
            (typeof e == 'boolean' ? e : e?.children) && t)
        )
          for (let r = 0; r < t.length; ++r) t[r].destroy(e);
        this.renderGroup?.destroy(), (this.renderGroup = null);
      }
    }
    Q.mixin(_, oh, dh, Mh, Sh, mh, ch, uh, qh, rh, ah, ph, lh);
    class HA extends _ {
      constructor(e) {
        super(e),
          (this.canBundle = !0),
          (this.allowChildren = !1),
          (this._roundPixels = 0),
          (this._lastUsed = -1),
          (this._gpuData = Object.create(null)),
          (this._bounds = new de(0, 1, 0, 0)),
          (this._boundsDirty = !0);
      }
      get bounds() {
        return this._boundsDirty ? (this.updateBounds(), (this._boundsDirty = !1), this._bounds) : this._bounds;
      }
      get roundPixels() {
        return !!this._roundPixels;
      }
      set roundPixels(e) {
        this._roundPixels = e ? 1 : 0;
      }
      containsPoint(e) {
        const t = this.bounds,
          { x: A, y: r } = e;
        return A >= t.minX && A <= t.maxX && r >= t.minY && r <= t.maxY;
      }
      onViewUpdate() {
        if ((this._didViewChangeTick++, (this._boundsDirty = !0), this.didViewUpdate)) return;
        this.didViewUpdate = !0;
        const e = this.renderGroup || this.parentRenderGroup;
        e && e.onChildViewUpdate(this);
      }
      destroy(e) {
        super.destroy(e), (this._bounds = null);
        for (const t in this._gpuData) this._gpuData[t].destroy?.();
        this._gpuData = null;
      }
      collectRenderablesSimple(e, t, A) {
        const { renderPipes: r } = t;
        r.blendMode.pushBlendMode(this, this.groupBlendMode, e),
          r[this.renderPipeId].addRenderable(this, e),
          (this.didViewUpdate = !1);
        const n = this.children,
          a = n.length;
        for (let l = 0; l < a; l++) n[l].collectRenderables(e, t, A);
        r.blendMode.popBlendMode(e);
      }
    }
    class re extends HA {
      constructor(e = v.EMPTY) {
        e instanceof v && (e = { texture: e });
        const { texture: t = v.EMPTY, anchor: A, roundPixels: r, width: s, height: n, ...a } = e;
        super({ label: 'Sprite', ...a }),
          (this.renderPipeId = 'sprite'),
          (this.batched = !0),
          (this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
          (this._anchor = new le({
            _onUpdate: () => {
              this.onViewUpdate();
            },
          })),
          A ? (this.anchor = A) : t.defaultAnchor && (this.anchor = t.defaultAnchor),
          (this.texture = t),
          (this.allowChildren = !1),
          (this.roundPixels = r ?? !1),
          s !== void 0 && (this.width = s),
          n !== void 0 && (this.height = n);
      }
      static from(e, t = !1) {
        return e instanceof v ? new re(e) : new re(v.from(e, t));
      }
      set texture(e) {
        e || (e = v.EMPTY);
        const t = this._texture;
        t !== e &&
          (t && t.dynamic && t.off('update', this.onViewUpdate, this),
            e.dynamic && e.on('update', this.onViewUpdate, this),
            (this._texture = e),
            this._width && this._setWidth(this._width, this._texture.orig.width),
            this._height && this._setHeight(this._height, this._texture.orig.height),
            this.onViewUpdate());
      }
      get texture() {
        return this._texture;
      }
      get visualBounds() {
        return Ls(this._visualBounds, this._anchor, this._texture), this._visualBounds;
      }
      get sourceBounds() {
        return P('8.6.1', 'Sprite.sourceBounds is deprecated, use visualBounds instead.'), this.visualBounds;
      }
      updateBounds() {
        const e = this._anchor,
          t = this._texture,
          A = this._bounds,
          { width: r, height: s } = t.orig;
        (A.minX = -e._x * r), (A.maxX = A.minX + r), (A.minY = -e._y * s), (A.maxY = A.minY + s);
      }
      destroy(e = !1) {
        if ((super.destroy(e), typeof e == 'boolean' ? e : e?.texture)) {
          const A = typeof e == 'boolean' ? e : e?.textureSource;
          this._texture.destroy(A);
        }
        (this._texture = null),
          (this._visualBounds = null),
          (this._bounds = null),
          (this._anchor = null),
          (this._gpuData = null);
      }
      get anchor() {
        return this._anchor;
      }
      set anchor(e) {
        typeof e == 'number' ? this._anchor.set(e) : this._anchor.copyFrom(e);
      }
      get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      }
      set width(e) {
        this._setWidth(e, this._texture.orig.width), (this._width = e);
      }
      get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      }
      set height(e) {
        this._setHeight(e, this._texture.orig.height), (this._height = e);
      }
      getSize(e) {
        return (
          e || (e = {}),
          (e.width = Math.abs(this.scale.x) * this._texture.orig.width),
          (e.height = Math.abs(this.scale.y) * this._texture.orig.height),
          e
        );
      }
      setSize(e, t) {
        typeof e == 'object' ? ((t = e.height ?? e.width), (e = e.width)) : t ?? (t = e),
          e !== void 0 && this._setWidth(e, this._texture.orig.width),
          t !== void 0 && this._setHeight(t, this._texture.orig.height);
      }
    }
    const jp = new de();
    function zs(i, e, t) {
      const A = jp;
      (i.measurable = !0), Oi(i, t, A), e.addBoundsMask(A), (i.measurable = !1);
    }
    function _s(i, e, t) {
      const A = De.get();
      i.measurable = !0;
      const r = Se.get().identity(),
        s = Th(i, t, r);
      ji(i, A, s), (i.measurable = !1), e.addBoundsMask(A), Se.return(r), De.return(A);
    }
    function Th(i, e, t) {
      return i
        ? (i !== e && (Th(i.parent, e, t), i.updateLocalTransform(), t.append(i.localTransform)), t)
        : (N('Mask bounds, renderable is not inside the root container'), t);
    }
    class $s {
      constructor(e) {
        (this.priority = 0), (this.inverse = !1), (this.pipe = 'alphaMask'), e?.mask && this.init(e.mask);
      }
      init(e) {
        (this.mask = e),
          (this.renderMaskToTexture = !(e instanceof re)),
          (this.mask.renderable = this.renderMaskToTexture),
          (this.mask.includeInBuild = !this.renderMaskToTexture),
          (this.mask.measurable = !1);
      }
      reset() {
        this.mask !== null && ((this.mask.measurable = !0), (this.mask = null));
      }
      addBounds(e, t) {
        this.inverse || zs(this.mask, e, t);
      }
      addLocalBounds(e, t) {
        _s(this.mask, e, t);
      }
      containsPoint(e, t) {
        const A = this.mask;
        return t(A, e);
      }
      destroy() {
        this.reset();
      }
      static test(e) {
        return e instanceof re;
      }
    }
    $s.extension = M.MaskEffect;
    class en {
      constructor(e) {
        (this.priority = 0), (this.pipe = 'colorMask'), e?.mask && this.init(e.mask);
      }
      init(e) {
        this.mask = e;
      }
      destroy() { }
      static test(e) {
        return typeof e == 'number';
      }
    }
    en.extension = M.MaskEffect;
    class tn {
      constructor(e) {
        (this.priority = 0), (this.pipe = 'stencilMask'), e?.mask && this.init(e.mask);
      }
      init(e) {
        (this.mask = e), (this.mask.includeInBuild = !1), (this.mask.measurable = !1);
      }
      reset() {
        this.mask !== null && ((this.mask.measurable = !0), (this.mask.includeInBuild = !0), (this.mask = null));
      }
      addBounds(e, t) {
        zs(this.mask, e, t);
      }
      addLocalBounds(e, t) {
        _s(this.mask, e, t);
      }
      containsPoint(e, t) {
        const A = this.mask;
        return t(A, e);
      }
      destroy() {
        this.reset();
      }
      static test(e) {
        return e instanceof _;
      }
    }
    tn.extension = M.MaskEffect;
    const Ih = {
      createCanvas: (i, e) => {
        const t = document.createElement('canvas');
        return (t.width = i), (t.height = e), t;
      },
      createImage: () => new Image(),
      getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => document.baseURI ?? window.location.href,
      getFontFaceSet: () => document.fonts,
      fetch: (i, e) => fetch(i, e),
      parseXML: (i) => new DOMParser().parseFromString(i, 'text/xml'),
    };
    let Ro = Ih;
    const J = {
      get() {
        return Ro;
      },
      set(i) {
        Ro = i;
      },
    };
    class Oe extends ne {
      constructor(e) {
        e.resource || (e.resource = J.get().createCanvas()),
          e.width || ((e.width = e.resource.width), e.autoDensity || (e.width /= e.resolution)),
          e.height || ((e.height = e.resource.height), e.autoDensity || (e.height /= e.resolution)),
          super(e),
          (this.uploadMethodId = 'image'),
          (this.autoDensity = e.autoDensity),
          this.resizeCanvas(),
          (this.transparent = !!e.transparent);
      }
      resizeCanvas() {
        this.autoDensity &&
          'style' in this.resource &&
          ((this.resource.style.width = `${this.width}px`), (this.resource.style.height = `${this.height}px`)),
          (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) &&
          ((this.resource.width = this.pixelWidth), (this.resource.height = this.pixelHeight));
      }
      resize(e = this.width, t = this.height, A = this._resolution) {
        const r = super.resize(e, t, A);
        return r && this.resizeCanvas(), r;
      }
      static test(e) {
        return (
          (globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
          (globalThis.OffscreenCanvas && e instanceof OffscreenCanvas)
        );
      }
      get context2D() {
        return this._context2D || (this._context2D = this.resource.getContext('2d'));
      }
    }
    Oe.extension = M.TextureSource;
    class ct extends ne {
      constructor(e) {
        super(e), (this.uploadMethodId = 'image'), (this.autoGarbageCollect = !0);
      }
      static test(e) {
        return (
          (globalThis.HTMLImageElement && e instanceof HTMLImageElement) ||
          (typeof ImageBitmap < 'u' && e instanceof ImageBitmap) ||
          (globalThis.VideoFrame && e instanceof VideoFrame)
        );
      }
    }
    ct.extension = M.TextureSource;
    var ut = ((i) => (
      (i[(i.INTERACTION = 50)] = 'INTERACTION'),
      (i[(i.HIGH = 25)] = 'HIGH'),
      (i[(i.NORMAL = 0)] = 'NORMAL'),
      (i[(i.LOW = -25)] = 'LOW'),
      (i[(i.UTILITY = -50)] = 'UTILITY'),
      i
    ))(ut || {});
    class bi {
      constructor(e, t = null, A = 0, r = !1) {
        (this.next = null),
          (this.previous = null),
          (this._destroyed = !1),
          (this._fn = e),
          (this._context = t),
          (this.priority = A),
          (this._once = r);
      }
      match(e, t = null) {
        return this._fn === e && this._context === t;
      }
      emit(e) {
        this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
        const t = this.next;
        return this._once && this.destroy(!0), this._destroyed && (this.next = null), t;
      }
      connect(e) {
        (this.previous = e), e.next && (e.next.previous = this), (this.next = e.next), (e.next = this);
      }
      destroy(e = !1) {
        (this._destroyed = !0),
          (this._fn = null),
          (this._context = null),
          this.previous && (this.previous.next = this.next),
          this.next && (this.next.previous = this.previous);
        const t = this.next;
        return (this.next = e ? null : t), (this.previous = null), t;
      }
    }
    const bh = class ve {
      constructor() {
        (this.autoStart = !1),
          (this.deltaTime = 1),
          (this.lastTime = -1),
          (this.speed = 1),
          (this.started = !1),
          (this._requestId = null),
          (this._maxElapsedMS = 100),
          (this._minElapsedMS = 0),
          (this._protected = !1),
          (this._lastFrame = -1),
          (this._head = new bi(null, null, 1 / 0)),
          (this.deltaMS = 1 / ve.targetFPMS),
          (this.elapsedMS = 1 / ve.targetFPMS),
          (this._tick = (e) => {
            (this._requestId = null),
              this.started &&
              (this.update(e),
                this.started &&
                this._requestId === null &&
                this._head.next &&
                (this._requestId = requestAnimationFrame(this._tick)));
          });
      }
      _requestIfNeeded() {
        this._requestId === null &&
          this._head.next &&
          ((this.lastTime = performance.now()),
            (this._lastFrame = this.lastTime),
            (this._requestId = requestAnimationFrame(this._tick)));
      }
      _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId), (this._requestId = null));
      }
      _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start();
      }
      add(e, t, A = ut.NORMAL) {
        return this._addListener(new bi(e, t, A));
      }
      addOnce(e, t, A = ut.NORMAL) {
        return this._addListener(new bi(e, t, A, !0));
      }
      _addListener(e) {
        let t = this._head.next,
          A = this._head;
        if (!t) e.connect(A);
        else {
          for (; t;) {
            if (e.priority > t.priority) {
              e.connect(A);
              break;
            }
            (A = t), (t = t.next);
          }
          e.previous || e.connect(A);
        }
        return this._startIfPossible(), this;
      }
      remove(e, t) {
        let A = this._head.next;
        for (; A;) A.match(e, t) ? (A = A.destroy()) : (A = A.next);
        return this._head.next || this._cancelIfNeeded(), this;
      }
      get count() {
        if (!this._head) return 0;
        let e = 0,
          t = this._head;
        for (; (t = t.next);) e++;
        return e;
      }
      start() {
        this.started || ((this.started = !0), this._requestIfNeeded());
      }
      stop() {
        this.started && ((this.started = !1), this._cancelIfNeeded());
      }
      destroy() {
        if (!this._protected) {
          this.stop();
          let e = this._head.next;
          for (; e;) e = e.destroy(!0);
          this._head.destroy(), (this._head = null);
        }
      }
      update(e = performance.now()) {
        let t;
        if (e > this.lastTime) {
          if (
            ((t = this.elapsedMS = e - this.lastTime),
              t > this._maxElapsedMS && (t = this._maxElapsedMS),
              (t *= this.speed),
              this._minElapsedMS)
          ) {
            const s = (e - this._lastFrame) | 0;
            if (s < this._minElapsedMS) return;
            this._lastFrame = e - (s % this._minElapsedMS);
          }
          (this.deltaMS = t), (this.deltaTime = this.deltaMS * ve.targetFPMS);
          const A = this._head;
          let r = A.next;
          for (; r;) r = r.emit(this);
          A.next || this._cancelIfNeeded();
        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = e;
      }
      get FPS() {
        return 1e3 / this.elapsedMS;
      }
      get minFPS() {
        return 1e3 / this._maxElapsedMS;
      }
      set minFPS(e) {
        const t = Math.min(this.maxFPS, e),
          A = Math.min(Math.max(0, t) / 1e3, ve.targetFPMS);
        this._maxElapsedMS = 1 / A;
      }
      get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
      }
      set maxFPS(e) {
        if (e === 0) this._minElapsedMS = 0;
        else {
          const t = Math.max(this.minFPS, e);
          this._minElapsedMS = 1 / (t / 1e3);
        }
      }
      static get shared() {
        if (!ve._shared) {
          const e = (ve._shared = new ve());
          (e.autoStart = !0), (e._protected = !0);
        }
        return ve._shared;
      }
      static get system() {
        if (!ve._system) {
          const e = (ve._system = new ve());
          (e.autoStart = !0), (e._protected = !0);
        }
        return ve._system;
      }
    };
    bh.targetFPMS = 0.06;
    let ue = bh,
      xr;
    async function An() {
      return (
        xr ??
        (xr = (async () => {
          const e = J.get().createCanvas(1, 1).getContext('webgl');
          if (!e) return 'premultiply-alpha-on-upload';
          const t = await new Promise((n) => {
            const a = document.createElement('video');
            (a.onloadeddata = () => n(a)),
              (a.onerror = () => n(null)),
              (a.autoplay = !1),
              (a.crossOrigin = 'anonymous'),
              (a.preload = 'auto'),
              (a.src =
                '[PLACEHOLDER:video/webm]'),
              a.load();
          });
          if (!t) return 'premultiply-alpha-on-upload';
          const A = e.createTexture();
          e.bindTexture(e.TEXTURE_2D, A);
          const r = e.createFramebuffer();
          e.bindFramebuffer(e.FRAMEBUFFER, r),
            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, A, 0),
            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
          const s = new Uint8Array(4);
          return (
            e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, s),
            e.deleteFramebuffer(r),
            e.deleteTexture(A),
            e.getExtension('WEBGL_lose_context')?.loseContext(),
            s[0] <= s[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload'
          );
        })()),
        xr
      );
    }
    const Xi = class yh extends ne {
      constructor(e) {
        super(e),
          (this.isReady = !1),
          (this.uploadMethodId = 'video'),
          (e = { ...yh.defaultOptions, ...e }),
          (this._autoUpdate = !0),
          (this._isConnectedToTicker = !1),
          (this._updateFPS = e.updateFPS || 0),
          (this._msToNextUpdate = 0),
          (this.autoPlay = e.autoPlay !== !1),
          (this.alphaMode = e.alphaMode ?? 'premultiply-alpha-on-upload'),
          (this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this)),
          (this._videoFrameRequestCallbackHandle = null),
          (this._load = null),
          (this._resolve = null),
          (this._reject = null),
          (this._onCanPlay = this._onCanPlay.bind(this)),
          (this._onCanPlayThrough = this._onCanPlayThrough.bind(this)),
          (this._onError = this._onError.bind(this)),
          (this._onPlayStart = this._onPlayStart.bind(this)),
          (this._onPlayStop = this._onPlayStop.bind(this)),
          (this._onSeeked = this._onSeeked.bind(this)),
          e.autoLoad !== !1 && this.load();
      }
      updateFrame() {
        if (!this.destroyed) {
          if (this._updateFPS) {
            const e = ue.shared.elapsedMS * this.resource.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - e);
          }
          (!this._updateFPS || this._msToNextUpdate <= 0) &&
            (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0),
            this.isValid && this.update();
        }
      }
      _videoFrameRequestCallback() {
        this.updateFrame(),
          this.destroyed
            ? (this._videoFrameRequestCallbackHandle = null)
            : (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
              this._videoFrameRequestCallback
            ));
      }
      get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight;
      }
      async load() {
        if (this._load) return this._load;
        const e = this.resource,
          t = this.options;
        return (
          (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) &&
          e.width &&
          e.height &&
          (e.complete = !0),
          e.addEventListener('play', this._onPlayStart),
          e.addEventListener('pause', this._onPlayStop),
          e.addEventListener('seeked', this._onSeeked),
          this._isSourceReady()
            ? this._mediaReady()
            : (t.preload || e.addEventListener('canplay', this._onCanPlay),
              e.addEventListener('canplaythrough', this._onCanPlayThrough),
              e.addEventListener('error', this._onError, !0)),
          (this.alphaMode = await An()),
          (this._load = new Promise((A, r) => {
            this.isValid
              ? A(this)
              : ((this._resolve = A),
                (this._reject = r),
                t.preloadTimeoutMs !== void 0 &&
                (this._preloadTimeout = setTimeout(() => {
                  this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`));
                })),
                e.load());
          })),
          this._load
        );
      }
      _onError(e) {
        this.resource.removeEventListener('error', this._onError, !0),
          this.emit('error', e),
          this._reject && (this._reject(e), (this._reject = null), (this._resolve = null));
      }
      _isSourcePlaying() {
        const e = this.resource;
        return !e.paused && !e.ended;
      }
      _isSourceReady() {
        return this.resource.readyState > 2;
      }
      _onPlayStart() {
        this.isValid || this._mediaReady(), this._configureAutoUpdate();
      }
      _onPlayStop() {
        this._configureAutoUpdate();
      }
      _onSeeked() {
        this._autoUpdate &&
          !this._isSourcePlaying() &&
          ((this._msToNextUpdate = 0), this.updateFrame(), (this._msToNextUpdate = 0));
      }
      _onCanPlay() {
        this.resource.removeEventListener('canplay', this._onCanPlay), this._mediaReady();
      }
      _onCanPlayThrough() {
        this.resource.removeEventListener('canplaythrough', this._onCanPlay),
          this._preloadTimeout && (clearTimeout(this._preloadTimeout), (this._preloadTimeout = void 0)),
          this._mediaReady();
      }
      _mediaReady() {
        const e = this.resource;
        this.isValid && ((this.isReady = !0), this.resize(e.videoWidth, e.videoHeight)),
          (this._msToNextUpdate = 0),
          this.updateFrame(),
          (this._msToNextUpdate = 0),
          this._resolve && (this._resolve(this), (this._resolve = null), (this._reject = null)),
          this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
      }
      destroy() {
        this._configureAutoUpdate();
        const e = this.resource;
        e &&
          (e.removeEventListener('play', this._onPlayStart),
            e.removeEventListener('pause', this._onPlayStop),
            e.removeEventListener('seeked', this._onSeeked),
            e.removeEventListener('canplay', this._onCanPlay),
            e.removeEventListener('canplaythrough', this._onCanPlayThrough),
            e.removeEventListener('error', this._onError, !0),
            e.pause(),
            (e.src = ''),
            e.load()),
          super.destroy();
      }
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(e) {
        e !== this._autoUpdate && ((this._autoUpdate = e), this._configureAutoUpdate());
      }
      get updateFPS() {
        return this._updateFPS;
      }
      set updateFPS(e) {
        e !== this._updateFPS && ((this._updateFPS = e), this._configureAutoUpdate());
      }
      _configureAutoUpdate() {
        this._autoUpdate && this._isSourcePlaying()
          ? !this._updateFPS && this.resource.requestVideoFrameCallback
            ? (this._isConnectedToTicker &&
              (ue.shared.remove(this.updateFrame, this), (this._isConnectedToTicker = !1), (this._msToNextUpdate = 0)),
              this._videoFrameRequestCallbackHandle === null &&
              (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                this._videoFrameRequestCallback
              )))
            : (this._videoFrameRequestCallbackHandle !== null &&
              (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
                (this._videoFrameRequestCallbackHandle = null)),
              this._isConnectedToTicker ||
              (ue.shared.add(this.updateFrame, this), (this._isConnectedToTicker = !0), (this._msToNextUpdate = 0)))
          : (this._videoFrameRequestCallbackHandle !== null &&
            (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),
              (this._videoFrameRequestCallbackHandle = null)),
            this._isConnectedToTicker &&
            (ue.shared.remove(this.updateFrame, this), (this._isConnectedToTicker = !1), (this._msToNextUpdate = 0)));
      }
      static test(e) {
        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement;
      }
    };
    Xi.extension = M.TextureSource;
    Xi.defaultOptions = {
      ...ne.defaultOptions,
      autoLoad: !0,
      autoPlay: !0,
      updateFPS: 0,
      crossorigin: !0,
      loop: !1,
      muted: !0,
      playsinline: !0,
      preload: !1,
    };
    Xi.MIME_TYPES = { ogv: 'video/ogg', mov: 'video/quicktime', m4v: 'video/mp4' };
    let Ot = Xi;
    const Be = (i, e, t = !1) => (Array.isArray(i) || (i = [i]), e ? i.map((A) => (typeof A == 'string' || t ? e(A) : A)) : i);
    class Zp {
      constructor() {
        (this._parsers = []), (this._cache = new Map()), (this._cacheMap = new Map());
      }
      reset() {
        this._cacheMap.clear(), this._cache.clear();
      }
      has(e) {
        return this._cache.has(e);
      }
      get(e) {
        const t = this._cache.get(e);
        return t || N(`[Assets] Asset id ${e} was not found in the Cache`), t;
      }
      set(e, t) {
        const A = Be(e);
        let r;
        for (let l = 0; l < this.parsers.length; l++) {
          const h = this.parsers[l];
          if (h.test(t)) {
            r = h.getCacheableAssets(A, t);
            break;
          }
        }
        const s = new Map(Object.entries(r || {}));
        r ||
          A.forEach((l) => {
            s.set(l, t);
          });
        const n = [...s.keys()],
          a = { cacheKeys: n, keys: A };
        A.forEach((l) => {
          this._cacheMap.set(l, a);
        }),
          n.forEach((l) => {
            const h = r ? r[l] : t;
            this._cache.has(l) && this._cache.get(l) !== h && N('[Cache] already has key:', l), this._cache.set(l, s.get(l));
          });
      }
      remove(e) {
        if (!this._cacheMap.has(e)) {
          N(`[Assets] Asset id ${e} was not found in the Cache`);
          return;
        }
        const t = this._cacheMap.get(e);
        t.cacheKeys.forEach((r) => {
          this._cache.delete(r);
        }),
          t.keys.forEach((r) => {
            this._cacheMap.delete(r);
          });
      }
      get parsers() {
        return this._parsers;
      }
    }
    const Z = new Zp(),
      as = [];
    Q.handleByList(M.TextureSource, as);
    function xh(i = {}) {
      const e = i && i.resource,
        t = e ? i.resource : i,
        A = e ? i : { resource: i };
      for (let r = 0; r < as.length; r++) {
        const s = as[r];
        if (s.test(t)) return new s(A);
      }
      throw new Error(`Could not find a source type for resource: ${A.resource}`);
    }
    function vh(i = {}, e = !1) {
      const t = i && i.resource,
        A = t ? i.resource : i,
        r = t ? i : { resource: i };
      if (!e && Z.has(A)) return Z.get(A);
      const s = new v({ source: xh(r) });
      return (
        s.on('destroy', () => {
          Z.has(A) && Z.remove(A);
        }),
        e || Z.set(A, s),
        s
      );
    }
    function Ch(i, e = !1) {
      return typeof i == 'string' ? Z.get(i) : i instanceof ne ? new v({ source: i }) : vh(i, e);
    }
    v.from = Ch;
    ne.from = xh;
    Q.add($s, en, tn, Ot, ct, Oe, Di);
    var At = ((i) => ((i[(i.Low = 0)] = 'Low'), (i[(i.Normal = 1)] = 'Normal'), (i[(i.High = 2)] = 'High'), i))(At || {});
    function Pe(i) {
      if (typeof i != 'string') throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`);
    }
    function gA(i) {
      return i.split('?')[0].split('#')[0];
    }
    function Xp(i) {
      return i.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    function Hp(i, e, t) {
      return i.replace(new RegExp(Xp(e), 'g'), t);
    }
    function zp(i, e) {
      let t = '',
        A = 0,
        r = -1,
        s = 0,
        n = -1;
      for (let a = 0; a <= i.length; ++a) {
        if (a < i.length) n = i.charCodeAt(a);
        else {
          if (n === 47) break;
          n = 47;
        }
        if (n === 47) {
          if (!(r === a - 1 || s === 1))
            if (r !== a - 1 && s === 2) {
              if (t.length < 2 || A !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
                if (t.length > 2) {
                  const l = t.lastIndexOf('/');
                  if (l !== t.length - 1) {
                    l === -1 ? ((t = ''), (A = 0)) : ((t = t.slice(0, l)), (A = t.length - 1 - t.lastIndexOf('/'))),
                      (r = a),
                      (s = 0);
                    continue;
                  }
                } else if (t.length === 2 || t.length === 1) {
                  (t = ''), (A = 0), (r = a), (s = 0);
                  continue;
                }
              }
            } else t.length > 0 ? (t += `/${i.slice(r + 1, a)}`) : (t = i.slice(r + 1, a)), (A = a - r - 1);
          (r = a), (s = 0);
        } else n === 46 && s !== -1 ? ++s : (s = -1);
      }
      return t;
    }
    const Ie = {
      toPosix(i) {
        return Hp(i, '\\', '/');
      },
      isUrl(i) {
        return /^https?:/.test(this.toPosix(i));
      },
      isDataUrl(i) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(
          i
        );
      },
      isBlobUrl(i) {
        return i.startsWith('blob:');
      },
      hasProtocol(i) {
        return /^[^/:]+:/.test(this.toPosix(i));
      },
      getProtocol(i) {
        Pe(i), (i = this.toPosix(i));
        const e = /^file:\/\/\//.exec(i);
        if (e) return e[0];
        const t = /^[^/:]+:\/{0,2}/.exec(i);
        return t ? t[0] : '';
      },
      toAbsolute(i, e, t) {
        if ((Pe(i), this.isDataUrl(i) || this.isBlobUrl(i))) return i;
        const A = gA(this.toPosix(e ?? J.get().getBaseUrl())),
          r = gA(this.toPosix(t ?? this.rootname(A)));
        return (i = this.toPosix(i)), i.startsWith('/') ? Ie.join(r, i.slice(1)) : this.isAbsolute(i) ? i : this.join(A, i);
      },
      normalize(i) {
        if ((Pe(i), i.length === 0)) return '.';
        if (this.isDataUrl(i) || this.isBlobUrl(i)) return i;
        i = this.toPosix(i);
        let e = '';
        const t = i.startsWith('/');
        this.hasProtocol(i) && ((e = this.rootname(i)), (i = i.slice(e.length)));
        const A = i.endsWith('/');
        return (i = zp(i)), i.length > 0 && A && (i += '/'), t ? `/${i}` : e + i;
      },
      isAbsolute(i) {
        return Pe(i), (i = this.toPosix(i)), this.hasProtocol(i) ? !0 : i.startsWith('/');
      },
      join(...i) {
        if (i.length === 0) return '.';
        let e;
        for (let t = 0; t < i.length; ++t) {
          const A = i[t];
          if ((Pe(A), A.length > 0))
            if (e === void 0) e = A;
            else {
              const r = i[t - 1] ?? '';
              this.joinExtensions.includes(this.extname(r).toLowerCase()) ? (e += `/../${A}`) : (e += `/${A}`);
            }
        }
        return e === void 0 ? '.' : this.normalize(e);
      },
      dirname(i) {
        if ((Pe(i), i.length === 0)) return '.';
        i = this.toPosix(i);
        let e = i.charCodeAt(0);
        const t = e === 47;
        let A = -1,
          r = !0;
        const s = this.getProtocol(i),
          n = i;
        i = i.slice(s.length);
        for (let a = i.length - 1; a >= 1; --a)
          if (((e = i.charCodeAt(a)), e === 47)) {
            if (!r) {
              A = a;
              break;
            }
          } else r = !1;
        return A === -1 ? (t ? '/' : this.isUrl(n) ? s + i : s) : t && A === 1 ? '//' : s + i.slice(0, A);
      },
      rootname(i) {
        Pe(i), (i = this.toPosix(i));
        let e = '';
        if ((i.startsWith('/') ? (e = '/') : (e = this.getProtocol(i)), this.isUrl(i))) {
          const t = i.indexOf('/', e.length);
          t !== -1 ? (e = i.slice(0, t)) : (e = i), e.endsWith('/') || (e += '/');
        }
        return e;
      },
      basename(i, e) {
        Pe(i), e && Pe(e), (i = gA(this.toPosix(i)));
        let t = 0,
          A = -1,
          r = !0,
          s;
        if (e !== void 0 && e.length > 0 && e.length <= i.length) {
          if (e.length === i.length && e === i) return '';
          let n = e.length - 1,
            a = -1;
          for (s = i.length - 1; s >= 0; --s) {
            const l = i.charCodeAt(s);
            if (l === 47) {
              if (!r) {
                t = s + 1;
                break;
              }
            } else
              a === -1 && ((r = !1), (a = s + 1)),
                n >= 0 && (l === e.charCodeAt(n) ? --n === -1 && (A = s) : ((n = -1), (A = a)));
          }
          return t === A ? (A = a) : A === -1 && (A = i.length), i.slice(t, A);
        }
        for (s = i.length - 1; s >= 0; --s)
          if (i.charCodeAt(s) === 47) {
            if (!r) {
              t = s + 1;
              break;
            }
          } else A === -1 && ((r = !1), (A = s + 1));
        return A === -1 ? '' : i.slice(t, A);
      },
      extname(i) {
        Pe(i), (i = gA(this.toPosix(i)));
        let e = -1,
          t = 0,
          A = -1,
          r = !0,
          s = 0;
        for (let n = i.length - 1; n >= 0; --n) {
          const a = i.charCodeAt(n);
          if (a === 47) {
            if (!r) {
              t = n + 1;
              break;
            }
            continue;
          }
          A === -1 && ((r = !1), (A = n + 1)), a === 46 ? (e === -1 ? (e = n) : s !== 1 && (s = 1)) : e !== -1 && (s = -1);
        }
        return e === -1 || A === -1 || s === 0 || (s === 1 && e === A - 1 && e === t + 1) ? '' : i.slice(e, A);
      },
      parse(i) {
        Pe(i);
        const e = { root: '', dir: '', base: '', ext: '', name: '' };
        if (i.length === 0) return e;
        i = gA(this.toPosix(i));
        let t = i.charCodeAt(0);
        const A = this.isAbsolute(i);
        let r;
        (e.root = this.rootname(i)), A || this.hasProtocol(i) ? (r = 1) : (r = 0);
        let s = -1,
          n = 0,
          a = -1,
          l = !0,
          h = i.length - 1,
          u = 0;
        for (; h >= r; --h) {
          if (((t = i.charCodeAt(h)), t === 47)) {
            if (!l) {
              n = h + 1;
              break;
            }
            continue;
          }
          a === -1 && ((l = !1), (a = h + 1)), t === 46 ? (s === -1 ? (s = h) : u !== 1 && (u = 1)) : s !== -1 && (u = -1);
        }
        return (
          s === -1 || a === -1 || u === 0 || (u === 1 && s === a - 1 && s === n + 1)
            ? a !== -1 && (n === 0 && A ? (e.base = e.name = i.slice(1, a)) : (e.base = e.name = i.slice(n, a)))
            : (n === 0 && A
              ? ((e.name = i.slice(1, s)), (e.base = i.slice(1, a)))
              : ((e.name = i.slice(n, s)), (e.base = i.slice(n, a))),
              (e.ext = i.slice(s, a))),
          (e.dir = this.dirname(i)),
          e
        );
      },
      sep: '/',
      delimiter: ':',
      joinExtensions: ['.html'],
    };
    function Uh(i, e, t, A, r) {
      const s = e[t];
      for (let n = 0; n < s.length; n++) {
        const a = s[n];
        t < e.length - 1 ? Uh(i.replace(A[t], a), e, t + 1, A, r) : r.push(i.replace(A[t], a));
      }
    }
    function kh(i) {
      const e = /\{(.*?)\}/g,
        t = i.match(e),
        A = [];
      if (t) {
        const r = [];
        t.forEach((s) => {
          const n = s.substring(1, s.length - 1).split(',');
          r.push(n);
        }),
          Uh(i, r, 0, t, A);
      } else A.push(i);
      return A;
    }
    const WA = (i) => !Array.isArray(i);
    class Rt {
      constructor() {
        (this._defaultBundleIdentifierOptions = {
          connector: '-',
          createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
          extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, ''),
        }),
          (this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector),
          (this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId),
          (this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
          (this._assetMap = {}),
          (this._preferredOrder = []),
          (this._parsers = []),
          (this._resolverHash = {}),
          (this._bundles = {});
      }
      setBundleIdentifier(e) {
        if (
          ((this._bundleIdConnector = e.connector ?? this._bundleIdConnector),
            (this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId),
            (this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle),
            this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')
        )
          throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');
      }
      prefer(...e) {
        e.forEach((t) => {
          this._preferredOrder.push(t), t.priority || (t.priority = Object.keys(t.params));
        }),
          (this._resolverHash = {});
      }
      set basePath(e) {
        this._basePath = e;
      }
      get basePath() {
        return this._basePath;
      }
      set rootPath(e) {
        this._rootPath = e;
      }
      get rootPath() {
        return this._rootPath;
      }
      get parsers() {
        return this._parsers;
      }
      reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
          (this._assetMap = {}),
          (this._preferredOrder = []),
          (this._resolverHash = {}),
          (this._rootPath = null),
          (this._basePath = null),
          (this._manifest = null),
          (this._bundles = {}),
          (this._defaultSearchParams = null);
      }
      setDefaultSearchParams(e) {
        if (typeof e == 'string') this._defaultSearchParams = e;
        else {
          const t = e;
          this._defaultSearchParams = Object.keys(t)
            .map((A) => `${encodeURIComponent(A)}=${encodeURIComponent(t[A])}`)
            .join('&');
        }
      }
      getAlias(e) {
        const { alias: t, src: A } = e;
        return Be(
          t || A,
          (s) => (typeof s == 'string' ? s : Array.isArray(s) ? s.map((n) => n?.src ?? n) : s?.src ? s.src : s),
          !0
        );
      }
      addManifest(e) {
        this._manifest && N('[Resolver] Manifest already exists, this will be overwritten'),
          (this._manifest = e),
          e.bundles.forEach((t) => {
            this.addBundle(t.name, t.assets);
          });
      }
      addBundle(e, t) {
        const A = [];
        let r = t;
        Array.isArray(t) ||
          (r = Object.entries(t).map(([s, n]) =>
            typeof n == 'string' || Array.isArray(n) ? { alias: s, src: n } : { alias: s, ...n }
          )),
          r.forEach((s) => {
            const n = s.src,
              a = s.alias;
            let l;
            if (typeof a == 'string') {
              const h = this._createBundleAssetId(e, a);
              A.push(h), (l = [a, h]);
            } else {
              const h = a.map((u) => this._createBundleAssetId(e, u));
              A.push(...h), (l = [...a, ...h]);
            }
            this.add({ ...s, alias: l, src: n });
          }),
          (this._bundles[e] = A);
      }
      add(e) {
        const t = [];
        Array.isArray(e) ? t.push(...e) : t.push(e);
        let A;
        (A = (s) => {
          this.hasKey(s) && N(`[Resolver] already has key: ${s} overwriting`);
        }),
          Be(t).forEach((s) => {
            const { src: n } = s;
            let { data: a, format: l, loadParser: h, parser: u } = s;
            const o = Be(n).map((g) => (typeof g == 'string' ? kh(g) : Array.isArray(g) ? g : [g])),
              c = this.getAlias(s);
            Array.isArray(c) ? c.forEach(A) : A(c);
            const d = [],
              f = (g) => ({ ...this._parsers.find((m) => m.test(g))?.parse(g), src: g });
            o.forEach((g) => {
              g.forEach((p) => {
                let m = {};
                if (
                  (typeof p != 'object'
                    ? (m = f(p))
                    : ((a = p.data ?? a),
                      (l = p.format ?? l),
                      (p.loadParser || p.parser) && ((h = p.loadParser ?? h), (u = p.parser ?? u)),
                      (m = { ...f(p.src), ...p })),
                    !c)
                )
                  throw new Error(`[Resolver] alias is undefined for this asset: ${m.src}`);
                (m = this._buildResolvedAsset(m, {
                  aliases: c,
                  data: a,
                  format: l,
                  loadParser: h,
                  parser: u,
                  progressSize: s.progressSize,
                })),
                  d.push(m);
              });
            }),
              c.forEach((g) => {
                this._assetMap[g] = d;
              });
          });
      }
      resolveBundle(e) {
        const t = WA(e);
        e = Be(e);
        const A = {};
        return (
          e.forEach((r) => {
            const s = this._bundles[r];
            if (s) {
              const n = this.resolve(s),
                a = {};
              for (const l in n) {
                const h = n[l];
                a[this._extractAssetIdFromBundle(r, l)] = h;
              }
              A[r] = a;
            }
          }),
          t ? A[e[0]] : A
        );
      }
      resolveUrl(e) {
        const t = this.resolve(e);
        if (typeof e != 'string') {
          const A = {};
          for (const r in t) A[r] = t[r].src;
          return A;
        }
        return t.src;
      }
      resolve(e) {
        const t = WA(e);
        e = Be(e);
        const A = {};
        return (
          e.forEach((r) => {
            if (!this._resolverHash[r])
              if (this._assetMap[r]) {
                let s = this._assetMap[r];
                const n = this._getPreferredOrder(s);
                n?.priority.forEach((a) => {
                  n.params[a].forEach((l) => {
                    const h = s.filter((u) => (u[a] ? u[a] === l : !1));
                    h.length && (s = h);
                  });
                }),
                  (this._resolverHash[r] = s[0]);
              } else this._resolverHash[r] = this._buildResolvedAsset({ alias: [r], src: r }, {});
            A[r] = this._resolverHash[r];
          }),
          t ? A[e[0]] : A
        );
      }
      hasKey(e) {
        return !!this._assetMap[e];
      }
      hasBundle(e) {
        return !!this._bundles[e];
      }
      _getPreferredOrder(e) {
        for (let t = 0; t < e.length; t++) {
          const A = e[t],
            r = this._preferredOrder.find((s) => s.params.format.includes(A.format));
          if (r) return r;
        }
        return this._preferredOrder[0];
      }
      _appendDefaultSearchParams(e) {
        if (!this._defaultSearchParams) return e;
        const t = /\?/.test(e) ? '&' : '?';
        return `${e}${t}${this._defaultSearchParams}`;
      }
      _buildResolvedAsset(e, t) {
        const { aliases: A, data: r, loadParser: s, parser: n, format: a, progressSize: l } = t;
        return (
          (this._basePath || this._rootPath) && (e.src = Ie.toAbsolute(e.src, this._basePath, this._rootPath)),
          (e.alias = A ?? e.alias ?? [e.src]),
          (e.src = this._appendDefaultSearchParams(e.src)),
          (e.data = { ...(r || {}), ...e.data }),
          (e.loadParser = s ?? e.loadParser),
          (e.parser = n ?? e.parser),
          (e.format = a ?? e.format ?? Rh(e.src)),
          l !== void 0 && (e.progressSize = l),
          e
        );
      }
    }
    Rt.RETINA_PREFIX = /@([0-9\.]+)x/;
    function Rh(i) {
      return i.split('.').pop().split('?').shift().split('#').shift();
    }
    const Ni = (i, e) => {
      const t = e.split('?')[1];
      return t && (i += `?${t}`), i;
    },
      Bh = class yA {
        constructor(e, t) {
          this.linkedSheets = [];
          let A = e;
          e?.source instanceof ne && (A = { texture: e, data: t });
          const { texture: r, data: s, cachePrefix: n = '' } = A;
          (this.cachePrefix = n),
            (this._texture = r instanceof v ? r : null),
            (this.textureSource = r.source),
            (this.textures = {}),
            (this.animations = {}),
            (this.data = s);
          const a = parseFloat(s.meta.scale);
          a ? ((this.resolution = a), (r.source.resolution = this.resolution)) : (this.resolution = r.source._resolution),
            (this._frames = this.data.frames),
            (this._frameKeys = Object.keys(this._frames)),
            (this._batchIndex = 0),
            (this._callback = null);
        }
        parse() {
          return new Promise((e) => {
            (this._callback = e),
              (this._batchIndex = 0),
              this._frameKeys.length <= yA.BATCH_SIZE
                ? (this._processFrames(0), this._processAnimations(), this._parseComplete())
                : this._nextBatch();
          });
        }
        _processFrames(e) {
          let t = e;
          const A = yA.BATCH_SIZE;
          for (; t - e < A && t < this._frameKeys.length;) {
            const r = this._frameKeys[t],
              s = this._frames[r],
              n = s.frame;
            if (n) {
              let a = null,
                l = null;
              const h = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame,
                u = new F(0, 0, Math.floor(h.w) / this.resolution, Math.floor(h.h) / this.resolution);
              s.rotated
                ? (a = new F(
                  Math.floor(n.x) / this.resolution,
                  Math.floor(n.y) / this.resolution,
                  Math.floor(n.h) / this.resolution,
                  Math.floor(n.w) / this.resolution
                ))
                : (a = new F(
                  Math.floor(n.x) / this.resolution,
                  Math.floor(n.y) / this.resolution,
                  Math.floor(n.w) / this.resolution,
                  Math.floor(n.h) / this.resolution
                )),
                s.trimmed !== !1 &&
                s.spriteSourceSize &&
                (l = new F(
                  Math.floor(s.spriteSourceSize.x) / this.resolution,
                  Math.floor(s.spriteSourceSize.y) / this.resolution,
                  Math.floor(n.w) / this.resolution,
                  Math.floor(n.h) / this.resolution
                )),
                (this.textures[r] = new v({
                  source: this.textureSource,
                  frame: a,
                  orig: u,
                  trim: l,
                  rotate: s.rotated ? 2 : 0,
                  defaultAnchor: s.anchor,
                  defaultBorders: s.borders,
                  label: r.toString(),
                }));
            }
            t++;
          }
        }
        _processAnimations() {
          const e = this.data.animations || {};
          for (const t in e) {
            this.animations[t] = [];
            for (let A = 0; A < e[t].length; A++) {
              const r = e[t][A];
              this.animations[t].push(this.textures[r]);
            }
          }
        }
        _parseComplete() {
          const e = this._callback;
          (this._callback = null), (this._batchIndex = 0), e.call(this, this.textures);
        }
        _nextBatch() {
          this._processFrames(this._batchIndex * yA.BATCH_SIZE),
            this._batchIndex++,
            setTimeout(() => {
              this._batchIndex * yA.BATCH_SIZE < this._frameKeys.length
                ? this._nextBatch()
                : (this._processAnimations(), this._parseComplete());
            }, 0);
        }
        destroy(e = !1) {
          for (const t in this.textures) this.textures[t].destroy();
          (this._frames = null),
            (this._frameKeys = null),
            (this.data = null),
            (this.textures = null),
            e && (this._texture?.destroy(), this.textureSource.destroy()),
            (this._texture = null),
            (this.textureSource = null),
            (this.linkedSheets = []);
        }
      };
    Bh.BATCH_SIZE = 1e3;
    let KA = Bh;
    const _p = [
      'jpg',
      'png',
      'jpeg',
      'avif',
      'webp',
      'basis',
      'etc2',
      'bc7',
      'bc6h',
      'bc5',
      'bc4',
      'bc3',
      'bc2',
      'bc1',
      'eac',
      'astc',
    ];
    function Nh(i, e, t) {
      const A = {};
      if (
        (i.forEach((r) => {
          A[r] = e;
        }),
          Object.keys(e.textures).forEach((r) => {
            A[`${e.cachePrefix}${r}`] = e.textures[r];
          }),
          !t)
      ) {
        const r = Ie.dirname(i[0]);
        e.linkedSheets.forEach((s, n) => {
          const a = Nh([`${r}/${e.data.meta.related_multi_packs[n]}`], s, !0);
          Object.assign(A, a);
        });
      }
      return A;
    }
    const Qh = {
      extension: M.Asset,
      cache: { test: (i) => i instanceof KA, getCacheableAssets: (i, e) => Nh(i, e, !1) },
      resolver: {
        extension: { type: M.ResolveParser, name: 'resolveSpritesheet' },
        test: (i) => {
          const t = i.split('?')[0].split('.'),
            A = t.pop(),
            r = t.pop();
          return A === 'json' && _p.includes(r);
        },
        parse: (i) => {
          const e = i.split('.');
          return { resolution: parseFloat(Rt.RETINA_PREFIX.exec(i)?.[1] ?? '1'), format: e[e.length - 2], src: i };
        },
      },
      loader: {
        name: 'spritesheetLoader',
        id: 'spritesheet',
        extension: { type: M.LoadParser, priority: At.Normal, name: 'spritesheetLoader' },
        async testParse(i, e) {
          return Ie.extname(e.src).toLowerCase() === '.json' && !!i.frames;
        },
        async parse(i, e, t) {
          const { texture: A, imageFilename: r, textureOptions: s, cachePrefix: n } = e?.data ?? {};
          let a = Ie.dirname(e.src);
          a && a.lastIndexOf('/') !== a.length - 1 && (a += '/');
          let l;
          if (A instanceof v) l = A;
          else {
            const o = Ni(a + (r ?? i.meta.image), e.src);
            l = (await t.load([{ src: o, data: s }]))[o];
          }
          const h = new KA({ texture: l.source, data: i, cachePrefix: n });
          await h.parse();
          const u = i?.meta?.related_multi_packs;
          if (Array.isArray(u)) {
            const o = [];
            for (const d of u) {
              if (typeof d != 'string') continue;
              let f = a + d;
              e.data?.ignoreMultiPack ||
                ((f = Ni(f, e.src)), o.push(t.load({ src: f, data: { textureOptions: s, ignoreMultiPack: !0 } })));
            }
            const c = await Promise.all(o);
            (h.linkedSheets = c),
              c.forEach((d) => {
                d.linkedSheets = [h].concat(h.linkedSheets.filter((f) => f !== d));
              });
          }
          return h;
        },
        async unload(i, e, t) {
          await t.unload(i.textureSource._sourceOrigin), i.destroy(!1);
        },
      },
    };
    Q.add(Qh);
    class rn {
      constructor(e) {
        (this._lastTransform = ''),
          (this._observer = null),
          (this._tickerAttached = !1),
          (this.updateTranslation = () => {
            if (!this._canvas) return;
            const t = this._canvas.getBoundingClientRect(),
              A = this._canvas.width,
              r = this._canvas.height,
              s = (t.width / A) * this._renderer.resolution,
              n = (t.height / r) * this._renderer.resolution,
              a = t.left,
              l = t.top,
              h = `translate(${a}px, ${l}px) scale(${s}, ${n})`;
            h !== this._lastTransform && ((this._domElement.style.transform = h), (this._lastTransform = h));
          }),
          (this._domElement = e.domElement),
          (this._renderer = e.renderer),
          !(globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas) &&
          ((this._canvas = this._renderer.canvas), this._attachObserver());
      }
      get canvas() {
        return this._canvas;
      }
      ensureAttached() {
        !this._domElement.parentNode &&
          this._canvas.parentNode &&
          (this._canvas.parentNode.appendChild(this._domElement), this.updateTranslation());
      }
      _attachObserver() {
        'ResizeObserver' in globalThis
          ? (this._observer && (this._observer.disconnect(), (this._observer = null)),
            (this._observer = new ResizeObserver((e) => {
              for (const t of e) {
                if (t.target !== this._canvas) continue;
                const A = this.canvas.width,
                  r = this.canvas.height,
                  s = (t.contentRect.width / A) * this._renderer.resolution,
                  n = (t.contentRect.height / r) * this._renderer.resolution;
                (this._lastScaleX !== s || this._lastScaleY !== n) &&
                  (this.updateTranslation(), (this._lastScaleX = s), (this._lastScaleY = n));
              }
            })),
            this._observer.observe(this._canvas))
          : this._tickerAttached || ue.shared.add(this.updateTranslation, this, ut.HIGH);
      }
      destroy() {
        this._observer
          ? (this._observer.disconnect(), (this._observer = null))
          : this._tickerAttached && ue.shared.remove(this.updateTranslation),
          (this._domElement = null),
          (this._renderer = null),
          (this._canvas = null),
          (this._tickerAttached = !1),
          (this._lastTransform = ''),
          (this._lastScaleX = null),
          (this._lastScaleY = null);
      }
    }
    class iA {
      constructor(e) {
        (this.bubbles = !0),
          (this.cancelBubble = !0),
          (this.cancelable = !1),
          (this.composed = !1),
          (this.defaultPrevented = !1),
          (this.eventPhase = iA.prototype.NONE),
          (this.propagationStopped = !1),
          (this.propagationImmediatelyStopped = !1),
          (this.layer = new H()),
          (this.page = new H()),
          (this.NONE = 0),
          (this.CAPTURING_PHASE = 1),
          (this.AT_TARGET = 2),
          (this.BUBBLING_PHASE = 3),
          (this.manager = e);
      }
      get layerX() {
        return this.layer.x;
      }
      get layerY() {
        return this.layer.y;
      }
      get pageX() {
        return this.page.x;
      }
      get pageY() {
        return this.page.y;
      }
      get data() {
        return this;
      }
      composedPath() {
        return (
          this.manager &&
          (!this.path || this.path[this.path.length - 1] !== this.target) &&
          (this.path = this.target ? this.manager.propagationPath(this.target) : []),
          this.path
        );
      }
      initEvent(e, t, A) {
        throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');
      }
      initUIEvent(e, t, A, r, s) {
        throw new Error('initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');
      }
      preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
          (this.defaultPrevented = !0);
      }
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0;
      }
      stopPropagation() {
        this.propagationStopped = !0;
      }
    }
    var vr = /iPhone/i,
      Bo = /iPod/i,
      No = /iPad/i,
      Qo = /\biOS-universal(?:.+)Mac\b/i,
      Cr = /\bAndroid(?:.+)Mobile\b/i,
      wo = /Android/i,
      wt = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
      hi = /Silk/i,
      ze = /Windows Phone/i,
      Po = /\bWindows(?:.+)ARM\b/i,
      Jo = /BlackBerry/i,
      Go = /BB10/i,
      Wo = /Opera Mini/i,
      Ko = /\b(CriOS|Chrome)(?:.+)Mobile/i,
      Fo = /Mobile(?:.+)Firefox\b/i,
      Yo = function (i) {
        return (
          typeof i < 'u' &&
          i.platform === 'MacIntel' &&
          typeof i.maxTouchPoints == 'number' &&
          i.maxTouchPoints > 1 &&
          typeof MSStream > 'u'
        );
      };
    function $p(i) {
      return function (e) {
        return e.test(i);
      };
    }
    function Do(i) {
      var e = { userAgent: '', platform: '', maxTouchPoints: 0 };
      !i && typeof navigator < 'u'
        ? (e = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 })
        : typeof i == 'string'
          ? (e.userAgent = i)
          : i && i.userAgent && (e = { userAgent: i.userAgent, platform: i.platform, maxTouchPoints: i.maxTouchPoints || 0 });
      var t = e.userAgent,
        A = t.split('[FBAN');
      typeof A[1] < 'u' && (t = A[0]), (A = t.split('Twitter')), typeof A[1] < 'u' && (t = A[0]);
      var r = $p(t),
        s = {
          apple: {
            phone: r(vr) && !r(ze),
            ipod: r(Bo),
            tablet: !r(vr) && (r(No) || Yo(e)) && !r(ze),
            universal: r(Qo),
            device: (r(vr) || r(Bo) || r(No) || r(Qo) || Yo(e)) && !r(ze),
          },
          amazon: { phone: r(wt), tablet: !r(wt) && r(hi), device: r(wt) || r(hi) },
          android: {
            phone: (!r(ze) && r(wt)) || (!r(ze) && r(Cr)),
            tablet: !r(ze) && !r(wt) && !r(Cr) && (r(hi) || r(wo)),
            device: (!r(ze) && (r(wt) || r(hi) || r(Cr) || r(wo))) || r(/\bokhttp\b/i),
          },
          windows: { phone: r(ze), tablet: r(Po), device: r(ze) || r(Po) },
          other: {
            blackberry: r(Jo),
            blackberry10: r(Go),
            opera: r(Wo),
            firefox: r(Fo),
            chrome: r(Ko),
            device: r(Jo) || r(Go) || r(Wo) || r(Fo) || r(Ko),
          },
          any: !1,
          phone: !1,
          tablet: !1,
        };
      return (
        (s.any = s.apple.device || s.android.device || s.windows.device || s.other.device),
        (s.phone = s.apple.phone || s.android.phone || s.windows.phone),
        (s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet),
        s
      );
    }
    const eg = Do.default ?? Do,
      wh = eg(globalThis.navigator),
      tg = 9,
      Oo = 100,
      Ag = 0,
      ig = 0,
      Lo = 2,
      jo = 1,
      rg = -1e3,
      sg = -1e3,
      ng = 2,
      sn = class Ph {
        constructor(e, t = wh) {
          (this._mobileInfo = t),
            (this.debug = !1),
            (this._activateOnTab = !0),
            (this._deactivateOnMouseMove = !0),
            (this._isActive = !1),
            (this._isMobileAccessibility = !1),
            (this._div = null),
            (this._pools = {}),
            (this._renderId = 0),
            (this._children = []),
            (this._androidUpdateCount = 0),
            (this._androidUpdateFrequency = 500),
            (this._isRunningTests = !1),
            (this._boundOnKeyDown = this._onKeyDown.bind(this)),
            (this._boundOnMouseMove = this._onMouseMove.bind(this)),
            (this._hookDiv = null),
            (t.tablet || t.phone) && this._createTouchHook(),
            (this._renderer = e);
        }
        get isActive() {
          return this._isActive;
        }
        get isMobileAccessibility() {
          return this._isMobileAccessibility;
        }
        get hookDiv() {
          return this._hookDiv;
        }
        get div() {
          return this._div;
        }
        _createTouchHook() {
          const e = document.createElement('button');
          (e.style.width = `${jo}px`),
            (e.style.height = `${jo}px`),
            (e.style.position = 'absolute'),
            (e.style.top = `${rg}px`),
            (e.style.left = `${sg}px`),
            (e.style.zIndex = ng.toString()),
            (e.style.backgroundColor = '#FF0000'),
            (e.title = 'select to enable accessibility for this content'),
            e.addEventListener('focus', () => {
              (this._isMobileAccessibility = !0), this._activate(), this._destroyTouchHook();
            }),
            document.body.appendChild(e),
            (this._hookDiv = e);
        }
        _destroyTouchHook() {
          this._hookDiv && (document.body.removeChild(this._hookDiv), (this._hookDiv = null));
        }
        _activate() {
          if (this._isActive) return;
          (this._isActive = !0),
            this._div ||
            ((this._div = document.createElement('div')),
              (this._div.style.position = 'absolute'),
              (this._div.style.top = `${Ag}px`),
              (this._div.style.left = `${ig}px`),
              (this._div.style.pointerEvents = 'none'),
              (this._div.style.zIndex = Lo.toString()),
              (this._canvasObserver = new rn({ domElement: this._div, renderer: this._renderer }))),
            this._activateOnTab && globalThis.addEventListener('keydown', this._boundOnKeyDown, !1),
            this._deactivateOnMouseMove && globalThis.document.addEventListener('mousemove', this._boundOnMouseMove, !0);
          const e = this._renderer.view.canvas;
          if (e.parentNode) this._canvasObserver.ensureAttached(), this._initAccessibilitySetup();
          else {
            const t = new MutationObserver(() => {
              e.parentNode && (t.disconnect(), this._canvasObserver.ensureAttached(), this._initAccessibilitySetup());
            });
            t.observe(document.body, { childList: !0, subtree: !0 });
          }
        }
        _initAccessibilitySetup() {
          this._renderer.runners.postrender.add(this),
            this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        }
        _deactivate() {
          if (!(!this._isActive || this._isMobileAccessibility)) {
            (this._isActive = !1),
              globalThis.document.removeEventListener('mousemove', this._boundOnMouseMove, !0),
              this._activateOnTab && globalThis.addEventListener('keydown', this._boundOnKeyDown, !1),
              this._renderer.runners.postrender.remove(this);
            for (const e of this._children)
              e._accessibleDiv?.parentNode &&
                (e._accessibleDiv.parentNode.removeChild(e._accessibleDiv), (e._accessibleDiv = null)),
                (e._accessibleActive = !1);
            for (const e in this._pools)
              this._pools[e].forEach((A) => {
                A.parentNode && A.parentNode.removeChild(A);
              }),
                delete this._pools[e];
            this._div?.parentNode && this._div.parentNode.removeChild(this._div), (this._pools = {}), (this._children = []);
          }
        }
        _updateAccessibleObjects(e) {
          if (!e.visible || !e.accessibleChildren) return;
          e.accessible && (e._accessibleActive || this._addChild(e), (e._renderId = this._renderId));
          const t = e.children;
          if (t) for (let A = 0; A < t.length; A++) this._updateAccessibleObjects(t[A]);
        }
        init(e) {
          const A = { accessibilityOptions: { ...Ph.defaultOptions, ...(e?.accessibilityOptions || {}) } };
          (this.debug = A.accessibilityOptions.debug),
            (this._activateOnTab = A.accessibilityOptions.activateOnTab),
            (this._deactivateOnMouseMove = A.accessibilityOptions.deactivateOnMouseMove),
            A.accessibilityOptions.enabledByDefault && this._activate(),
            this._renderer.runners.postrender.remove(this);
        }
        postrender() {
          const e = performance.now();
          if (
            (this._mobileInfo.android.device && e < this._androidUpdateCount) ||
            ((this._androidUpdateCount = e + this._androidUpdateFrequency),
              (!this._renderer.renderingToScreen || !this._renderer.view.canvas) && !this._isRunningTests)
          )
            return;
          const t = new Set();
          if (this._renderer.lastObjectRendered) {
            this._updateAccessibleObjects(this._renderer.lastObjectRendered);
            for (const A of this._children) A._renderId === this._renderId && t.add(this._children.indexOf(A));
          }
          for (let A = this._children.length - 1; A >= 0; A--) {
            const r = this._children[A];
            t.has(A) ||
              (r._accessibleDiv &&
                r._accessibleDiv.parentNode &&
                (r._accessibleDiv.parentNode.removeChild(r._accessibleDiv),
                  this._getPool(r.accessibleType).push(r._accessibleDiv),
                  (r._accessibleDiv = null)),
                (r._accessibleActive = !1),
                js(this._children, A, 1));
          }
          this._renderer.renderingToScreen && this._canvasObserver.ensureAttached();
          for (let A = 0; A < this._children.length; A++) {
            const r = this._children[A];
            if (!r._accessibleActive || !r._accessibleDiv) continue;
            const s = r._accessibleDiv,
              n = r.hitArea || r.getBounds().rectangle;
            if (r.hitArea) {
              const a = r.worldTransform;
              (s.style.left = `${a.tx + n.x * a.a}px`),
                (s.style.top = `${a.ty + n.y * a.d}px`),
                (s.style.width = `${n.width * a.a}px`),
                (s.style.height = `${n.height * a.d}px`);
            } else
              this._capHitArea(n),
                (s.style.left = `${n.x}px`),
                (s.style.top = `${n.y}px`),
                (s.style.width = `${n.width}px`),
                (s.style.height = `${n.height}px`);
          }
          this._renderId++;
        }
        _updateDebugHTML(e) {
          e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`;
        }
        _capHitArea(e) {
          e.x < 0 && ((e.width += e.x), (e.x = 0)), e.y < 0 && ((e.height += e.y), (e.y = 0));
          const { width: t, height: A } = this._renderer;
          e.x + e.width > t && (e.width = t - e.x), e.y + e.height > A && (e.height = A - e.y);
        }
        _addChild(e) {
          let A = this._getPool(e.accessibleType).pop();
          A
            ? ((A.innerHTML = ''), A.removeAttribute('title'), A.removeAttribute('aria-label'), (A.tabIndex = 0))
            : (e.accessibleType === 'button'
              ? (A = document.createElement('button'))
              : ((A = document.createElement(e.accessibleType)),
                (A.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `),
                e.accessibleText && (A.innerText = e.accessibleText)),
              (A.style.width = `${Oo}px`),
              (A.style.height = `${Oo}px`),
              (A.style.backgroundColor = this.debug ? 'rgba(255,255,255,0.5)' : 'transparent'),
              (A.style.position = 'absolute'),
              (A.style.zIndex = Lo.toString()),
              (A.style.borderStyle = 'none'),
              navigator.userAgent.toLowerCase().includes('chrome')
                ? A.setAttribute('aria-live', 'off')
                : A.setAttribute('aria-live', 'polite'),
              navigator.userAgent.match(/rv:.*Gecko\//)
                ? A.setAttribute('aria-relevant', 'additions')
                : A.setAttribute('aria-relevant', 'text'),
              A.addEventListener('click', this._onClick.bind(this)),
              A.addEventListener('focus', this._onFocus.bind(this)),
              A.addEventListener('focusout', this._onFocusOut.bind(this))),
            (A.style.pointerEvents = e.accessiblePointerEvents),
            (A.type = e.accessibleType),
            e.accessibleTitle && e.accessibleTitle !== null
              ? (A.title = e.accessibleTitle)
              : (!e.accessibleHint || e.accessibleHint === null) && (A.title = `container ${e.tabIndex}`),
            e.accessibleHint && e.accessibleHint !== null && A.setAttribute('aria-label', e.accessibleHint),
            e.interactive ? (A.tabIndex = e.tabIndex) : (A.tabIndex = 0),
            this.debug && this._updateDebugHTML(A),
            (e._accessibleActive = !0),
            (e._accessibleDiv = A),
            (A.container = e),
            this._children.push(e),
            this._div.appendChild(e._accessibleDiv);
        }
        _dispatchEvent(e, t) {
          const { container: A } = e.target,
            r = this._renderer.events.rootBoundary,
            s = Object.assign(new iA(r), { target: A });
          (r.rootTarget = this._renderer.lastObjectRendered), t.forEach((n) => r.dispatchEvent(s, n));
        }
        _onClick(e) {
          this._dispatchEvent(e, ['click', 'pointertap', 'tap']);
        }
        _onFocus(e) {
          e.target.getAttribute('aria-live') || e.target.setAttribute('aria-live', 'assertive'),
            this._dispatchEvent(e, ['mouseover']);
        }
        _onFocusOut(e) {
          e.target.getAttribute('aria-live') || e.target.setAttribute('aria-live', 'polite'),
            this._dispatchEvent(e, ['mouseout']);
        }
        _onKeyDown(e) {
          e.keyCode !== tg || !this._activateOnTab || this._activate();
        }
        _onMouseMove(e) {
          (e.movementX === 0 && e.movementY === 0) || this._deactivate();
        }
        destroy() {
          this._deactivate(),
            this._destroyTouchHook(),
            this._canvasObserver?.destroy(),
            (this._canvasObserver = null),
            (this._div = null),
            (this._pools = null),
            (this._children = null),
            (this._renderer = null),
            (this._hookDiv = null),
            globalThis.removeEventListener('keydown', this._boundOnKeyDown),
            (this._boundOnKeyDown = null),
            globalThis.document.removeEventListener('mousemove', this._boundOnMouseMove, !0),
            (this._boundOnMouseMove = null);
        }
        setAccessibilityEnabled(e) {
          e ? this._activate() : this._deactivate();
        }
        _getPool(e) {
          return this._pools[e] || (this._pools[e] = []), this._pools[e];
        }
      };
    sn.extension = { type: [M.WebGLSystem, M.WebGPUSystem], name: 'accessibility' };
    sn.defaultOptions = { enabledByDefault: !1, debug: !1, activateOnTab: !0, deactivateOnMouseMove: !0 };
    let Jh = sn;
    const Gh = {
      accessible: !1,
      accessibleTitle: null,
      accessibleHint: null,
      tabIndex: 0,
      accessibleType: 'button',
      accessibleText: null,
      accessiblePointerEvents: 'auto',
      accessibleChildren: !0,
      _accessibleActive: !1,
      _accessibleDiv: null,
      _renderId: -1,
    },
      Ur = Object.create(null),
      Zo = Object.create(null);
    function _t(i, e) {
      let t = Zo[i];
      return t === void 0 && (Ur[e] === void 0 && (Ur[e] = 1), (Zo[i] = t = Ur[e]++)), t;
    }
    let ci;
    function nn() {
      return (!ci || ci?.isContextLost()) && (ci = J.get().createCanvas().getContext('webgl', {})), ci;
    }
    let ui;
    function Wh() {
      if (!ui) {
        ui = 'mediump';
        const i = nn();
        i &&
          i.getShaderPrecisionFormat &&
          (ui = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? 'highp' : 'mediump');
      }
      return ui;
    }
    function Kh(i, e, t) {
      return e
        ? i
        : t
          ? ((i = i.replace('out vec4 finalColor;', '')),
            `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `)
          : `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `;
    }
    function Fh(i, e, t) {
      const A = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
      if (i.substring(0, 9) !== 'precision') {
        let r = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
        return (
          r === 'highp' && A !== 'highp' && (r = 'mediump'),
          `precision ${r} float;
${i}`
        );
      } else if (A !== 'highp' && i.substring(0, 15) === 'precision highp')
        return i.replace('precision highp', 'precision mediump');
      return i;
    }
    function Yh(i, e) {
      return e
        ? `#version 300 es
${i}`
        : i;
    }
    const ag = {},
      og = {};
    function Dh(i, { name: e = 'pixi-program' }, t = !0) {
      (e = e.replace(/\s+/g, '-')), (e += t ? '-fragment' : '-vertex');
      const A = t ? ag : og;
      return (
        A[e] ? (A[e]++, (e += `-${A[e]}`)) : (A[e] = 1),
        i.indexOf('#define SHADER_NAME') !== -1
          ? i
          : `${`#define SHADER_NAME ${e}`}
${i}`
      );
    }
    function Oh(i, e) {
      return e ? i.replace('#version 300 es', '') : i;
    }
    const kr = { stripVersion: Oh, ensurePrecision: Fh, addProgramDefines: Kh, setProgramName: Dh, insertVersion: Yh },
      mA = Object.create(null),
      Lh = class os {
        constructor(e) {
          e = { ...os.defaultOptions, ...e };
          const t = e.fragment.indexOf('#version 300 es') !== -1,
            A = {
              stripVersion: t,
              ensurePrecision: {
                requestedFragmentPrecision: e.preferredFragmentPrecision,
                requestedVertexPrecision: e.preferredVertexPrecision,
                maxSupportedVertexPrecision: 'highp',
                maxSupportedFragmentPrecision: Wh(),
              },
              setProgramName: { name: e.name },
              addProgramDefines: t,
              insertVersion: t,
            };
          let r = e.fragment,
            s = e.vertex;
          Object.keys(kr).forEach((n) => {
            const a = A[n];
            (r = kr[n](r, a, !0)), (s = kr[n](s, a, !1));
          }),
            (this.fragment = r),
            (this.vertex = s),
            (this.transformFeedbackVaryings = e.transformFeedbackVaryings),
            (this._key = _t(`${this.vertex}:${this.fragment}`, 'gl-program'));
        }
        destroy() {
          (this.fragment = null),
            (this.vertex = null),
            (this._attributeData = null),
            (this._uniformData = null),
            (this._uniformBlockData = null),
            (this.transformFeedbackVaryings = null),
            (mA[this._cacheKey] = null);
        }
        static from(e) {
          const t = `${e.vertex}:${e.fragment}`;
          return mA[t] || ((mA[t] = new os(e)), (mA[t]._cacheKey = t)), mA[t];
        }
      };
    Lh.defaultOptions = { preferredVertexPrecision: 'highp', preferredFragmentPrecision: 'mediump' };
    let dt = Lh;
    const Xo = {
      uint8x2: { size: 2, stride: 2, normalised: !1 },
      uint8x4: { size: 4, stride: 4, normalised: !1 },
      sint8x2: { size: 2, stride: 2, normalised: !1 },
      sint8x4: { size: 4, stride: 4, normalised: !1 },
      unorm8x2: { size: 2, stride: 2, normalised: !0 },
      unorm8x4: { size: 4, stride: 4, normalised: !0 },
      snorm8x2: { size: 2, stride: 2, normalised: !0 },
      snorm8x4: { size: 4, stride: 4, normalised: !0 },
      uint16x2: { size: 2, stride: 4, normalised: !1 },
      uint16x4: { size: 4, stride: 8, normalised: !1 },
      sint16x2: { size: 2, stride: 4, normalised: !1 },
      sint16x4: { size: 4, stride: 8, normalised: !1 },
      unorm16x2: { size: 2, stride: 4, normalised: !0 },
      unorm16x4: { size: 4, stride: 8, normalised: !0 },
      snorm16x2: { size: 2, stride: 4, normalised: !0 },
      snorm16x4: { size: 4, stride: 8, normalised: !0 },
      float16x2: { size: 2, stride: 4, normalised: !1 },
      float16x4: { size: 4, stride: 8, normalised: !1 },
      float32: { size: 1, stride: 4, normalised: !1 },
      float32x2: { size: 2, stride: 8, normalised: !1 },
      float32x3: { size: 3, stride: 12, normalised: !1 },
      float32x4: { size: 4, stride: 16, normalised: !1 },
      uint32: { size: 1, stride: 4, normalised: !1 },
      uint32x2: { size: 2, stride: 8, normalised: !1 },
      uint32x3: { size: 3, stride: 12, normalised: !1 },
      uint32x4: { size: 4, stride: 16, normalised: !1 },
      sint32: { size: 1, stride: 4, normalised: !1 },
      sint32x2: { size: 2, stride: 8, normalised: !1 },
      sint32x3: { size: 3, stride: 12, normalised: !1 },
      sint32x4: { size: 4, stride: 16, normalised: !1 },
    };
    function et(i) {
      return Xo[i] ?? Xo.float32;
    }
    const lg = {
      f32: 'float32',
      'vec2<f32>': 'float32x2',
      'vec3<f32>': 'float32x3',
      'vec4<f32>': 'float32x4',
      vec2f: 'float32x2',
      vec3f: 'float32x3',
      vec4f: 'float32x4',
      i32: 'sint32',
      'vec2<i32>': 'sint32x2',
      'vec3<i32>': 'sint32x3',
      'vec4<i32>': 'sint32x4',
      u32: 'uint32',
      'vec2<u32>': 'uint32x2',
      'vec3<u32>': 'uint32x3',
      'vec4<u32>': 'uint32x4',
      bool: 'uint32',
      'vec2<bool>': 'uint32x2',
      'vec3<bool>': 'uint32x3',
      'vec4<bool>': 'uint32x4',
    };
    function jh({ source: i, entryPoint: e }) {
      const t = {},
        A = i.indexOf(`fn ${e}`);
      if (A !== -1) {
        const r = i.indexOf('->', A);
        if (r !== -1) {
          const s = i.substring(A, r),
            n = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
          let a;
          for (; (a = n.exec(s)) !== null;) {
            const l = lg[a[3]] ?? 'float32';
            t[a[2]] = { location: parseInt(a[1], 10), format: l, stride: et(l).stride, offset: 0, instance: !1, start: 0 };
          }
        }
      }
      return t;
    }
    function yi(i) {
      const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,
        t = /@group\((\d+)\)/,
        A = /@binding\((\d+)\)/,
        r = /var(<[^>]+>)? (\w+)/,
        s = /:\s*(\w+)/,
        n = /struct\s+(\w+)\s*{([^}]+)}/g,
        a = /(\w+)\s*:\s*([\w\<\>]+)/g,
        l = /struct\s+(\w+)/,
        h = i.match(e)?.map((o) => ({
          group: parseInt(o.match(t)[1], 10),
          binding: parseInt(o.match(A)[1], 10),
          name: o.match(r)[2],
          isUniform: o.match(r)[1] === '<uniform>',
          type: o.match(s)[1],
        }));
      if (!h) return { groups: [], structs: [] };
      const u =
        i
          .match(n)
          ?.map((o) => {
            const c = o.match(l)[1],
              d = o.match(a).reduce((f, g) => {
                const [p, m] = g.split(':');
                return (f[p.trim()] = m.trim()), f;
              }, {});
            return d ? { name: c, members: d } : null;
          })
          .filter(({ name: o }) => h.some((c) => c.type === o)) ?? [];
      return { groups: h, structs: u };
    }
    var Yt = ((i) => ((i[(i.VERTEX = 1)] = 'VERTEX'), (i[(i.FRAGMENT = 2)] = 'FRAGMENT'), (i[(i.COMPUTE = 4)] = 'COMPUTE'), i))(
      Yt || {}
    );
    function Zh({ groups: i }) {
      const e = [];
      for (let t = 0; t < i.length; t++) {
        const A = i[t];
        e[A.group] || (e[A.group] = []),
          A.isUniform
            ? e[A.group].push({ binding: A.binding, visibility: Yt.VERTEX | Yt.FRAGMENT, buffer: { type: 'uniform' } })
            : A.type === 'sampler'
              ? e[A.group].push({ binding: A.binding, visibility: Yt.FRAGMENT, sampler: { type: 'filtering' } })
              : A.type === 'texture_2d' &&
              e[A.group].push({
                binding: A.binding,
                visibility: Yt.FRAGMENT,
                texture: { sampleType: 'float', viewDimension: '2d', multisampled: !1 },
              });
      }
      return e;
    }
    function Xh({ groups: i }) {
      const e = [];
      for (let t = 0; t < i.length; t++) {
        const A = i[t];
        e[A.group] || (e[A.group] = {}), (e[A.group][A.name] = A.binding);
      }
      return e;
    }
    function Hh(i, e) {
      const t = new Set(),
        A = new Set(),
        r = [...i.structs, ...e.structs].filter((n) => (t.has(n.name) ? !1 : (t.add(n.name), !0))),
        s = [...i.groups, ...e.groups].filter((n) => {
          const a = `${n.name}-${n.binding}`;
          return A.has(a) ? !1 : (A.add(a), !0);
        });
      return { structs: r, groups: s };
    }
    const SA = Object.create(null);
    class it {
      constructor(e) {
        (this._layoutKey = 0), (this._attributeLocationsKey = 0);
        const { fragment: t, vertex: A, layout: r, gpuLayout: s, name: n } = e;
        if (((this.name = n), (this.fragment = t), (this.vertex = A), t.source === A.source)) {
          const a = yi(t.source);
          this.structsAndGroups = a;
        } else {
          const a = yi(A.source),
            l = yi(t.source);
          this.structsAndGroups = Hh(a, l);
        }
        (this.layout = r ?? Xh(this.structsAndGroups)),
          (this.gpuLayout = s ?? Zh(this.structsAndGroups)),
          (this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0),
          (this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0),
          this._generateProgramKey();
      }
      _generateProgramKey() {
        const { vertex: e, fragment: t } = this,
          A = e.source + t.source + e.entryPoint + t.entryPoint;
        this._layoutKey = _t(A, 'program');
      }
      get attributeData() {
        return this._attributeData ?? (this._attributeData = jh(this.vertex)), this._attributeData;
      }
      destroy() {
        (this.gpuLayout = null),
          (this.layout = null),
          (this.structsAndGroups = null),
          (this.fragment = null),
          (this.vertex = null),
          (SA[this._cacheKey] = null);
      }
      static from(e) {
        const t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
        return SA[t] || ((SA[t] = new it(e)), (SA[t]._cacheKey = t)), SA[t];
      }
    }
    const an = [
      'f32',
      'i32',
      'vec2<f32>',
      'vec3<f32>',
      'vec4<f32>',
      'mat2x2<f32>',
      'mat3x3<f32>',
      'mat4x4<f32>',
      'mat3x2<f32>',
      'mat4x2<f32>',
      'mat2x3<f32>',
      'mat4x3<f32>',
      'mat2x4<f32>',
      'mat3x4<f32>',
      'vec2<i32>',
      'vec3<i32>',
      'vec4<i32>',
    ],
      zh = an.reduce((i, e) => ((i[e] = !0), i), {});
    function _h(i, e) {
      switch (i) {
        case 'f32':
          return 0;
        case 'vec2<f32>':
          return new Float32Array(2 * e);
        case 'vec3<f32>':
          return new Float32Array(3 * e);
        case 'vec4<f32>':
          return new Float32Array(4 * e);
        case 'mat2x2<f32>':
          return new Float32Array([1, 0, 0, 1]);
        case 'mat3x3<f32>':
          return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case 'mat4x4<f32>':
          return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      return null;
    }
    const $h = class ec {
      constructor(e, t) {
        (this._touched = 0),
          (this.uid = z('uniform')),
          (this._resourceType = 'uniformGroup'),
          (this._resourceId = z('resource')),
          (this.isUniformGroup = !0),
          (this._dirtyId = 0),
          (this.destroyed = !1),
          (t = { ...ec.defaultOptions, ...t }),
          (this.uniformStructures = e);
        const A = {};
        for (const r in e) {
          const s = e[r];
          if (((s.name = r), (s.size = s.size ?? 1), !zh[s.type])) {
            const n = s.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
            if (n) {
              const [, a, l] = n;
              throw new Error(`Uniform type ${s.type} is not supported. Use type: '${a}', size: ${l} instead.`);
            }
            throw new Error(`Uniform type ${s.type} is not supported. Supported uniform types are: ${an.join(', ')}`);
          }
          s.value ?? (s.value = _h(s.type, s.size)), (A[r] = s.value);
        }
        (this.uniforms = A),
          (this._dirtyId = 1),
          (this.ubo = t.ubo),
          (this.isStatic = t.isStatic),
          (this._signature = _t(
            Object.keys(A)
              .map((r) => `${r}-${e[r].type}`)
              .join('-'),
            'uniform-group'
          ));
      }
      update() {
        this._dirtyId++;
      }
    };
    $h.defaultOptions = { ubo: !1, isStatic: !1 };
    let qe = $h;
    class Le {
      constructor(e) {
        (this.resources = Object.create(null)), (this._dirty = !0);
        let t = 0;
        for (const A in e) {
          const r = e[A];
          this.setResource(r, t++);
        }
        this._updateKey();
      }
      _updateKey() {
        if (!this._dirty) return;
        this._dirty = !1;
        const e = [];
        let t = 0;
        for (const A in this.resources) e[t++] = this.resources[A]._resourceId;
        this._key = e.join('|');
      }
      setResource(e, t) {
        const A = this.resources[t];
        e !== A &&
          (A && e.off?.('change', this.onResourceChange, this),
            e.on?.('change', this.onResourceChange, this),
            (this.resources[t] = e),
            (this._dirty = !0));
      }
      getResource(e) {
        return this.resources[e];
      }
      _touch(e) {
        const t = this.resources;
        for (const A in t) t[A]._touched = e;
      }
      destroy() {
        const e = this.resources;
        for (const t in e) e[t]?.off?.('change', this.onResourceChange, this);
        this.resources = null;
      }
      onResourceChange(e) {
        if (((this._dirty = !0), e.destroyed)) {
          const t = this.resources;
          for (const A in t) t[A] === e && (t[A] = null);
        } else this._updateKey();
      }
    }
    var we = ((i) => ((i[(i.WEBGL = 1)] = 'WEBGL'), (i[(i.WEBGPU = 2)] = 'WEBGPU'), (i[(i.BOTH = 3)] = 'BOTH'), i))(we || {});
    class ke extends ye {
      constructor(e) {
        super(),
          (this.uid = z('shader')),
          (this._uniformBindMap = Object.create(null)),
          (this._ownedBindGroups = []),
          (this._destroyed = !1);
        let { gpuProgram: t, glProgram: A, groups: r, resources: s, compatibleRenderers: n, groupMap: a } = e;
        (this.gpuProgram = t),
          (this.glProgram = A),
          n === void 0 && ((n = 0), t && (n |= we.WEBGPU), A && (n |= we.WEBGL)),
          (this.compatibleRenderers = n);
        const l = {};
        if ((!s && !r && (s = {}), s && r)) throw new Error('[Shader] Cannot have both resources and groups');
        if (!t && r && !a)
          throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');
        if (!t && r && a)
          for (const h in a)
            for (const u in a[h]) {
              const o = a[h][u];
              l[o] = { group: h, binding: u, name: o };
            }
        else if (t && r && !a) {
          const h = t.structsAndGroups.groups;
          (a = {}),
            h.forEach((u) => {
              (a[u.group] = a[u.group] || {}), (a[u.group][u.binding] = u.name), (l[u.name] = u);
            });
        } else if (s) {
          (r = {}),
            (a = {}),
            t &&
            t.structsAndGroups.groups.forEach((o) => {
              (a[o.group] = a[o.group] || {}), (a[o.group][o.binding] = o.name), (l[o.name] = o);
            });
          let h = 0;
          for (const u in s)
            l[u] ||
              (r[99] || ((r[99] = new Le()), this._ownedBindGroups.push(r[99])),
                (l[u] = { group: 99, binding: h, name: u }),
                (a[99] = a[99] || {}),
                (a[99][h] = u),
                h++);
          for (const u in s) {
            const o = u;
            let c = s[u];
            !c.source && !c._resourceType && (c = new qe(c));
            const d = l[o];
            d &&
              (r[d.group] || ((r[d.group] = new Le()), this._ownedBindGroups.push(r[d.group])),
                r[d.group].setResource(c, d.binding));
          }
        }
        (this.groups = r), (this._uniformBindMap = a), (this.resources = this._buildResourceAccessor(r, l));
      }
      addResource(e, t, A) {
        var r, s;
        (r = this._uniformBindMap)[t] || (r[t] = {}),
          (s = this._uniformBindMap[t])[A] || (s[A] = e),
          this.groups[t] || ((this.groups[t] = new Le()), this._ownedBindGroups.push(this.groups[t]));
      }
      _buildResourceAccessor(e, t) {
        const A = {};
        for (const r in t) {
          const s = t[r];
          Object.defineProperty(A, s.name, {
            get() {
              return e[s.group].getResource(s.binding);
            },
            set(n) {
              e[s.group].setResource(n, s.binding);
            },
          });
        }
        return A;
      }
      destroy(e = !1) {
        this._destroyed ||
          ((this._destroyed = !0),
            this.emit('destroy', this),
            e && (this.gpuProgram?.destroy(), this.glProgram?.destroy()),
            (this.gpuProgram = null),
            (this.glProgram = null),
            this.removeAllListeners(),
            (this._uniformBindMap = null),
            this._ownedBindGroups.forEach((t) => {
              t.destroy();
            }),
            (this._ownedBindGroups = null),
            (this.resources = null),
            (this.groups = null));
      }
      static from(e) {
        const { gpu: t, gl: A, ...r } = e;
        let s, n;
        return t && (s = it.from(t)), A && (n = dt.from(A)), new ke({ gpuProgram: s, glProgram: n, ...r });
      }
    }
    const hg = {
      normal: 0,
      add: 1,
      multiply: 2,
      screen: 3,
      overlay: 4,
      erase: 5,
      'normal-npm': 6,
      'add-npm': 7,
      'screen-npm': 8,
      min: 9,
      max: 10,
    },
      Rr = 0,
      Br = 1,
      Nr = 2,
      Qr = 3,
      wr = 4,
      Pr = 5,
      ls = class tc {
        constructor() {
          (this.data = 0), (this.blendMode = 'normal'), (this.polygonOffset = 0), (this.blend = !0), (this.depthMask = !0);
        }
        get blend() {
          return !!(this.data & (1 << Rr));
        }
        set blend(e) {
          !!(this.data & (1 << Rr)) !== e && (this.data ^= 1 << Rr);
        }
        get offsets() {
          return !!(this.data & (1 << Br));
        }
        set offsets(e) {
          !!(this.data & (1 << Br)) !== e && (this.data ^= 1 << Br);
        }
        set cullMode(e) {
          if (e === 'none') {
            this.culling = !1;
            return;
          }
          (this.culling = !0), (this.clockwiseFrontFace = e === 'front');
        }
        get cullMode() {
          return this.culling ? (this.clockwiseFrontFace ? 'front' : 'back') : 'none';
        }
        get culling() {
          return !!(this.data & (1 << Nr));
        }
        set culling(e) {
          !!(this.data & (1 << Nr)) !== e && (this.data ^= 1 << Nr);
        }
        get depthTest() {
          return !!(this.data & (1 << Qr));
        }
        set depthTest(e) {
          !!(this.data & (1 << Qr)) !== e && (this.data ^= 1 << Qr);
        }
        get depthMask() {
          return !!(this.data & (1 << Pr));
        }
        set depthMask(e) {
          !!(this.data & (1 << Pr)) !== e && (this.data ^= 1 << Pr);
        }
        get clockwiseFrontFace() {
          return !!(this.data & (1 << wr));
        }
        set clockwiseFrontFace(e) {
          !!(this.data & (1 << wr)) !== e && (this.data ^= 1 << wr);
        }
        get blendMode() {
          return this._blendMode;
        }
        set blendMode(e) {
          (this.blend = e !== 'none'), (this._blendMode = e), (this._blendModeId = hg[e] || 0);
        }
        get polygonOffset() {
          return this._polygonOffset;
        }
        set polygonOffset(e) {
          (this.offsets = !!e), (this._polygonOffset = e);
        }
        toString() {
          return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
        }
        static for2d() {
          const e = new tc();
          return (e.depthTest = !1), (e.blend = !0), e;
        }
      };
    ls.default2d = ls.for2d();
    let Ue = ls;
    const Ac = class hs extends ke {
      constructor(e) {
        (e = { ...hs.defaultOptions, ...e }),
          super(e),
          (this.enabled = !0),
          (this._state = Ue.for2d()),
          (this.blendMode = e.blendMode),
          (this.padding = e.padding),
          typeof e.antialias == 'boolean' ? (this.antialias = e.antialias ? 'on' : 'off') : (this.antialias = e.antialias),
          (this.resolution = e.resolution),
          (this.blendRequired = e.blendRequired),
          (this.clipToViewport = e.clipToViewport),
          this.addResource('uTexture', 0, 1),
          e.blendRequired && this.addResource('uBackTexture', 0, 3);
      }
      apply(e, t, A, r) {
        e.applyFilter(this, t, A, r);
      }
      get blendMode() {
        return this._state.blendMode;
      }
      set blendMode(e) {
        this._state.blendMode = e;
      }
      static from(e) {
        const { gpu: t, gl: A, ...r } = e;
        let s, n;
        return t && (s = it.from(t)), A && (n = dt.from(A)), new hs({ gpuProgram: s, glProgram: n, ...r });
      }
    };
    Ac.defaultOptions = {
      blendMode: 'normal',
      resolution: 1,
      padding: 0,
      antialias: 'off',
      blendRequired: !1,
      clipToViewport: !0,
    };
    let on = Ac;
    const cs = [];
    Q.handleByNamedList(M.Environment, cs);
    async function ic(i) {
      if (!i)
        for (let e = 0; e < cs.length; e++) {
          const t = cs[e];
          if (t.value.test()) {
            await t.value.load();
            return;
          }
        }
    }
    let qA;
    function ln() {
      if (typeof qA == 'boolean') return qA;
      try {
        qA = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;')({ a: 'b' }, 'a', 'b') === !0;
      } catch {
        qA = !1;
      }
      return qA;
    }
    function Ho(i, e, t = 2) {
      const A = e && e.length,
        r = A ? e[0] * t : i.length;
      let s = rc(i, 0, r, t, !0);
      const n = [];
      if (!s || s.next === s.prev) return n;
      let a, l, h;
      if ((A && (s = pg(i, e, s, t)), i.length > 80 * t)) {
        (a = i[0]), (l = i[1]);
        let u = a,
          o = l;
        for (let c = t; c < r; c += t) {
          const d = i[c],
            f = i[c + 1];
          d < a && (a = d), f < l && (l = f), d > u && (u = d), f > o && (o = f);
        }
        (h = Math.max(u - a, o - l)), (h = h !== 0 ? 32767 / h : 0);
      }
      return FA(s, n, t, a, l, h, 0), n;
    }
    function rc(i, e, t, A, r) {
      let s;
      if (r === yg(i, e, t, A) > 0) for (let n = e; n < t; n += A) s = zo((n / A) | 0, i[n], i[n + 1], s);
      else for (let n = t - A; n >= e; n -= A) s = zo((n / A) | 0, i[n], i[n + 1], s);
      return s && $t(s, s.next) && (DA(s), (s = s.next)), s;
    }
    function vt(i, e) {
      if (!i) return i;
      e || (e = i);
      let t = i,
        A;
      do
        if (((A = !1), !t.steiner && ($t(t, t.next) || Ae(t.prev, t, t.next) === 0))) {
          if ((DA(t), (t = e = t.prev), t === t.next)) break;
          A = !0;
        } else t = t.next;
      while (A || t !== e);
      return e;
    }
    function FA(i, e, t, A, r, s, n) {
      if (!i) return;
      !n && s && Mg(i, A, r, s);
      let a = i;
      for (; i.prev !== i.next;) {
        const l = i.prev,
          h = i.next;
        if (s ? ug(i, A, r, s) : cg(i)) {
          e.push(l.i, i.i, h.i), DA(i), (i = h.next), (a = h.next);
          continue;
        }
        if (((i = h), i === a)) {
          n
            ? n === 1
              ? ((i = dg(vt(i), e)), FA(i, e, t, A, r, s, 2))
              : n === 2 && fg(i, e, t, A, r, s)
            : FA(vt(i), e, t, A, r, s, 1);
          break;
        }
      }
    }
    function cg(i) {
      const e = i.prev,
        t = i,
        A = i.next;
      if (Ae(e, t, A) >= 0) return !1;
      const r = e.x,
        s = t.x,
        n = A.x,
        a = e.y,
        l = t.y,
        h = A.y,
        u = Math.min(r, s, n),
        o = Math.min(a, l, h),
        c = Math.max(r, s, n),
        d = Math.max(a, l, h);
      let f = A.next;
      for (; f !== e;) {
        if (f.x >= u && f.x <= c && f.y >= o && f.y <= d && xA(r, a, s, l, n, h, f.x, f.y) && Ae(f.prev, f, f.next) >= 0)
          return !1;
        f = f.next;
      }
      return !0;
    }
    function ug(i, e, t, A) {
      const r = i.prev,
        s = i,
        n = i.next;
      if (Ae(r, s, n) >= 0) return !1;
      const a = r.x,
        l = s.x,
        h = n.x,
        u = r.y,
        o = s.y,
        c = n.y,
        d = Math.min(a, l, h),
        f = Math.min(u, o, c),
        g = Math.max(a, l, h),
        p = Math.max(u, o, c),
        m = us(d, f, e, t, A),
        S = us(g, p, e, t, A);
      let q = i.prevZ,
        E = i.nextZ;
      for (; q && q.z >= m && E && E.z <= S;) {
        if (
          (q.x >= d &&
            q.x <= g &&
            q.y >= f &&
            q.y <= p &&
            q !== r &&
            q !== n &&
            xA(a, u, l, o, h, c, q.x, q.y) &&
            Ae(q.prev, q, q.next) >= 0) ||
          ((q = q.prevZ),
            E.x >= d &&
            E.x <= g &&
            E.y >= f &&
            E.y <= p &&
            E !== r &&
            E !== n &&
            xA(a, u, l, o, h, c, E.x, E.y) &&
            Ae(E.prev, E, E.next) >= 0)
        )
          return !1;
        E = E.nextZ;
      }
      for (; q && q.z >= m;) {
        if (
          q.x >= d &&
          q.x <= g &&
          q.y >= f &&
          q.y <= p &&
          q !== r &&
          q !== n &&
          xA(a, u, l, o, h, c, q.x, q.y) &&
          Ae(q.prev, q, q.next) >= 0
        )
          return !1;
        q = q.prevZ;
      }
      for (; E && E.z <= S;) {
        if (
          E.x >= d &&
          E.x <= g &&
          E.y >= f &&
          E.y <= p &&
          E !== r &&
          E !== n &&
          xA(a, u, l, o, h, c, E.x, E.y) &&
          Ae(E.prev, E, E.next) >= 0
        )
          return !1;
        E = E.nextZ;
      }
      return !0;
    }
    function dg(i, e) {
      let t = i;
      do {
        const A = t.prev,
          r = t.next.next;
        !$t(A, r) && nc(A, t, t.next, r) && YA(A, r) && YA(r, A) && (e.push(A.i, t.i, r.i), DA(t), DA(t.next), (t = i = r)),
          (t = t.next);
      } while (t !== i);
      return vt(t);
    }
    function fg(i, e, t, A, r, s) {
      let n = i;
      do {
        let a = n.next.next;
        for (; a !== n.prev;) {
          if (n.i !== a.i && Tg(n, a)) {
            let l = ac(n, a);
            (n = vt(n, n.next)), (l = vt(l, l.next)), FA(n, e, t, A, r, s, 0), FA(l, e, t, A, r, s, 0);
            return;
          }
          a = a.next;
        }
        n = n.next;
      } while (n !== i);
    }
    function pg(i, e, t, A) {
      const r = [];
      for (let s = 0, n = e.length; s < n; s++) {
        const a = e[s] * A,
          l = s < n - 1 ? e[s + 1] * A : i.length,
          h = rc(i, a, l, A, !1);
        h === h.next && (h.steiner = !0), r.push(Vg(h));
      }
      r.sort(gg);
      for (let s = 0; s < r.length; s++) t = mg(r[s], t);
      return t;
    }
    function gg(i, e) {
      let t = i.x - e.x;
      if (t === 0 && ((t = i.y - e.y), t === 0)) {
        const A = (i.next.y - i.y) / (i.next.x - i.x),
          r = (e.next.y - e.y) / (e.next.x - e.x);
        t = A - r;
      }
      return t;
    }
    function mg(i, e) {
      const t = Sg(i, e);
      if (!t) return e;
      const A = ac(t, i);
      return vt(A, A.next), vt(t, t.next);
    }
    function Sg(i, e) {
      let t = e;
      const A = i.x,
        r = i.y;
      let s = -1 / 0,
        n;
      if ($t(i, t)) return t;
      do {
        if ($t(i, t.next)) return t.next;
        if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
          const o = t.x + ((r - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
          if (o <= A && o > s && ((s = o), (n = t.x < t.next.x ? t : t.next), o === A)) return n;
        }
        t = t.next;
      } while (t !== e);
      if (!n) return null;
      const a = n,
        l = n.x,
        h = n.y;
      let u = 1 / 0;
      t = n;
      do {
        if (A >= t.x && t.x >= l && A !== t.x && sc(r < h ? A : s, r, l, h, r < h ? s : A, r, t.x, t.y)) {
          const o = Math.abs(r - t.y) / (A - t.x);
          YA(t, i) && (o < u || (o === u && (t.x > n.x || (t.x === n.x && qg(n, t))))) && ((n = t), (u = o));
        }
        t = t.next;
      } while (t !== a);
      return n;
    }
    function qg(i, e) {
      return Ae(i.prev, i, e.prev) < 0 && Ae(e.next, i, i.next) < 0;
    }
    function Mg(i, e, t, A) {
      let r = i;
      do r.z === 0 && (r.z = us(r.x, r.y, e, t, A)), (r.prevZ = r.prev), (r.nextZ = r.next), (r = r.next);
      while (r !== i);
      (r.prevZ.nextZ = null), (r.prevZ = null), Eg(r);
    }
    function Eg(i) {
      let e,
        t = 1;
      do {
        let A = i,
          r;
        i = null;
        let s = null;
        for (e = 0; A;) {
          e++;
          let n = A,
            a = 0;
          for (let h = 0; h < t && (a++, (n = n.nextZ), !!n); h++);
          let l = t;
          for (; a > 0 || (l > 0 && n);)
            a !== 0 && (l === 0 || !n || A.z <= n.z) ? ((r = A), (A = A.nextZ), a--) : ((r = n), (n = n.nextZ), l--),
              s ? (s.nextZ = r) : (i = r),
              (r.prevZ = s),
              (s = r);
          A = n;
        }
        (s.nextZ = null), (t *= 2);
      } while (e > 1);
      return i;
    }
    function us(i, e, t, A, r) {
      return (
        (i = ((i - t) * r) | 0),
        (e = ((e - A) * r) | 0),
        (i = (i | (i << 8)) & 16711935),
        (i = (i | (i << 4)) & 252645135),
        (i = (i | (i << 2)) & 858993459),
        (i = (i | (i << 1)) & 1431655765),
        (e = (e | (e << 8)) & 16711935),
        (e = (e | (e << 4)) & 252645135),
        (e = (e | (e << 2)) & 858993459),
        (e = (e | (e << 1)) & 1431655765),
        i | (e << 1)
      );
    }
    function Vg(i) {
      let e = i,
        t = i;
      do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
      while (e !== i);
      return t;
    }
    function sc(i, e, t, A, r, s, n, a) {
      return (
        (r - n) * (e - a) >= (i - n) * (s - a) &&
        (i - n) * (A - a) >= (t - n) * (e - a) &&
        (t - n) * (s - a) >= (r - n) * (A - a)
      );
    }
    function xA(i, e, t, A, r, s, n, a) {
      return !(i === n && e === a) && sc(i, e, t, A, r, s, n, a);
    }
    function Tg(i, e) {
      return (
        i.next.i !== e.i &&
        i.prev.i !== e.i &&
        !Ig(i, e) &&
        ((YA(i, e) && YA(e, i) && bg(i, e) && (Ae(i.prev, i, e.prev) || Ae(i, e.prev, e))) ||
          ($t(i, e) && Ae(i.prev, i, i.next) > 0 && Ae(e.prev, e, e.next) > 0))
      );
    }
    function Ae(i, e, t) {
      return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
    }
    function $t(i, e) {
      return i.x === e.x && i.y === e.y;
    }
    function nc(i, e, t, A) {
      const r = fi(Ae(i, e, t)),
        s = fi(Ae(i, e, A)),
        n = fi(Ae(t, A, i)),
        a = fi(Ae(t, A, e));
      return !!(
        (r !== s && n !== a) ||
        (r === 0 && di(i, t, e)) ||
        (s === 0 && di(i, A, e)) ||
        (n === 0 && di(t, i, A)) ||
        (a === 0 && di(t, e, A))
      );
    }
    function di(i, e, t) {
      return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
    }
    function fi(i) {
      return i > 0 ? 1 : i < 0 ? -1 : 0;
    }
    function Ig(i, e) {
      let t = i;
      do {
        if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && nc(t, t.next, i, e)) return !0;
        t = t.next;
      } while (t !== i);
      return !1;
    }
    function YA(i, e) {
      return Ae(i.prev, i, i.next) < 0
        ? Ae(i, e, i.next) >= 0 && Ae(i, i.prev, e) >= 0
        : Ae(i, e, i.prev) < 0 || Ae(i, i.next, e) < 0;
    }
    function bg(i, e) {
      let t = i,
        A = !1;
      const r = (i.x + e.x) / 2,
        s = (i.y + e.y) / 2;
      do
        t.y > s != t.next.y > s && t.next.y !== t.y && r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x && (A = !A),
          (t = t.next);
      while (t !== i);
      return A;
    }
    function ac(i, e) {
      const t = ds(i.i, i.x, i.y),
        A = ds(e.i, e.x, e.y),
        r = i.next,
        s = e.prev;
      return (i.next = e), (e.prev = i), (t.next = r), (r.prev = t), (A.next = t), (t.prev = A), (s.next = A), (A.prev = s), A;
    }
    function zo(i, e, t, A) {
      const r = ds(i, e, t);
      return A ? ((r.next = A.next), (r.prev = A), (A.next.prev = r), (A.next = r)) : ((r.prev = r), (r.next = r)), r;
    }
    function DA(i) {
      (i.next.prev = i.prev),
        (i.prev.next = i.next),
        i.prevZ && (i.prevZ.nextZ = i.nextZ),
        i.nextZ && (i.nextZ.prevZ = i.prevZ);
    }
    function ds(i, e, t) {
      return { i, x: e, y: t, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
    }
    function yg(i, e, t, A) {
      let r = 0;
      for (let s = e, n = t - A; s < t; s += A) (r += (i[n] - i[s]) * (i[s + 1] + i[n + 1])), (n = s);
      return r;
    }
    const oc = Ho.default || Ho;
    var Ve = ((i) => (
      (i[(i.NONE = 0)] = 'NONE'),
      (i[(i.COLOR = 16384)] = 'COLOR'),
      (i[(i.STENCIL = 1024)] = 'STENCIL'),
      (i[(i.DEPTH = 256)] = 'DEPTH'),
      (i[(i.COLOR_DEPTH = 16640)] = 'COLOR_DEPTH'),
      (i[(i.COLOR_STENCIL = 17408)] = 'COLOR_STENCIL'),
      (i[(i.DEPTH_STENCIL = 1280)] = 'DEPTH_STENCIL'),
      (i[(i.ALL = 17664)] = 'ALL'),
      i
    ))(Ve || {});
    class hn {
      constructor(e) {
        (this.items = []), (this._name = e);
      }
      emit(e, t, A, r, s, n, a, l) {
        const { name: h, items: u } = this;
        for (let o = 0, c = u.length; o < c; o++) u[o][h](e, t, A, r, s, n, a, l);
        return this;
      }
      add(e) {
        return e[this._name] && (this.remove(e), this.items.push(e)), this;
      }
      remove(e) {
        const t = this.items.indexOf(e);
        return t !== -1 && this.items.splice(t, 1), this;
      }
      contains(e) {
        return this.items.indexOf(e) !== -1;
      }
      removeAll() {
        return (this.items.length = 0), this;
      }
      destroy() {
        this.removeAll(), (this.items = null), (this._name = null);
      }
      get empty() {
        return this.items.length === 0;
      }
      get name() {
        return this._name;
      }
    }
    const xg = [
      'init',
      'destroy',
      'contextChange',
      'resolutionChange',
      'resetState',
      'renderEnd',
      'renderStart',
      'render',
      'update',
      'postrender',
      'prerender',
    ],
      lc = class hc extends ye {
        constructor(e) {
          super(),
            (this.uid = z('renderer')),
            (this.runners = Object.create(null)),
            (this.renderPipes = Object.create(null)),
            (this._initOptions = {}),
            (this._systemsHash = Object.create(null)),
            (this.type = e.type),
            (this.name = e.name),
            (this.config = e);
          const t = [...xg, ...(this.config.runners ?? [])];
          this._addRunners(...t), this._unsafeEvalCheck();
        }
        async init(e = {}) {
          const t = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
          await ic(t),
            this._addSystems(this.config.systems),
            this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
          for (const A in this._systemsHash) e = { ...this._systemsHash[A].constructor.defaultOptions, ...e };
          (e = { ...hc.defaultOptions, ...e }), (this._roundPixels = e.roundPixels ? 1 : 0);
          for (let A = 0; A < this.runners.init.items.length; A++) await this.runners.init.items[A].init(e);
          this._initOptions = e;
        }
        render(e, t) {
          let A = e;
          if (
            (A instanceof _ &&
              ((A = { container: A }),
                t &&
                (P(W, 'passing a second argument is deprecated, please use render options instead'),
                  (A.target = t.renderTexture))),
              A.target || (A.target = this.view.renderTarget),
              A.target === this.view.renderTarget &&
              ((this._lastObjectRendered = A.container),
                A.clearColor ?? (A.clearColor = this.background.colorRgba),
                A.clear ?? (A.clear = this.background.clearBeforeRender)),
              A.clearColor)
          ) {
            const r = Array.isArray(A.clearColor) && A.clearColor.length === 4;
            A.clearColor = r ? A.clearColor : $.shared.setValue(A.clearColor).toArray();
          }
          A.transform || (A.container.updateLocalTransform(), (A.transform = A.container.localTransform)),
            A.container.visible &&
            (A.container.enableRenderGroup(),
              this.runners.prerender.emit(A),
              this.runners.renderStart.emit(A),
              this.runners.render.emit(A),
              this.runners.renderEnd.emit(A),
              this.runners.postrender.emit(A));
        }
        resize(e, t, A) {
          const r = this.view.resolution;
          this.view.resize(e, t, A),
            this.emit('resize', this.view.screen.width, this.view.screen.height, this.view.resolution),
            A !== void 0 && A !== r && this.runners.resolutionChange.emit(A);
        }
        clear(e = {}) {
          const t = this;
          e.target || (e.target = t.renderTarget.renderTarget),
            e.clearColor || (e.clearColor = this.background.colorRgba),
            e.clear ?? (e.clear = Ve.ALL);
          const { clear: A, clearColor: r, target: s } = e;
          $.shared.setValue(r ?? this.background.colorRgba), t.renderTarget.clear(s, A, $.shared.toArray());
        }
        get resolution() {
          return this.view.resolution;
        }
        set resolution(e) {
          (this.view.resolution = e), this.runners.resolutionChange.emit(e);
        }
        get width() {
          return this.view.texture.frame.width;
        }
        get height() {
          return this.view.texture.frame.height;
        }
        get canvas() {
          return this.view.canvas;
        }
        get lastObjectRendered() {
          return this._lastObjectRendered;
        }
        get renderingToScreen() {
          return this.renderTarget.renderingToScreen;
        }
        get screen() {
          return this.view.screen;
        }
        _addRunners(...e) {
          e.forEach((t) => {
            this.runners[t] = new hn(t);
          });
        }
        _addSystems(e) {
          let t;
          for (t in e) {
            const A = e[t];
            this._addSystem(A.value, A.name);
          }
        }
        _addSystem(e, t) {
          const A = new e(this);
          if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`);
          (this[t] = A), (this._systemsHash[t] = A);
          for (const r in this.runners) this.runners[r].add(A);
          return this;
        }
        _addPipes(e, t) {
          const A = t.reduce((r, s) => ((r[s.name] = s.value), r), {});
          e.forEach((r) => {
            const s = r.value,
              n = r.name,
              a = A[n];
            (this.renderPipes[n] = new s(this, a ? new a() : null)), this.runners.destroy.add(this.renderPipes[n]);
          });
        }
        destroy(e = !1) {
          this.runners.destroy.items.reverse(),
            this.runners.destroy.emit(e),
            (e === !0 || (typeof e == 'object' && e.releaseGlobalResources)) && kt.release(),
            Object.values(this.runners).forEach((t) => {
              t.destroy();
            }),
            (this._systemsHash = null),
            (this.renderPipes = null);
        }
        generateTexture(e) {
          return this.textureGenerator.generateTexture(e);
        }
        get roundPixels() {
          return !!this._roundPixels;
        }
        _unsafeEvalCheck() {
          if (!ln())
            throw new Error(
              'Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.'
            );
        }
        resetState() {
          this.runners.resetState.emit();
        }
      };
    lc.defaultOptions = { resolution: 1, failIfMajorPerformanceCaveat: !1, roundPixels: !1 };
    let zA = lc,
      pi;
    function cc(i) {
      return (
        pi !== void 0 ||
        (pi = (() => {
          const e = { stencil: !0, failIfMajorPerformanceCaveat: i ?? zA.defaultOptions.failIfMajorPerformanceCaveat };
          try {
            if (!J.get().getWebGLRenderingContext()) return !1;
            let A = J.get().createCanvas().getContext('webgl', e);
            const r = !!A?.getContextAttributes()?.stencil;
            if (A) {
              const s = A.getExtension('WEBGL_lose_context');
              s && s.loseContext();
            }
            return (A = null), r;
          } catch {
            return !1;
          }
        })()),
        pi
      );
    }
    let gi;
    async function uc(i = {}) {
      return (
        gi !== void 0 ||
        (gi = await (async () => {
          const e = J.get().getNavigator().gpu;
          if (!e) return !1;
          try {
            return await (await e.requestAdapter(i)).requestDevice(), !0;
          } catch {
            return !1;
          }
        })()),
        gi
      );
    }
    const _o = ['webgl', 'webgpu', 'canvas'];
    async function dc(i) {
      let e = [];
      i.preference
        ? (e.push(i.preference),
          _o.forEach((s) => {
            s !== i.preference && e.push(s);
          }))
        : (e = _o.slice());
      let t,
        A = {};
      for (let s = 0; s < e.length; s++) {
        const n = e[s];
        if (n === 'webgpu' && (await uc())) {
          const { WebGPURenderer: a } = await QA(
            async () => {
              const { WebGPURenderer: l } = await Promise.resolve().then(() => JS);
              return { WebGPURenderer: l };
            },
            void 0,
            import.meta.url
          );
          (t = a), (A = { ...i, ...i.webgpu });
          break;
        } else if (n === 'webgl' && cc(i.failIfMajorPerformanceCaveat ?? zA.defaultOptions.failIfMajorPerformanceCaveat)) {
          const { WebGLRenderer: a } = await QA(
            async () => {
              const { WebGLRenderer: l } = await Promise.resolve().then(() => US);
              return { WebGLRenderer: l };
            },
            void 0,
            import.meta.url
          );
          (t = a), (A = { ...i, ...i.webgl });
          break;
        } else if (n === 'canvas') throw ((A = { ...i }), new Error('CanvasRenderer is not yet implemented'));
      }
      if ((delete A.webgpu, delete A.webgl, !t)) throw new Error('No available renderer for the current environment');
      const r = new t();
      return await r.init(A), r;
    }
    const OA = '8.14.3';
    class cn {
      static init() {
        globalThis.__PIXI_APP_INIT__?.(this, OA);
      }
      static destroy() { }
    }
    cn.extension = M.Application;
    class un {
      constructor(e) {
        this._renderer = e;
      }
      init() {
        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, OA);
      }
      destroy() {
        this._renderer = null;
      }
    }
    un.extension = { type: [M.WebGLSystem, M.WebGPUSystem], name: 'initHook', priority: -10 };
    const fc = class fs {
      constructor(...e) {
        (this.stage = new _()),
          e[0] !== void 0 && P(W, 'Application constructor options are deprecated, please use Application.init() instead.');
      }
      async init(e) {
        (e = { ...e }),
          this.stage || (this.stage = new _()),
          (this.renderer = await dc(e)),
          fs._plugins.forEach((t) => {
            t.init.call(this, e);
          });
      }
      render() {
        this.renderer.render({ container: this.stage });
      }
      get canvas() {
        return this.renderer.canvas;
      }
      get view() {
        return P(W, 'Application.view is deprecated, please use Application.canvas instead.'), this.renderer.canvas;
      }
      get screen() {
        return this.renderer.screen;
      }
      destroy(e = !1, t = !1) {
        const A = fs._plugins.slice(0);
        A.reverse(),
          A.forEach((r) => {
            r.destroy.call(this);
          }),
          this.stage.destroy(t),
          (this.stage = null),
          this.renderer.destroy(e),
          (this.renderer = null);
      }
    };
    fc._plugins = [];
    let dn = fc;
    Q.handleByList(M.Application, dn._plugins);
    Q.add(cn);
    class fn {
      static init(e) {
        Object.defineProperty(this, 'resizeTo', {
          configurable: !0,
          set(t) {
            globalThis.removeEventListener('resize', this.queueResize),
              (this._resizeTo = t),
              t && (globalThis.addEventListener('resize', this.queueResize), this.resize());
          },
          get() {
            return this._resizeTo;
          },
        }),
          (this.queueResize = () => {
            this._resizeTo && (this._cancelResize(), (this._resizeId = requestAnimationFrame(() => this.resize())));
          }),
          (this._cancelResize = () => {
            this._resizeId && (cancelAnimationFrame(this._resizeId), (this._resizeId = null));
          }),
          (this.resize = () => {
            if (!this._resizeTo) return;
            this._cancelResize();
            let t, A;
            if (this._resizeTo === globalThis.window) (t = globalThis.innerWidth), (A = globalThis.innerHeight);
            else {
              const { clientWidth: r, clientHeight: s } = this._resizeTo;
              (t = r), (A = s);
            }
            this.renderer.resize(t, A), this.render();
          }),
          (this._resizeId = null),
          (this._resizeTo = null),
          (this.resizeTo = e.resizeTo || null);
      }
      static destroy() {
        globalThis.removeEventListener('resize', this.queueResize),
          this._cancelResize(),
          (this._cancelResize = null),
          (this.queueResize = null),
          (this.resizeTo = null),
          (this.resize = null);
      }
    }
    fn.extension = M.Application;
    class pn {
      static init(e) {
        (e = Object.assign({ autoStart: !0, sharedTicker: !1 }, e)),
          Object.defineProperty(this, 'ticker', {
            configurable: !0,
            set(t) {
              this._ticker && this._ticker.remove(this.render, this), (this._ticker = t), t && t.add(this.render, this, ut.LOW);
            },
            get() {
              return this._ticker;
            },
          }),
          (this.stop = () => {
            this._ticker.stop();
          }),
          (this.start = () => {
            this._ticker.start();
          }),
          (this._ticker = null),
          (this.ticker = e.sharedTicker ? ue.shared : new ue()),
          e.autoStart && this.start();
      }
      static destroy() {
        if (this._ticker) {
          const e = this._ticker;
          (this.ticker = null), e.destroy();
        }
      }
    }
    pn.extension = M.Application;
    class gn extends ye {
      constructor() {
        super(...arguments),
          (this.chars = Object.create(null)),
          (this.lineHeight = 0),
          (this.fontFamily = ''),
          (this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }),
          (this.baseLineOffset = 0),
          (this.distanceField = { type: 'none', range: 0 }),
          (this.pages = []),
          (this.applyFillAsTint = !0),
          (this.baseMeasurementFontSize = 100),
          (this.baseRenderedFontSize = 100);
      }
      get font() {
        return P(W, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.'), this.fontFamily;
      }
      get pageTextures() {
        return P(W, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.'), this.pages;
      }
      get size() {
        return (
          P(W, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.'), this.fontMetrics.fontSize
        );
      }
      get distanceFieldRange() {
        return (
          P(W, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.'),
          this.distanceField.range
        );
      }
      get distanceFieldType() {
        return (
          P(W, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.'),
          this.distanceField.type
        );
      }
      destroy(e = !1) {
        this.emit('destroy', this), this.removeAllListeners();
        for (const t in this.chars) this.chars[t].texture?.destroy();
        (this.chars = null), e && (this.pages.forEach((t) => t.texture.destroy(!0)), (this.pages = null));
      }
    }
      /**
       * tiny-lru
       *
       * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
       * @license BSD-3-Clause
       * @version 11.4.5
       */ class vg {
      constructor(e = 0, t = 0, A = !1) {
        (this.first = null),
          (this.items = Object.create(null)),
          (this.last = null),
          (this.max = e),
          (this.resetTtl = A),
          (this.size = 0),
          (this.ttl = t);
      }
      clear() {
        return (this.first = null), (this.items = Object.create(null)), (this.last = null), (this.size = 0), this;
      }
      delete(e) {
        if (this.has(e)) {
          const t = this.items[e];
          delete this.items[e],
            this.size--,
            t.prev !== null && (t.prev.next = t.next),
            t.next !== null && (t.next.prev = t.prev),
            this.first === t && (this.first = t.next),
            this.last === t && (this.last = t.prev);
        }
        return this;
      }
      entries(e = this.keys()) {
        return e.map((t) => [t, this.get(t)]);
      }
      evict(e = !1) {
        if (e || this.size > 0) {
          const t = this.first;
          delete this.items[t.key],
            --this.size === 0 ? ((this.first = null), (this.last = null)) : ((this.first = t.next), (this.first.prev = null));
        }
        return this;
      }
      expiresAt(e) {
        let t;
        return this.has(e) && (t = this.items[e].expiry), t;
      }
      get(e) {
        const t = this.items[e];
        if (t !== void 0) {
          if (this.ttl > 0 && t.expiry <= Date.now()) {
            this.delete(e);
            return;
          }
          return this.moveToEnd(t), t.value;
        }
      }
      has(e) {
        return e in this.items;
      }
      moveToEnd(e) {
        this.last !== e &&
          (e.prev !== null && (e.prev.next = e.next),
            e.next !== null && (e.next.prev = e.prev),
            this.first === e && (this.first = e.next),
            (e.prev = this.last),
            (e.next = null),
            this.last !== null && (this.last.next = e),
            (this.last = e),
            this.first === null && (this.first = e));
      }
      keys() {
        const e = [];
        let t = this.first;
        for (; t !== null;) e.push(t.key), (t = t.next);
        return e;
      }
      setWithEvicted(e, t, A = this.resetTtl) {
        let r = null;
        if (this.has(e)) this.set(e, t, !0, A);
        else {
          this.max > 0 && this.size === this.max && ((r = { ...this.first }), this.evict(!0));
          let s = (this.items[e] = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key: e,
            prev: this.last,
            next: null,
            value: t,
          });
          ++this.size === 1 ? (this.first = s) : (this.last.next = s), (this.last = s);
        }
        return r;
      }
      set(e, t, A = !1, r = this.resetTtl) {
        let s = this.items[e];
        return (
          A || s !== void 0
            ? ((s.value = t), A === !1 && r && (s.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.moveToEnd(s))
            : (this.max > 0 && this.size === this.max && this.evict(!0),
              (s = this.items[e] =
                { expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl, key: e, prev: this.last, next: null, value: t }),
              ++this.size === 1 ? (this.first = s) : (this.last.next = s),
              (this.last = s)),
          this
        );
      }
      values(e = this.keys()) {
        return e.map((t) => this.get(t));
      }
    }
    function pc(i = 1e3, e = 0, t = !1) {
      if (isNaN(i) || i < 0) throw new TypeError('Invalid max value');
      if (isNaN(e) || e < 0) throw new TypeError('Invalid ttl value');
      if (typeof t != 'boolean') throw new TypeError('Invalid resetTtl value');
      return new vg(i, e, t);
    }
    const Cg = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'];
    function LA(i) {
      const e = typeof i.fontSize == 'number' ? `${i.fontSize}px` : i.fontSize;
      let t = i.fontFamily;
      Array.isArray(i.fontFamily) || (t = i.fontFamily.split(','));
      for (let A = t.length - 1; A >= 0; A--) {
        let r = t[A].trim();
        !/([\"\'])[^\'\"]+\1/.test(r) && !Cg.includes(r) && (r = `"${r}"`), (t[A] = r);
      }
      return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${e} ${t.join(',')}`;
    }
    const Jr = { willReadFrequently: !0 },
      Ge = class k {
        static get experimentalLetterSpacingSupported() {
          let e = k._experimentalLetterSpacingSupported;
          if (e === void 0) {
            const t = J.get().getCanvasRenderingContext2D().prototype;
            e = k._experimentalLetterSpacingSupported = 'letterSpacing' in t || 'textLetterSpacing' in t;
          }
          return e;
        }
        constructor(e, t, A, r, s, n, a, l, h) {
          (this.text = e),
            (this.style = t),
            (this.width = A),
            (this.height = r),
            (this.lines = s),
            (this.lineWidths = n),
            (this.lineHeight = a),
            (this.maxLineWidth = l),
            (this.fontProperties = h);
        }
        static measureText(e = ' ', t, A = k._canvas, r = t.wordWrap) {
          const s = `${e}-${t.styleKey}-wordWrap-${r}`;
          if (k._measurementCache.has(s)) return k._measurementCache.get(s);
          const n = LA(t),
            a = k.measureFont(n);
          a.fontSize === 0 && ((a.fontSize = t.fontSize), (a.ascent = t.fontSize));
          const l = k.__context;
          l.font = n;
          const u = (r ? k._wordWrap(e, t, A) : e).split(/(?:\r\n|\r|\n)/),
            o = new Array(u.length);
          let c = 0;
          for (let S = 0; S < u.length; S++) {
            const q = k._measureText(u[S], t.letterSpacing, l);
            (o[S] = q), (c = Math.max(c, q));
          }
          const d = t._stroke?.width || 0;
          let f = c + d;
          t.dropShadow && (f += t.dropShadow.distance);
          const g = t.lineHeight || a.fontSize;
          let p = Math.max(g, a.fontSize + d) + (u.length - 1) * (g + t.leading);
          t.dropShadow && (p += t.dropShadow.distance);
          const m = new k(e, t, f, p, u, o, g + t.leading, c, a);
          return k._measurementCache.set(s, m), m;
        }
        static _measureText(e, t, A) {
          let r = !1;
          k.experimentalLetterSpacingSupported &&
            (k.experimentalLetterSpacing
              ? ((A.letterSpacing = `${t}px`), (A.textLetterSpacing = `${t}px`), (r = !0))
              : ((A.letterSpacing = '0px'), (A.textLetterSpacing = '0px')));
          const s = A.measureText(e);
          let n = s.width;
          const a = -s.actualBoundingBoxLeft;
          let h = s.actualBoundingBoxRight - a;
          if (n > 0)
            if (r) (n -= t), (h -= t);
            else {
              const u = (k.graphemeSegmenter(e).length - 1) * t;
              (n += u), (h += u);
            }
          return Math.max(n, h);
        }
        static _wordWrap(e, t, A = k._canvas) {
          const r = A.getContext('2d', Jr);
          let s = 0,
            n = '',
            a = '';
          const l = Object.create(null),
            { letterSpacing: h, whiteSpace: u } = t,
            o = k._collapseSpaces(u),
            c = k._collapseNewlines(u);
          let d = !o;
          const f = t.wordWrapWidth + h,
            g = k._tokenize(e);
          for (let p = 0; p < g.length; p++) {
            let m = g[p];
            if (k._isNewline(m)) {
              if (!c) {
                (a += k._addLine(n)), (d = !o), (n = ''), (s = 0);
                continue;
              }
              m = ' ';
            }
            if (o) {
              const q = k.isBreakingSpace(m),
                E = k.isBreakingSpace(n[n.length - 1]);
              if (q && E) continue;
            }
            const S = k._getFromCache(m, h, l, r);
            if (S > f)
              if ((n !== '' && ((a += k._addLine(n)), (n = ''), (s = 0)), k.canBreakWords(m, t.breakWords))) {
                const q = k.wordWrapSplit(m);
                for (let E = 0; E < q.length; E++) {
                  let b = q[E],
                    T = b,
                    I = 1;
                  for (; q[E + I];) {
                    const y = q[E + I];
                    if (!k.canBreakChars(T, y, m, E, t.breakWords)) b += y;
                    else break;
                    (T = y), I++;
                  }
                  E += I - 1;
                  const B = k._getFromCache(b, h, l, r);
                  B + s > f && ((a += k._addLine(n)), (d = !1), (n = ''), (s = 0)), (n += b), (s += B);
                }
              } else {
                n.length > 0 && ((a += k._addLine(n)), (n = ''), (s = 0));
                const q = p === g.length - 1;
                (a += k._addLine(m, !q)), (d = !1), (n = ''), (s = 0);
              }
            else
              S + s > f && ((d = !1), (a += k._addLine(n)), (n = ''), (s = 0)),
                (n.length > 0 || !k.isBreakingSpace(m) || d) && ((n += m), (s += S));
          }
          return (a += k._addLine(n, !1)), a;
        }
        static _addLine(e, t = !0) {
          return (
            (e = k._trimRight(e)),
            (e = t
              ? `${e}
`
              : e),
            e
          );
        }
        static _getFromCache(e, t, A, r) {
          let s = A[e];
          return typeof s != 'number' && ((s = k._measureText(e, t, r) + t), (A[e] = s)), s;
        }
        static _collapseSpaces(e) {
          return e === 'normal' || e === 'pre-line';
        }
        static _collapseNewlines(e) {
          return e === 'normal';
        }
        static _trimRight(e) {
          if (typeof e != 'string') return '';
          for (let t = e.length - 1; t >= 0; t--) {
            const A = e[t];
            if (!k.isBreakingSpace(A)) break;
            e = e.slice(0, -1);
          }
          return e;
        }
        static _isNewline(e) {
          return typeof e != 'string' ? !1 : k._newlines.includes(e.charCodeAt(0));
        }
        static isBreakingSpace(e, t) {
          return typeof e != 'string' ? !1 : k._breakingSpaces.includes(e.charCodeAt(0));
        }
        static _tokenize(e) {
          const t = [];
          let A = '';
          if (typeof e != 'string') return t;
          for (let r = 0; r < e.length; r++) {
            const s = e[r],
              n = e[r + 1];
            if (k.isBreakingSpace(s, n) || k._isNewline(s)) {
              A !== '' && (t.push(A), (A = '')),
                s === '\r' &&
                  n ===
                  `
`
                  ? (t.push(`\r
`),
                    r++)
                  : t.push(s);
              continue;
            }
            A += s;
          }
          return A !== '' && t.push(A), t;
        }
        static canBreakWords(e, t) {
          return t;
        }
        static canBreakChars(e, t, A, r, s) {
          return !0;
        }
        static wordWrapSplit(e) {
          return k.graphemeSegmenter(e);
        }
        static measureFont(e) {
          if (k._fonts[e]) return k._fonts[e];
          const t = k._context;
          t.font = e;
          const A = t.measureText(k.METRICS_STRING + k.BASELINE_SYMBOL),
            r = {
              ascent: A.actualBoundingBoxAscent,
              descent: A.actualBoundingBoxDescent,
              fontSize: A.actualBoundingBoxAscent + A.actualBoundingBoxDescent,
            };
          return (k._fonts[e] = r), r;
        }
        static clearMetrics(e = '') {
          e ? delete k._fonts[e] : (k._fonts = {});
        }
        static get _canvas() {
          if (!k.__canvas) {
            let e;
            try {
              const t = new OffscreenCanvas(0, 0);
              if (t.getContext('2d', Jr)?.measureText) return (k.__canvas = t), t;
              e = J.get().createCanvas();
            } catch {
              e = J.get().createCanvas();
            }
            (e.width = e.height = 10), (k.__canvas = e);
          }
          return k.__canvas;
        }
        static get _context() {
          return k.__context || (k.__context = k._canvas.getContext('2d', Jr)), k.__context;
        }
      };
    Ge.METRICS_STRING = '|q';
    Ge.BASELINE_SYMBOL = 'M';
    Ge.BASELINE_MULTIPLIER = 1.4;
    Ge.HEIGHT_MULTIPLIER = 2;
    Ge.graphemeSegmenter = (() => {
      if (typeof Intl?.Segmenter == 'function') {
        const i = new Intl.Segmenter();
        return (e) => {
          const t = i.segment(e),
            A = [];
          let r = 0;
          for (const s of t) A[r++] = s.segment;
          return A;
        };
      }
      return (i) => [...i];
    })();
    Ge.experimentalLetterSpacing = !1;
    Ge._fonts = {};
    Ge._newlines = [10, 13];
    Ge._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
    Ge._measurementCache = pc(1e3);
    let Ne = Ge;
    const $o = [
      { offset: 0, color: 'white' },
      { offset: 1, color: 'black' },
    ],
      mn = class ps {
        constructor(...e) {
          (this.uid = z('fillGradient')), (this._tick = 0), (this.type = 'linear'), (this.colorStops = []);
          let t = Ug(e);
          (t = { ...(t.type === 'radial' ? ps.defaultRadialOptions : ps.defaultLinearOptions), ...wA(t) }),
            (this._textureSize = t.textureSize),
            (this._wrapMode = t.wrapMode),
            t.type === 'radial'
              ? ((this.center = t.center),
                (this.outerCenter = t.outerCenter ?? this.center),
                (this.innerRadius = t.innerRadius),
                (this.outerRadius = t.outerRadius),
                (this.scale = t.scale),
                (this.rotation = t.rotation))
              : ((this.start = t.start), (this.end = t.end)),
            (this.textureSpace = t.textureSpace),
            (this.type = t.type),
            t.colorStops.forEach((r) => {
              this.addColorStop(r.offset, r.color);
            });
        }
        addColorStop(e, t) {
          return this.colorStops.push({ offset: e, color: $.shared.setValue(t).toHexa() }), this;
        }
        buildLinearGradient() {
          if (this.texture) return;
          let { x: e, y: t } = this.start,
            { x: A, y: r } = this.end,
            s = A - e,
            n = r - t;
          const a = s < 0 || n < 0;
          if (this._wrapMode === 'clamp-to-edge') {
            if (s < 0) {
              const p = e;
              (e = A), (A = p), (s *= -1);
            }
            if (n < 0) {
              const p = t;
              (t = r), (r = p), (n *= -1);
            }
          }
          const l = this.colorStops.length ? this.colorStops : $o,
            h = this._textureSize,
            { canvas: u, context: o } = tl(h, 1),
            c = a ? o.createLinearGradient(this._textureSize, 0, 0, 0) : o.createLinearGradient(0, 0, this._textureSize, 0);
          el(c, l),
            (o.fillStyle = c),
            o.fillRect(0, 0, h, 1),
            (this.texture = new v({ source: new ct({ resource: u, addressMode: this._wrapMode }) }));
          const d = Math.sqrt(s * s + n * n),
            f = Math.atan2(n, s),
            g = new R();
          g.scale(d / h, 1),
            g.rotate(f),
            g.translate(e, t),
            this.textureSpace === 'local' && g.scale(h, h),
            (this.transform = g);
        }
        buildGradient() {
          this.texture || this._tick++, this.type === 'linear' ? this.buildLinearGradient() : this.buildRadialGradient();
        }
        buildRadialGradient() {
          if (this.texture) return;
          const e = this.colorStops.length ? this.colorStops : $o,
            t = this._textureSize,
            { canvas: A, context: r } = tl(t, t),
            { x: s, y: n } = this.center,
            { x: a, y: l } = this.outerCenter,
            h = this.innerRadius,
            u = this.outerRadius,
            o = a - u,
            c = l - u,
            d = t / (u * 2),
            f = (s - o) * d,
            g = (n - c) * d,
            p = r.createRadialGradient(f, g, h * d, (a - o) * d, (l - c) * d, u * d);
          el(p, e),
            (r.fillStyle = e[e.length - 1].color),
            r.fillRect(0, 0, t, t),
            (r.fillStyle = p),
            r.translate(f, g),
            r.rotate(this.rotation),
            r.scale(1, this.scale),
            r.translate(-f, -g),
            r.fillRect(0, 0, t, t),
            (this.texture = new v({ source: new ct({ resource: A, addressMode: this._wrapMode }) }));
          const m = new R();
          m.scale(1 / d, 1 / d), m.translate(o, c), this.textureSpace === 'local' && m.scale(t, t), (this.transform = m);
        }
        destroy() {
          this.texture?.destroy(!0),
            (this.texture = null),
            (this.transform = null),
            (this.colorStops = []),
            (this.start = null),
            (this.end = null),
            (this.center = null),
            (this.outerCenter = null);
        }
        get styleKey() {
          return `fill-gradient-${this.uid}-${this._tick}`;
        }
      };
    mn.defaultLinearOptions = {
      start: { x: 0, y: 0 },
      end: { x: 0, y: 1 },
      colorStops: [],
      textureSpace: 'local',
      type: 'linear',
      textureSize: 256,
      wrapMode: 'clamp-to-edge',
    };
    mn.defaultRadialOptions = {
      center: { x: 0.5, y: 0.5 },
      innerRadius: 0,
      outerRadius: 0.5,
      colorStops: [],
      scale: 1,
      textureSpace: 'local',
      type: 'radial',
      textureSize: 256,
      wrapMode: 'clamp-to-edge',
    };
    let Ze = mn;
    function el(i, e) {
      for (let t = 0; t < e.length; t++) {
        const A = e[t];
        i.addColorStop(A.offset, A.color);
      }
    }
    function tl(i, e) {
      const t = J.get().createCanvas(i, e),
        A = t.getContext('2d');
      return { canvas: t, context: A };
    }
    function Ug(i) {
      let e = i[0] ?? {};
      return (
        (typeof e == 'number' || i[1]) &&
        (P('8.5.2', 'use options object instead'),
          (e = {
            type: 'linear',
            start: { x: i[0], y: i[1] },
            end: { x: i[2], y: i[3] },
            textureSpace: i[4],
            textureSize: i[5] ?? Ze.defaultLinearOptions.textureSize,
          })),
        e
      );
    }
    const Al = {
      repeat: { addressModeU: 'repeat', addressModeV: 'repeat' },
      'repeat-x': { addressModeU: 'repeat', addressModeV: 'clamp-to-edge' },
      'repeat-y': { addressModeU: 'clamp-to-edge', addressModeV: 'repeat' },
      'no-repeat': { addressModeU: 'clamp-to-edge', addressModeV: 'clamp-to-edge' },
    };
    class _A {
      constructor(e, t) {
        (this.uid = z('fillPattern')),
          (this._tick = 0),
          (this.transform = new R()),
          (this.texture = e),
          this.transform.scale(1 / e.frame.width, 1 / e.frame.height),
          t && ((e.source.style.addressModeU = Al[t].addressModeU), (e.source.style.addressModeV = Al[t].addressModeV));
      }
      setTransform(e) {
        const t = this.texture;
        this.transform.copyFrom(e),
          this.transform.invert(),
          this.transform.scale(1 / t.frame.width, 1 / t.frame.height),
          this._tick++;
      }
      get texture() {
        return this._texture;
      }
      set texture(e) {
        this._texture !== e && ((this._texture = e), this._tick++);
      }
      get styleKey() {
        return `fill-pattern-${this.uid}-${this._tick}`;
      }
      destroy() {
        this.texture.destroy(!0), (this.texture = null);
      }
    }
    var Gr, il;
    function kg() {
      if (il) return Gr;
      (il = 1), (Gr = t);
      var i = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
        e = /([astvzqmhlc])([^astvzqmhlc]*)/gi;
      function t(s) {
        var n = [];
        return (
          s.replace(e, function (a, l, h) {
            var u = l.toLowerCase();
            for (
              h = r(h), u == 'm' && h.length > 2 && (n.push([l].concat(h.splice(0, 2))), (u = 'l'), (l = l == 'm' ? 'l' : 'L'));
              ;

            ) {
              if (h.length == i[u]) return h.unshift(l), n.push(h);
              if (h.length < i[u]) throw new Error('malformed path data');
              n.push([l].concat(h.splice(0, i[u])));
            }
          }),
          n
        );
      }
      var A = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
      function r(s) {
        var n = s.match(A);
        return n ? n.map(Number) : [];
      }
      return Gr;
    }
    var Rg = kg();
    const Bg = Ol(Rg);
    function gc(i, e) {
      const t = Bg(i),
        A = [];
      let r = null,
        s = 0,
        n = 0;
      for (let a = 0; a < t.length; a++) {
        const l = t[a],
          h = l[0],
          u = l;
        switch (h) {
          case 'M':
            (s = u[1]), (n = u[2]), e.moveTo(s, n);
            break;
          case 'm':
            (s += u[1]), (n += u[2]), e.moveTo(s, n);
            break;
          case 'H':
            (s = u[1]), e.lineTo(s, n);
            break;
          case 'h':
            (s += u[1]), e.lineTo(s, n);
            break;
          case 'V':
            (n = u[1]), e.lineTo(s, n);
            break;
          case 'v':
            (n += u[1]), e.lineTo(s, n);
            break;
          case 'L':
            (s = u[1]), (n = u[2]), e.lineTo(s, n);
            break;
          case 'l':
            (s += u[1]), (n += u[2]), e.lineTo(s, n);
            break;
          case 'C':
            (s = u[5]), (n = u[6]), e.bezierCurveTo(u[1], u[2], u[3], u[4], s, n);
            break;
          case 'c':
            e.bezierCurveTo(s + u[1], n + u[2], s + u[3], n + u[4], s + u[5], n + u[6]), (s += u[5]), (n += u[6]);
            break;
          case 'S':
            (s = u[3]), (n = u[4]), e.bezierCurveToShort(u[1], u[2], s, n);
            break;
          case 's':
            e.bezierCurveToShort(s + u[1], n + u[2], s + u[3], n + u[4]), (s += u[3]), (n += u[4]);
            break;
          case 'Q':
            (s = u[3]), (n = u[4]), e.quadraticCurveTo(u[1], u[2], s, n);
            break;
          case 'q':
            e.quadraticCurveTo(s + u[1], n + u[2], s + u[3], n + u[4]), (s += u[3]), (n += u[4]);
            break;
          case 'T':
            (s = u[1]), (n = u[2]), e.quadraticCurveToShort(s, n);
            break;
          case 't':
            (s += u[1]), (n += u[2]), e.quadraticCurveToShort(s, n);
            break;
          case 'A':
            (s = u[6]), (n = u[7]), e.arcToSvg(u[1], u[2], u[3], u[4], u[5], s, n);
            break;
          case 'a':
            (s += u[6]), (n += u[7]), e.arcToSvg(u[1], u[2], u[3], u[4], u[5], s, n);
            break;
          case 'Z':
          case 'z':
            e.closePath(),
              A.length > 0 && ((r = A.pop()), r ? ((s = r.startX), (n = r.startY)) : ((s = 0), (n = 0))),
              (r = null);
            break;
          default:
            N(`Unknown SVG path command: ${h}`);
        }
        h !== 'Z' && h !== 'z' && r === null && ((r = { startX: s, startY: n }), A.push(r));
      }
      return e;
    }
    class Hi {
      constructor(e = 0, t = 0, A = 0) {
        (this.type = 'circle'), (this.x = e), (this.y = t), (this.radius = A);
      }
      clone() {
        return new Hi(this.x, this.y, this.radius);
      }
      contains(e, t) {
        if (this.radius <= 0) return !1;
        const A = this.radius * this.radius;
        let r = this.x - e,
          s = this.y - t;
        return (r *= r), (s *= s), r + s <= A;
      }
      strokeContains(e, t, A, r = 0.5) {
        if (this.radius === 0) return !1;
        const s = this.x - e,
          n = this.y - t,
          a = this.radius,
          l = (1 - r) * A,
          h = Math.sqrt(s * s + n * n);
        return h <= a + l && h > a - (A - l);
      }
      getBounds(e) {
        return (
          e || (e = new F()),
          (e.x = this.x - this.radius),
          (e.y = this.y - this.radius),
          (e.width = this.radius * 2),
          (e.height = this.radius * 2),
          e
        );
      }
      copyFrom(e) {
        return (this.x = e.x), (this.y = e.y), (this.radius = e.radius), this;
      }
      copyTo(e) {
        return e.copyFrom(this), e;
      }
      toString() {
        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      }
    }
    class zi {
      constructor(e = 0, t = 0, A = 0, r = 0) {
        (this.type = 'ellipse'), (this.x = e), (this.y = t), (this.halfWidth = A), (this.halfHeight = r);
      }
      clone() {
        return new zi(this.x, this.y, this.halfWidth, this.halfHeight);
      }
      contains(e, t) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1;
        let A = (e - this.x) / this.halfWidth,
          r = (t - this.y) / this.halfHeight;
        return (A *= A), (r *= r), A + r <= 1;
      }
      strokeContains(e, t, A, r = 0.5) {
        const { halfWidth: s, halfHeight: n } = this;
        if (s <= 0 || n <= 0) return !1;
        const a = A * (1 - r),
          l = A - a,
          h = s - l,
          u = n - l,
          o = s + a,
          c = n + a,
          d = e - this.x,
          f = t - this.y,
          g = (d * d) / (h * h) + (f * f) / (u * u),
          p = (d * d) / (o * o) + (f * f) / (c * c);
        return g > 1 && p <= 1;
      }
      getBounds(e) {
        return (
          e || (e = new F()),
          (e.x = this.x - this.halfWidth),
          (e.y = this.y - this.halfHeight),
          (e.width = this.halfWidth * 2),
          (e.height = this.halfHeight * 2),
          e
        );
      }
      copyFrom(e) {
        return (this.x = e.x), (this.y = e.y), (this.halfWidth = e.halfWidth), (this.halfHeight = e.halfHeight), this;
      }
      copyTo(e) {
        return e.copyFrom(this), e;
      }
      toString() {
        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
      }
    }
    function mc(i, e, t, A, r, s) {
      const n = i - t,
        a = e - A,
        l = r - t,
        h = s - A,
        u = n * l + a * h,
        o = l * l + h * h;
      let c = -1;
      o !== 0 && (c = u / o);
      let d, f;
      c < 0 ? ((d = t), (f = A)) : c > 1 ? ((d = r), (f = s)) : ((d = t + c * l), (f = A + c * h));
      const g = i - d,
        p = e - f;
      return g * g + p * p;
    }
    let Ng, Qg;
    class Lt {
      constructor(...e) {
        this.type = 'polygon';
        let t = Array.isArray(e[0]) ? e[0] : e;
        if (typeof t[0] != 'number') {
          const A = [];
          for (let r = 0, s = t.length; r < s; r++) A.push(t[r].x, t[r].y);
          t = A;
        }
        (this.points = t), (this.closePath = !0);
      }
      isClockwise() {
        let e = 0;
        const t = this.points,
          A = t.length;
        for (let r = 0; r < A; r += 2) {
          const s = t[r],
            n = t[r + 1],
            a = t[(r + 2) % A],
            l = t[(r + 3) % A];
          e += (a - s) * (l + n);
        }
        return e < 0;
      }
      containsPolygon(e) {
        const t = this.getBounds(Ng),
          A = e.getBounds(Qg);
        if (!t.containsRect(A)) return !1;
        const r = e.points;
        for (let s = 0; s < r.length; s += 2) {
          const n = r[s],
            a = r[s + 1];
          if (!this.contains(n, a)) return !1;
        }
        return !0;
      }
      clone() {
        const e = this.points.slice(),
          t = new Lt(e);
        return (t.closePath = this.closePath), t;
      }
      contains(e, t) {
        let A = !1;
        const r = this.points.length / 2;
        for (let s = 0, n = r - 1; s < r; n = s++) {
          const a = this.points[s * 2],
            l = this.points[s * 2 + 1],
            h = this.points[n * 2],
            u = this.points[n * 2 + 1];
          l > t != u > t && e < (h - a) * ((t - l) / (u - l)) + a && (A = !A);
        }
        return A;
      }
      strokeContains(e, t, A, r = 0.5) {
        const s = A * A,
          n = s * (1 - r),
          a = s - n,
          { points: l } = this,
          h = l.length - (this.closePath ? 0 : 2);
        for (let u = 0; u < h; u += 2) {
          const o = l[u],
            c = l[u + 1],
            d = l[(u + 2) % l.length],
            f = l[(u + 3) % l.length],
            g = mc(e, t, o, c, d, f),
            p = Math.sign((d - o) * (t - c) - (f - c) * (e - o));
          if (g <= (p < 0 ? a : n)) return !0;
        }
        return !1;
      }
      getBounds(e) {
        e || (e = new F());
        const t = this.points;
        let A = 1 / 0,
          r = -1 / 0,
          s = 1 / 0,
          n = -1 / 0;
        for (let a = 0, l = t.length; a < l; a += 2) {
          const h = t[a],
            u = t[a + 1];
          (A = h < A ? h : A), (r = h > r ? h : r), (s = u < s ? u : s), (n = u > n ? u : n);
        }
        return (e.x = A), (e.width = r - A), (e.y = s), (e.height = n - s), e;
      }
      copyFrom(e) {
        return (this.points = e.points.slice()), (this.closePath = e.closePath), this;
      }
      copyTo(e) {
        return e.copyFrom(this), e;
      }
      toString() {
        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, t) => `${e}, ${t}`, '')}]`;
      }
      get lastX() {
        return this.points[this.points.length - 2];
      }
      get lastY() {
        return this.points[this.points.length - 1];
      }
      get x() {
        return (
          P('8.11.0', 'Polygon.lastX is deprecated, please use Polygon.lastX instead.'), this.points[this.points.length - 2]
        );
      }
      get y() {
        return P('8.11.0', 'Polygon.y is deprecated, please use Polygon.lastY instead.'), this.points[this.points.length - 1];
      }
      get startX() {
        return this.points[0];
      }
      get startY() {
        return this.points[1];
      }
    }
    const mi = (i, e, t, A, r, s, n) => {
      const a = i - t,
        l = e - A,
        h = Math.sqrt(a * a + l * l);
      return h >= r - s && h <= r + n;
    };
    class _i {
      constructor(e = 0, t = 0, A = 0, r = 0, s = 20) {
        (this.type = 'roundedRectangle'), (this.x = e), (this.y = t), (this.width = A), (this.height = r), (this.radius = s);
      }
      getBounds(e) {
        return e || (e = new F()), (e.x = this.x), (e.y = this.y), (e.width = this.width), (e.height = this.height), e;
      }
      clone() {
        return new _i(this.x, this.y, this.width, this.height, this.radius);
      }
      copyFrom(e) {
        return (this.x = e.x), (this.y = e.y), (this.width = e.width), (this.height = e.height), this;
      }
      copyTo(e) {
        return e.copyFrom(this), e;
      }
      contains(e, t) {
        if (this.width <= 0 || this.height <= 0) return !1;
        if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
          const A = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
          if ((t >= this.y + A && t <= this.y + this.height - A) || (e >= this.x + A && e <= this.x + this.width - A))
            return !0;
          let r = e - (this.x + A),
            s = t - (this.y + A);
          const n = A * A;
          if (
            r * r + s * s <= n ||
            ((r = e - (this.x + this.width - A)), r * r + s * s <= n) ||
            ((s = t - (this.y + this.height - A)), r * r + s * s <= n) ||
            ((r = e - (this.x + A)), r * r + s * s <= n)
          )
            return !0;
        }
        return !1;
      }
      strokeContains(e, t, A, r = 0.5) {
        const { x: s, y: n, width: a, height: l, radius: h } = this,
          u = A * (1 - r),
          o = A - u,
          c = s + h,
          d = n + h,
          f = a - h * 2,
          g = l - h * 2,
          p = s + a,
          m = n + l;
        return (((e >= s - u && e <= s + o) || (e >= p - o && e <= p + u)) && t >= d && t <= d + g) ||
          (((t >= n - u && t <= n + o) || (t >= m - o && t <= m + u)) && e >= c && e <= c + f)
          ? !0
          : (e < c && t < d && mi(e, t, c, d, h, o, u)) ||
          (e > p - h && t < d && mi(e, t, p - h, d, h, o, u)) ||
          (e > p - h && t > m - h && mi(e, t, p - h, m - h, h, o, u)) ||
          (e < c && t > m - h && mi(e, t, c, m - h, h, o, u));
      }
      toString() {
        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      }
    }
    const Sc = {};
    function $i(i, e, t) {
      let A = 2166136261;
      for (let r = 0; r < e; r++) (A ^= i[r].uid), (A = Math.imul(A, 16777619)), (A >>>= 0);
      return Sc[A] || wg(i, e, A, t);
    }
    function wg(i, e, t, A) {
      const r = {};
      let s = 0;
      for (let a = 0; a < A; a++) {
        const l = a < e ? i[a] : v.EMPTY.source;
        (r[s++] = l.source), (r[s++] = l.style);
      }
      const n = new Le(r);
      return (Sc[t] = n), n;
    }
    class bt {
      constructor(e) {
        typeof e == 'number'
          ? (this.rawBinaryData = new ArrayBuffer(e))
          : e instanceof Uint8Array
            ? (this.rawBinaryData = e.buffer)
            : (this.rawBinaryData = e),
          (this.uint32View = new Uint32Array(this.rawBinaryData)),
          (this.float32View = new Float32Array(this.rawBinaryData)),
          (this.size = this.rawBinaryData.byteLength);
      }
      get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
      }
      get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
      }
      get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
      }
      get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
      }
      get float64View() {
        return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
      }
      get bigUint64View() {
        return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
      }
      view(e) {
        return this[`${e}View`];
      }
      destroy() {
        (this.rawBinaryData = null),
          (this.uint32View = null),
          (this.float32View = null),
          (this.uint16View = null),
          (this._int8View = null),
          (this._uint8View = null),
          (this._int16View = null),
          (this._int32View = null),
          (this._float64Array = null),
          (this._bigUint64Array = null);
      }
      static sizeOf(e) {
        switch (e) {
          case 'int8':
          case 'uint8':
            return 1;
          case 'int16':
          case 'uint16':
            return 2;
          case 'int32':
          case 'uint32':
          case 'float32':
            return 4;
          default:
            throw new Error(`${e} isn't a valid view type`);
        }
      }
    }
    function Qi(i, e) {
      const t = (i.byteLength / 8) | 0,
        A = new Float64Array(i, 0, t);
      new Float64Array(e, 0, t).set(A);
      const s = i.byteLength - t * 8;
      if (s > 0) {
        const n = new Uint8Array(i, t * 8, s);
        new Uint8Array(e, t * 8, s).set(n);
      }
    }
    const qc = { normal: 'normal-npm', add: 'add-npm', screen: 'screen-npm' };
    var ie = ((i) => (
      (i[(i.DISABLED = 0)] = 'DISABLED'),
      (i[(i.RENDERING_MASK_ADD = 1)] = 'RENDERING_MASK_ADD'),
      (i[(i.MASK_ACTIVE = 2)] = 'MASK_ACTIVE'),
      (i[(i.INVERSE_MASK_ACTIVE = 3)] = 'INVERSE_MASK_ACTIVE'),
      (i[(i.RENDERING_MASK_REMOVE = 4)] = 'RENDERING_MASK_REMOVE'),
      (i[(i.NONE = 5)] = 'NONE'),
      i
    ))(ie || {});
    function eA(i, e) {
      return (e.alphaMode === 'no-premultiply-alpha' && qc[i]) || i;
    }
    const Pg = [
      'precision mediump float;',
      'void main(void){',
      'float test = 0.1;',
      '%forloop%',
      'gl_FragColor = vec4(0.0);',
      '}',
    ].join(`
`);
    function Jg(i) {
      let e = '';
      for (let t = 0; t < i; ++t)
        t > 0 &&
          (e += `
else `),
          t < i - 1 && (e += `if(test == ${t}.0){}`);
      return e;
    }
    function Sn(i, e) {
      if (i === 0) throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
      const t = e.createShader(e.FRAGMENT_SHADER);
      try {
        for (; ;) {
          const A = Pg.replace(/%forloop%/gi, Jg(i));
          if ((e.shaderSource(t, A), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS))) i = (i / 2) | 0;
          else break;
        }
      } finally {
        e.deleteShader(t);
      }
      return i;
    }
    let Pt = null;
    function Mc() {
      if (Pt) return Pt;
      const i = nn();
      return (
        (Pt = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS)),
        (Pt = Sn(Pt, i)),
        i.getExtension('WEBGL_lose_context')?.loseContext(),
        Pt
      );
    }
    class Ec {
      constructor() {
        (this.ids = Object.create(null)), (this.textures = []), (this.count = 0);
      }
      clear() {
        for (let e = 0; e < this.count; e++) {
          const t = this.textures[e];
          (this.textures[e] = null), (this.ids[t.uid] = null);
        }
        this.count = 0;
      }
    }
    class Vc {
      constructor() {
        (this.renderPipeId = 'batch'),
          (this.action = 'startBatch'),
          (this.start = 0),
          (this.size = 0),
          (this.textures = new Ec()),
          (this.blendMode = 'normal'),
          (this.topology = 'triangle-strip'),
          (this.canBundle = !0);
      }
      destroy() {
        (this.textures = null), (this.gpuBindGroup = null), (this.bindGroup = null), (this.batcher = null);
      }
    }
    const UA = [];
    let wi = 0;
    kt.register({
      clear: () => {
        if (UA.length > 0) for (const i of UA) i && i.destroy();
        (UA.length = 0), (wi = 0);
      },
    });
    function rl() {
      return wi > 0 ? UA[--wi] : new Vc();
    }
    function sl(i) {
      UA[wi++] = i;
    }
    let MA = 0;
    const Tc = class Ic {
      constructor(e) {
        (this.uid = z('batcher')),
          (this.dirty = !0),
          (this.batchIndex = 0),
          (this.batches = []),
          (this._elements = []),
          (e = { ...Ic.defaultOptions, ...e }),
          e.maxTextures ||
          (P('v8.8.0', 'maxTextures is a required option for Batcher now, please pass it in the options'),
            (e.maxTextures = Mc()));
        const { maxTextures: t, attributesInitialSize: A, indicesInitialSize: r } = e;
        (this.attributeBuffer = new bt(A * 4)), (this.indexBuffer = new Uint16Array(r)), (this.maxTextures = t);
      }
      begin() {
        (this.elementSize = 0), (this.elementStart = 0), (this.indexSize = 0), (this.attributeSize = 0);
        for (let e = 0; e < this.batchIndex; e++) sl(this.batches[e]);
        (this.batchIndex = 0), (this._batchIndexStart = 0), (this._batchIndexSize = 0), (this.dirty = !0);
      }
      add(e) {
        (this._elements[this.elementSize++] = e),
          (e._indexStart = this.indexSize),
          (e._attributeStart = this.attributeSize),
          (e._batcher = this),
          (this.indexSize += e.indexSize),
          (this.attributeSize += e.attributeSize * this.vertexSize);
      }
      checkAndUpdateTexture(e, t) {
        const A = e._batch.textures.ids[t._source.uid];
        return !A && A !== 0 ? !1 : ((e._textureId = A), (e.texture = t), !0);
      }
      updateElement(e) {
        this.dirty = !0;
        const t = this.attributeBuffer;
        e.packAsQuad
          ? this.packQuadAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId)
          : this.packAttributes(e, t.float32View, t.uint32View, e._attributeStart, e._textureId);
      }
      break(e) {
        const t = this._elements;
        if (!t[this.elementStart]) return;
        let A = rl(),
          r = A.textures;
        r.clear();
        const s = t[this.elementStart];
        let n = eA(s.blendMode, s.texture._source),
          a = s.topology;
        this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4),
          this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
        const l = this.attributeBuffer.float32View,
          h = this.attributeBuffer.uint32View,
          u = this.indexBuffer;
        let o = this._batchIndexSize,
          c = this._batchIndexStart,
          d = 'startBatch';
        const f = this.maxTextures;
        for (let g = this.elementStart; g < this.elementSize; ++g) {
          const p = t[g];
          t[g] = null;
          const S = p.texture._source,
            q = eA(p.blendMode, S),
            E = n !== q || a !== p.topology;
          if (S._batchTick === MA && !E) {
            (p._textureId = S._textureBindLocation),
              (o += p.indexSize),
              p.packAsQuad
                ? (this.packQuadAttributes(p, l, h, p._attributeStart, p._textureId),
                  this.packQuadIndex(u, p._indexStart, p._attributeStart / this.vertexSize))
                : (this.packAttributes(p, l, h, p._attributeStart, p._textureId),
                  this.packIndex(p, u, p._indexStart, p._attributeStart / this.vertexSize)),
              (p._batch = A);
            continue;
          }
          (S._batchTick = MA),
            (r.count >= f || E) &&
            (this._finishBatch(A, c, o - c, r, n, a, e, d),
              (d = 'renderBatch'),
              (c = o),
              (n = q),
              (a = p.topology),
              (A = rl()),
              (r = A.textures),
              r.clear(),
              ++MA),
            (p._textureId = S._textureBindLocation = r.count),
            (r.ids[S.uid] = r.count),
            (r.textures[r.count++] = S),
            (p._batch = A),
            (o += p.indexSize),
            p.packAsQuad
              ? (this.packQuadAttributes(p, l, h, p._attributeStart, p._textureId),
                this.packQuadIndex(u, p._indexStart, p._attributeStart / this.vertexSize))
              : (this.packAttributes(p, l, h, p._attributeStart, p._textureId),
                this.packIndex(p, u, p._indexStart, p._attributeStart / this.vertexSize));
        }
        r.count > 0 && (this._finishBatch(A, c, o - c, r, n, a, e, d), (c = o), ++MA),
          (this.elementStart = this.elementSize),
          (this._batchIndexStart = c),
          (this._batchIndexSize = o);
      }
      _finishBatch(e, t, A, r, s, n, a, l) {
        (e.gpuBindGroup = null),
          (e.bindGroup = null),
          (e.action = l),
          (e.batcher = this),
          (e.textures = r),
          (e.blendMode = s),
          (e.topology = n),
          (e.start = t),
          (e.size = A),
          ++MA,
          (this.batches[this.batchIndex++] = e),
          a.add(e);
      }
      finish(e) {
        this.break(e);
      }
      ensureAttributeBuffer(e) {
        e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4);
      }
      ensureIndexBuffer(e) {
        e <= this.indexBuffer.length || this._resizeIndexBuffer(e);
      }
      _resizeAttributeBuffer(e) {
        const t = Math.max(e, this.attributeBuffer.size * 2),
          A = new bt(t);
        Qi(this.attributeBuffer.rawBinaryData, A.rawBinaryData), (this.attributeBuffer = A);
      }
      _resizeIndexBuffer(e) {
        const t = this.indexBuffer;
        let A = Math.max(e, t.length * 1.5);
        A += A % 2;
        const r = A > 65535 ? new Uint32Array(A) : new Uint16Array(A);
        if (r.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT) for (let s = 0; s < t.length; s++) r[s] = t[s];
        else Qi(t.buffer, r.buffer);
        this.indexBuffer = r;
      }
      packQuadIndex(e, t, A) {
        (e[t] = A + 0), (e[t + 1] = A + 1), (e[t + 2] = A + 2), (e[t + 3] = A + 0), (e[t + 4] = A + 2), (e[t + 5] = A + 3);
      }
      packIndex(e, t, A, r) {
        const s = e.indices,
          n = e.indexSize,
          a = e.indexOffset,
          l = e.attributeOffset;
        for (let h = 0; h < n; h++) t[A++] = r + s[h + a] - l;
      }
      destroy(e = {}) {
        if (this.batches !== null) {
          for (let t = 0; t < this.batches.length; t++) sl(this.batches[t]);
          (this.batches = null),
            this.geometry.destroy(!0),
            (this.geometry = null),
            e.shader && (this.shader?.destroy(), (this.shader = null));
          for (let t = 0; t < this._elements.length; t++) this._elements[t] && (this._elements[t]._batch = null);
          (this._elements = null), (this.indexBuffer = null), this.attributeBuffer.destroy(), (this.attributeBuffer = null);
        }
      }
    };
    Tc.defaultOptions = { maxTextures: null, attributesInitialSize: 4, indicesInitialSize: 6 };
    let bc = Tc;
    var K = ((i) => (
      (i[(i.MAP_READ = 1)] = 'MAP_READ'),
      (i[(i.MAP_WRITE = 2)] = 'MAP_WRITE'),
      (i[(i.COPY_SRC = 4)] = 'COPY_SRC'),
      (i[(i.COPY_DST = 8)] = 'COPY_DST'),
      (i[(i.INDEX = 16)] = 'INDEX'),
      (i[(i.VERTEX = 32)] = 'VERTEX'),
      (i[(i.UNIFORM = 64)] = 'UNIFORM'),
      (i[(i.STORAGE = 128)] = 'STORAGE'),
      (i[(i.INDIRECT = 256)] = 'INDIRECT'),
      (i[(i.QUERY_RESOLVE = 512)] = 'QUERY_RESOLVE'),
      (i[(i.STATIC = 1024)] = 'STATIC'),
      i
    ))(K || {});
    class be extends ye {
      constructor(e) {
        let { data: t, size: A } = e;
        const { usage: r, label: s, shrinkToFit: n } = e;
        super(),
          (this.uid = z('buffer')),
          (this._resourceType = 'buffer'),
          (this._resourceId = z('resource')),
          (this._touched = 0),
          (this._updateID = 1),
          (this._dataInt32 = null),
          (this.shrinkToFit = !0),
          (this.destroyed = !1),
          t instanceof Array && (t = new Float32Array(t)),
          (this._data = t),
          A ?? (A = t?.byteLength);
        const a = !!t;
        (this.descriptor = { size: A, usage: r, mappedAtCreation: a, label: s }), (this.shrinkToFit = n ?? !0);
      }
      get data() {
        return this._data;
      }
      set data(e) {
        this.setDataWithSize(e, e.length, !0);
      }
      get dataInt32() {
        return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
      }
      get static() {
        return !!(this.descriptor.usage & K.STATIC);
      }
      set static(e) {
        e ? (this.descriptor.usage |= K.STATIC) : (this.descriptor.usage &= ~K.STATIC);
      }
      setDataWithSize(e, t, A) {
        if ((this._updateID++, (this._updateSize = t * e.BYTES_PER_ELEMENT), this._data === e)) {
          A && this.emit('update', this);
          return;
        }
        const r = this._data;
        if (((this._data = e), (this._dataInt32 = null), !r || r.length !== e.length)) {
          !this.shrinkToFit && r && e.byteLength < r.byteLength
            ? A && this.emit('update', this)
            : ((this.descriptor.size = e.byteLength), (this._resourceId = z('resource')), this.emit('change', this));
          return;
        }
        A && this.emit('update', this);
      }
      update(e) {
        (this._updateSize = e ?? this._updateSize), this._updateID++, this.emit('update', this);
      }
      destroy() {
        (this.destroyed = !0),
          this.emit('destroy', this),
          this.emit('change', this),
          (this._data = null),
          (this.descriptor = null),
          this.removeAllListeners();
      }
    }
    function qn(i, e) {
      if (!(i instanceof be)) {
        let t = e ? K.INDEX : K.VERTEX;
        i instanceof Array &&
          (e
            ? ((i = new Uint32Array(i)), (t = K.INDEX | K.COPY_DST))
            : ((i = new Float32Array(i)), (t = K.VERTEX | K.COPY_DST))),
          (i = new be({ data: i, label: e ? 'index-mesh-buffer' : 'vertex-mesh-buffer', usage: t }));
      }
      return i;
    }
    function yc(i, e, t) {
      const A = i.getAttribute(e);
      if (!A) return (t.minX = 0), (t.minY = 0), (t.maxX = 0), (t.maxY = 0), t;
      const r = A.buffer.data;
      let s = 1 / 0,
        n = 1 / 0,
        a = -1 / 0,
        l = -1 / 0;
      const h = r.BYTES_PER_ELEMENT,
        u = (A.offset || 0) / h,
        o = (A.stride || 8) / h;
      for (let c = u; c < r.length; c += o) {
        const d = r[c],
          f = r[c + 1];
        d > a && (a = d), f > l && (l = f), d < s && (s = d), f < n && (n = f);
      }
      return (t.minX = s), (t.minY = n), (t.maxX = a), (t.maxY = l), t;
    }
    function Gg(i) {
      return (
        (i instanceof be || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = { buffer: i }), (i.buffer = qn(i.buffer, !1)), i
      );
    }
    class Bt extends ye {
      constructor(e = {}) {
        super(),
          (this.uid = z('geometry')),
          (this._layoutKey = 0),
          (this.instanceCount = 1),
          (this._bounds = new de()),
          (this._boundsDirty = !0);
        const { attributes: t, indexBuffer: A, topology: r } = e;
        if (((this.buffers = []), (this.attributes = {}), t)) for (const s in t) this.addAttribute(s, t[s]);
        (this.instanceCount = e.instanceCount ?? 1), A && this.addIndex(A), (this.topology = r || 'triangle-list');
      }
      onBufferUpdate() {
        (this._boundsDirty = !0), this.emit('update', this);
      }
      getAttribute(e) {
        return this.attributes[e];
      }
      getIndex() {
        return this.indexBuffer;
      }
      getBuffer(e) {
        return this.getAttribute(e).buffer;
      }
      getSize() {
        for (const e in this.attributes) {
          const t = this.attributes[e];
          return t.buffer.data.length / (t.stride / 4 || t.size);
        }
        return 0;
      }
      addAttribute(e, t) {
        const A = Gg(t);
        this.buffers.indexOf(A.buffer) === -1 &&
          (this.buffers.push(A.buffer),
            A.buffer.on('update', this.onBufferUpdate, this),
            A.buffer.on('change', this.onBufferUpdate, this)),
          (this.attributes[e] = A);
      }
      addIndex(e) {
        (this.indexBuffer = qn(e, !0)), this.buffers.push(this.indexBuffer);
      }
      get bounds() {
        return this._boundsDirty ? ((this._boundsDirty = !1), yc(this, 'aPosition', this._bounds)) : this._bounds;
      }
      destroy(e = !1) {
        this.emit('destroy', this),
          this.removeAllListeners(),
          e && this.buffers.forEach((t) => t.destroy()),
          this.indexBuffer?.destroy(),
          (this.attributes = null),
          (this.buffers = null),
          (this.indexBuffer = null),
          (this._bounds = null);
      }
    }
    const Wg = new Float32Array(1),
      Kg = new Uint32Array(1);
    class xc extends Bt {
      constructor() {
        const t = new be({ data: Wg, label: 'attribute-batch-buffer', usage: K.VERTEX | K.COPY_DST, shrinkToFit: !1 }),
          A = new be({ data: Kg, label: 'index-batch-buffer', usage: K.INDEX | K.COPY_DST, shrinkToFit: !1 }),
          r = 24;
        super({
          attributes: {
            aPosition: { buffer: t, format: 'float32x2', stride: r, offset: 0 },
            aUV: { buffer: t, format: 'float32x2', stride: r, offset: 8 },
            aColor: { buffer: t, format: 'unorm8x4', stride: r, offset: 16 },
            aTextureIdAndRound: { buffer: t, format: 'uint16x2', stride: r, offset: 20 },
          },
          indexBuffer: A,
        });
      }
    }
    function gs(i, e, t) {
      if (i)
        for (const A in i) {
          const r = A.toLocaleLowerCase(),
            s = e[r];
          if (s) {
            let n = i[A];
            A === 'header' && (n = n.replace(/@in\s+[^;]+;\s*/g, '').replace(/@out\s+[^;]+;\s*/g, '')),
              t && s.push(`//----${t}----//`),
              s.push(n);
          } else N(`${A} placement hook does not exist in shader`);
        }
    }
    const Fg = /\{\{(.*?)\}\}/g;
    function ms(i) {
      const e = {};
      return (
        (i.match(Fg)?.map((A) => A.replace(/[{()}]/g, '')) ?? []).forEach((A) => {
          e[A] = [];
        }),
        e
      );
    }
    function nl(i, e) {
      let t;
      const A = /@in\s+([^;]+);/g;
      for (; (t = A.exec(i)) !== null;) e.push(t[1]);
    }
    function Ss(i, e, t = !1) {
      const A = [];
      nl(e, A),
        i.forEach((a) => {
          a.header && nl(a.header, A);
        });
      const r = A;
      t && r.sort();
      const s = r.map((a, l) => `       @location(${l}) ${a},`).join(`
`);
      let n = e.replace(/@in\s+[^;]+;\s*/g, '');
      return (
        (n = n.replace(
          '{{in}}',
          `
${s}
`
        )),
        n
      );
    }
    function al(i, e) {
      let t;
      const A = /@out\s+([^;]+);/g;
      for (; (t = A.exec(i)) !== null;) e.push(t[1]);
    }
    function Yg(i) {
      const t = /\b(\w+)\s*:/g.exec(i);
      return t ? t[1] : '';
    }
    function Dg(i) {
      const e = /@.*?\s+/g;
      return i.replace(e, '');
    }
    function vc(i, e) {
      const t = [];
      al(e, t),
        i.forEach((l) => {
          l.header && al(l.header, t);
        });
      let A = 0;
      const r = t.sort().map((l) => (l.indexOf('builtin') > -1 ? l : `@location(${A++}) ${l}`)).join(`,
`),
        s = t.sort().map((l) => `       var ${Dg(l)};`).join(`
`),
        n = `return VSOutput(
            ${t.sort().map((l) => ` ${Yg(l)}`).join(`,
`)});`;
      let a = e.replace(/@out\s+[^;]+;\s*/g, '');
      return (
        (a = a.replace(
          '{{struct}}',
          `
${r}
`
        )),
        (a = a.replace(
          '{{start}}',
          `
${s}
`
        )),
        (a = a.replace(
          '{{return}}',
          `
${n}
`
        )),
        a
      );
    }
    function qs(i, e) {
      let t = i;
      for (const A in e) {
        const r = e[A];
        r.join(`
`).length
          ? (t = t.replace(
            `{{${A}}}`,
            `//-----${A} START-----//
${r.join(`
`)}
//----${A} FINISH----//`
          ))
          : (t = t.replace(`{{${A}}}`, ''));
      }
      return t;
    }
    const ot = Object.create(null),
      Wr = new Map();
    let Og = 0;
    function Cc({ template: i, bits: e }) {
      const t = kc(i, e);
      if (ot[t]) return ot[t];
      const { vertex: A, fragment: r } = Lg(i, e);
      return (ot[t] = Rc(A, r, e)), ot[t];
    }
    function Uc({ template: i, bits: e }) {
      const t = kc(i, e);
      return ot[t] || (ot[t] = Rc(i.vertex, i.fragment, e)), ot[t];
    }
    function Lg(i, e) {
      const t = e.map((n) => n.vertex).filter((n) => !!n),
        A = e.map((n) => n.fragment).filter((n) => !!n);
      let r = Ss(t, i.vertex, !0);
      r = vc(t, r);
      const s = Ss(A, i.fragment, !0);
      return { vertex: r, fragment: s };
    }
    function kc(i, e) {
      return (
        e
          .map((t) => (Wr.has(t) || Wr.set(t, Og++), Wr.get(t)))
          .sort((t, A) => t - A)
          .join('-') +
        i.vertex +
        i.fragment
      );
    }
    function Rc(i, e, t) {
      const A = ms(i),
        r = ms(e);
      return (
        t.forEach((s) => {
          gs(s.vertex, A, s.name), gs(s.fragment, r, s.name);
        }),
        { vertex: qs(i, A), fragment: qs(e, r) }
      );
    }
    const Bc = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,
      Nc = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`,
      Qc = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,
      wc = `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`,
      Pc = {
        name: 'global-uniforms-bit',
        vertex: {
          header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `,
        },
      },
      Jc = {
        name: 'global-uniforms-bit',
        vertex: {
          header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `,
        },
      };
    function rA({ bits: i, name: e }) {
      const t = Cc({ template: { fragment: Nc, vertex: Bc }, bits: [Pc, ...i] });
      return it.from({
        name: e,
        vertex: { source: t.vertex, entryPoint: 'main' },
        fragment: { source: t.fragment, entryPoint: 'main' },
      });
    }
    function sA({ bits: i, name: e }) {
      return new dt({ name: e, ...Uc({ template: { vertex: Qc, fragment: wc }, bits: [Jc, ...i] }) });
    }
    const er = {
      name: 'color-bit',
      vertex: {
        header: `
            @in aColor: vec4<f32>;
        `,
        main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `,
      },
    },
      tr = {
        name: 'color-bit',
        vertex: {
          header: `
            in vec4 aColor;
        `,
          main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `,
        },
      },
      Kr = {};
    function jg(i) {
      const e = [];
      if (i === 1)
        e.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;'),
          e.push('@group(1) @binding(1) var textureSampler1: sampler;');
      else {
        let t = 0;
        for (let A = 0; A < i; A++)
          e.push(`@group(1) @binding(${t++}) var textureSource${A + 1}: texture_2d<f32>;`),
            e.push(`@group(1) @binding(${t++}) var textureSampler${A + 1}: sampler;`);
      }
      return e.join(`
`);
    }
    function Zg(i) {
      const e = [];
      if (i === 1) e.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');
      else {
        e.push('switch vTextureId {');
        for (let t = 0; t < i; t++)
          t === i - 1 ? e.push('  default:{') : e.push(`  case ${t}:{`),
            e.push(`      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`),
            e.push('      break;}');
        e.push('}');
      }
      return e.join(`
`);
    }
    function Ar(i) {
      return (
        Kr[i] ||
        (Kr[i] = {
          name: 'texture-batch-bit',
          vertex: {
            header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `,
          },
          fragment: {
            header: `
                @in @interpolate(flat) vTextureId: u32;

                ${jg(i)}
            `,
            main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${Zg(i)}
            `,
          },
        }),
        Kr[i]
      );
    }
    const Fr = {};
    function Xg(i) {
      const e = [];
      for (let t = 0; t < i; t++)
        t > 0 && e.push('else'),
          t < i - 1 && e.push(`if(vTextureId < ${t}.5)`),
          e.push('{'),
          e.push(`	outColor = texture(uTextures[${t}], vUV);`),
          e.push('}');
      return e.join(`
`);
    }
    function ir(i) {
      return (
        Fr[i] ||
        (Fr[i] = {
          name: 'texture-batch-bit',
          vertex: {
            header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `,
          },
          fragment: {
            header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
            main: `

                ${Xg(i)}
            `,
          },
        }),
        Fr[i]
      );
    }
    const nA = {
      name: 'round-pixels-bit',
      vertex: {
        header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
      },
    },
      aA = {
        name: 'round-pixels-bit',
        vertex: {
          header: `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
        },
      },
      ol = {};
    function rr(i) {
      let e = ol[i];
      if (e) return e;
      const t = new Int32Array(i);
      for (let A = 0; A < i; A++) t[A] = A;
      return (e = ol[i] = new qe({ uTextures: { value: t, type: 'i32', size: i } }, { isStatic: !0 })), e;
    }
    class Ms extends ke {
      constructor(e) {
        const t = sA({ name: 'batch', bits: [tr, ir(e), aA] }),
          A = rA({ name: 'batch', bits: [er, Ar(e), nA] });
        super({ glProgram: t, gpuProgram: A, resources: { batchSamplers: rr(e) } }), (this.maxTextures = e);
      }
    }
    let EA = null;
    const Gc = class Wc extends bc {
      constructor(e) {
        super(e),
          (this.geometry = new xc()),
          (this.name = Wc.extension.name),
          (this.vertexSize = 6),
          EA ?? (EA = new Ms(e.maxTextures)),
          (this.shader = EA);
      }
      packAttributes(e, t, A, r, s) {
        const n = (s << 16) | (e.roundPixels & 65535),
          a = e.transform,
          l = a.a,
          h = a.b,
          u = a.c,
          o = a.d,
          c = a.tx,
          d = a.ty,
          { positions: f, uvs: g } = e,
          p = e.color,
          m = e.attributeOffset,
          S = m + e.attributeSize;
        for (let q = m; q < S; q++) {
          const E = q * 2,
            b = f[E],
            T = f[E + 1];
          (t[r++] = l * b + u * T + c),
            (t[r++] = o * T + h * b + d),
            (t[r++] = g[E]),
            (t[r++] = g[E + 1]),
            (A[r++] = p),
            (A[r++] = n);
        }
      }
      packQuadAttributes(e, t, A, r, s) {
        const n = e.texture,
          a = e.transform,
          l = a.a,
          h = a.b,
          u = a.c,
          o = a.d,
          c = a.tx,
          d = a.ty,
          f = e.bounds,
          g = f.maxX,
          p = f.minX,
          m = f.maxY,
          S = f.minY,
          q = n.uvs,
          E = e.color,
          b = (s << 16) | (e.roundPixels & 65535);
        (t[r + 0] = l * p + u * S + c),
          (t[r + 1] = o * S + h * p + d),
          (t[r + 2] = q.x0),
          (t[r + 3] = q.y0),
          (A[r + 4] = E),
          (A[r + 5] = b),
          (t[r + 6] = l * g + u * S + c),
          (t[r + 7] = o * S + h * g + d),
          (t[r + 8] = q.x1),
          (t[r + 9] = q.y1),
          (A[r + 10] = E),
          (A[r + 11] = b),
          (t[r + 12] = l * g + u * m + c),
          (t[r + 13] = o * m + h * g + d),
          (t[r + 14] = q.x2),
          (t[r + 15] = q.y2),
          (A[r + 16] = E),
          (A[r + 17] = b),
          (t[r + 18] = l * p + u * m + c),
          (t[r + 19] = o * m + h * p + d),
          (t[r + 20] = q.x3),
          (t[r + 21] = q.y3),
          (A[r + 22] = E),
          (A[r + 23] = b);
      }
      _updateMaxTextures(e) {
        this.shader.maxTextures !== e && ((EA = new Ms(e)), (this.shader = EA));
      }
      destroy() {
        (this.shader = null), super.destroy();
      }
    };
    Gc.extension = { type: [M.Batcher], name: 'default' };
    let sr = Gc;
    function Kc(i, e, t, A, r, s, n, a = null) {
      let l = 0;
      (t *= e), (r *= s);
      const h = a.a,
        u = a.b,
        o = a.c,
        c = a.d,
        d = a.tx,
        f = a.ty;
      for (; l < n;) {
        const g = i[t],
          p = i[t + 1];
        (A[r] = h * g + o * p + d), (A[r + 1] = u * g + c * p + f), (r += s), (t += e), l++;
      }
    }
    function Fc(i, e, t, A) {
      let r = 0;
      for (e *= t; r < A;) (i[e] = 0), (i[e + 1] = 0), (e += t), r++;
    }
    function Mn(i, e, t, A, r) {
      const s = e.a,
        n = e.b,
        a = e.c,
        l = e.d,
        h = e.tx,
        u = e.ty;
      t || (t = 0), A || (A = 2), r || (r = i.length / A - t);
      let o = t * A;
      for (let c = 0; c < r; c++) {
        const d = i[o],
          f = i[o + 1];
        (i[o] = s * d + a * f + h), (i[o + 1] = n * d + l * f + u), (o += A);
      }
    }
    const Hg = new R();
    class nr {
      constructor() {
        (this.packAsQuad = !1),
          (this.batcherName = 'default'),
          (this.topology = 'triangle-list'),
          (this.applyTransform = !0),
          (this.roundPixels = 0),
          (this._batcher = null),
          (this._batch = null);
      }
      get uvs() {
        return this.geometryData.uvs;
      }
      get positions() {
        return this.geometryData.vertices;
      }
      get indices() {
        return this.geometryData.indices;
      }
      get blendMode() {
        return this.renderable && this.applyTransform ? this.renderable.groupBlendMode : 'normal';
      }
      get color() {
        const e = this.baseColor,
          t = (e >> 16) | (e & 65280) | ((e & 255) << 16),
          A = this.renderable;
        return A ? Zs(t, A.groupColor) + ((this.alpha * A.groupAlpha * 255) << 24) : t + ((this.alpha * 255) << 24);
      }
      get transform() {
        return this.renderable?.groupTransform || Hg;
      }
      copyTo(e) {
        (e.indexOffset = this.indexOffset),
          (e.indexSize = this.indexSize),
          (e.attributeOffset = this.attributeOffset),
          (e.attributeSize = this.attributeSize),
          (e.baseColor = this.baseColor),
          (e.alpha = this.alpha),
          (e.texture = this.texture),
          (e.geometryData = this.geometryData),
          (e.topology = this.topology);
      }
      reset() {
        (this.applyTransform = !0), (this.renderable = null), (this.topology = 'triangle-list');
      }
      destroy() {
        (this.renderable = null),
          (this.texture = null),
          (this.geometryData = null),
          (this._batcher = null),
          (this._batch = null);
      }
    }
    const tA = {
      extension: { type: M.ShapeBuilder, name: 'circle' },
      build(i, e) {
        let t, A, r, s, n, a;
        if (i.type === 'circle') {
          const E = i;
          if (((n = a = E.radius), n <= 0)) return !1;
          (t = E.x), (A = E.y), (r = s = 0);
        } else if (i.type === 'ellipse') {
          const E = i;
          if (((n = E.halfWidth), (a = E.halfHeight), n <= 0 || a <= 0)) return !1;
          (t = E.x), (A = E.y), (r = s = 0);
        } else {
          const E = i,
            b = E.width / 2,
            T = E.height / 2;
          (t = E.x + b), (A = E.y + T), (n = a = Math.max(0, Math.min(E.radius, Math.min(b, T)))), (r = b - n), (s = T - a);
        }
        if (r < 0 || s < 0) return !1;
        const l = Math.ceil(2.3 * Math.sqrt(n + a)),
          h = l * 8 + (r ? 4 : 0) + (s ? 4 : 0);
        if (h === 0) return !1;
        if (l === 0) return (e[0] = e[6] = t + r), (e[1] = e[3] = A + s), (e[2] = e[4] = t - r), (e[5] = e[7] = A - s), !0;
        let u = 0,
          o = l * 4 + (r ? 2 : 0) + 2,
          c = o,
          d = h,
          f = r + n,
          g = s,
          p = t + f,
          m = t - f,
          S = A + g;
        if (((e[u++] = p), (e[u++] = S), (e[--o] = S), (e[--o] = m), s)) {
          const E = A - g;
          (e[c++] = m), (e[c++] = E), (e[--d] = E), (e[--d] = p);
        }
        for (let E = 1; E < l; E++) {
          const b = (Math.PI / 2) * (E / l),
            T = r + Math.cos(b) * n,
            I = s + Math.sin(b) * a,
            B = t + T,
            y = t - T,
            x = A + I,
            C = A - I;
          (e[u++] = B), (e[u++] = x), (e[--o] = x), (e[--o] = y), (e[c++] = y), (e[c++] = C), (e[--d] = C), (e[--d] = B);
        }
        (f = r), (g = s + a), (p = t + f), (m = t - f), (S = A + g);
        const q = A - g;
        return (
          (e[u++] = p),
          (e[u++] = S),
          (e[--d] = q),
          (e[--d] = p),
          r && ((e[u++] = m), (e[u++] = S), (e[--d] = q), (e[--d] = m)),
          !0
        );
      },
      triangulate(i, e, t, A, r, s) {
        if (i.length === 0) return;
        let n = 0,
          a = 0;
        for (let u = 0; u < i.length; u += 2) (n += i[u]), (a += i[u + 1]);
        (n /= i.length / 2), (a /= i.length / 2);
        let l = A;
        (e[l * t] = n), (e[l * t + 1] = a);
        const h = l++;
        for (let u = 0; u < i.length; u += 2)
          (e[l * t] = i[u]), (e[l * t + 1] = i[u + 1]), u > 0 && ((r[s++] = l), (r[s++] = h), (r[s++] = l - 1)), l++;
        (r[s++] = h + 1), (r[s++] = h), (r[s++] = l - 1);
      },
    },
      Yc = { ...tA, extension: { ...tA.extension, name: 'ellipse' } },
      Dc = { ...tA, extension: { ...tA.extension, name: 'roundedRectangle' } },
      En = 1e-4,
      Es = 1e-4;
    function Oc(i) {
      const e = i.length;
      if (e < 6) return 1;
      let t = 0;
      for (let A = 0, r = i[e - 2], s = i[e - 1]; A < e; A += 2) {
        const n = i[A],
          a = i[A + 1];
        (t += (n - r) * (a + s)), (r = n), (s = a);
      }
      return t < 0 ? -1 : 1;
    }
    function ll(i, e, t, A, r, s, n, a) {
      const l = i - t * r,
        h = e - A * r,
        u = i + t * s,
        o = e + A * s;
      let c, d;
      n ? ((c = A), (d = -t)) : ((c = -A), (d = t));
      const f = l + c,
        g = h + d,
        p = u + c,
        m = o + d;
      return a.push(f, g), a.push(p, m), 2;
    }
    function St(i, e, t, A, r, s, n, a) {
      const l = t - i,
        h = A - e;
      let u = Math.atan2(l, h),
        o = Math.atan2(r - i, s - e);
      a && u < o ? (u += Math.PI * 2) : !a && u > o && (o += Math.PI * 2);
      let c = u;
      const d = o - u,
        f = Math.abs(d),
        g = Math.sqrt(l * l + h * h),
        p = (((15 * f * Math.sqrt(g)) / Math.PI) >> 0) + 1,
        m = d / p;
      if (((c += m), a)) {
        n.push(i, e), n.push(t, A);
        for (let S = 1, q = c; S < p; S++, q += m) n.push(i, e), n.push(i + Math.sin(q) * g, e + Math.cos(q) * g);
        n.push(i, e), n.push(r, s);
      } else {
        n.push(t, A), n.push(i, e);
        for (let S = 1, q = c; S < p; S++, q += m) n.push(i + Math.sin(q) * g, e + Math.cos(q) * g), n.push(i, e);
        n.push(r, s), n.push(i, e);
      }
      return p * 2;
    }
    function Lc(i, e, t, A, r, s) {
      const n = En;
      if (i.length === 0) return;
      const a = e;
      let l = a.alignment;
      if (e.alignment !== 0.5) {
        let D = Oc(i);
        l = (l - 0.5) * D + 0.5;
      }
      const h = new H(i[0], i[1]),
        u = new H(i[i.length - 2], i[i.length - 1]),
        o = A,
        c = Math.abs(h.x - u.x) < n && Math.abs(h.y - u.y) < n;
      if (o) {
        (i = i.slice()), c && (i.pop(), i.pop(), u.set(i[i.length - 2], i[i.length - 1]));
        const D = (h.x + u.x) * 0.5,
          nt = (u.y + h.y) * 0.5;
        i.unshift(D, nt), i.push(D, nt);
      }
      const d = r,
        f = i.length / 2;
      let g = i.length;
      const p = d.length / 2,
        m = a.width / 2,
        S = m * m,
        q = a.miterLimit * a.miterLimit;
      let E = i[0],
        b = i[1],
        T = i[2],
        I = i[3],
        B = 0,
        y = 0,
        x = -(b - I),
        C = E - T,
        X = 0,
        L = 0,
        O = Math.sqrt(x * x + C * C);
      (x /= O), (C /= O), (x *= m), (C *= m);
      const st = l,
        U = (1 - st) * 2,
        w = st * 2;
      o ||
        (a.cap === 'round'
          ? (g += St(E - x * (U - w) * 0.5, b - C * (U - w) * 0.5, E - x * U, b - C * U, E + x * w, b + C * w, d, !0) + 2)
          : a.cap === 'square' && (g += ll(E, b, x, C, U, w, !0, d))),
        d.push(E - x * U, b - C * U),
        d.push(E + x * w, b + C * w);
      for (let D = 1; D < f - 1; ++D) {
        (E = i[(D - 1) * 2]),
          (b = i[(D - 1) * 2 + 1]),
          (T = i[D * 2]),
          (I = i[D * 2 + 1]),
          (B = i[(D + 1) * 2]),
          (y = i[(D + 1) * 2 + 1]),
          (x = -(b - I)),
          (C = E - T),
          (O = Math.sqrt(x * x + C * C)),
          (x /= O),
          (C /= O),
          (x *= m),
          (C *= m),
          (X = -(I - y)),
          (L = T - B),
          (O = Math.sqrt(X * X + L * L)),
          (X /= O),
          (L /= O),
          (X *= m),
          (L *= m);
        const nt = T - E,
          cA = b - I,
          uA = T - B,
          dA = y - I,
          uo = nt * uA + cA * dA,
          Ai = cA * uA - dA * nt,
          fA = Ai < 0;
        if (Math.abs(Ai) < 0.001 * Math.abs(uo)) {
          d.push(T - x * U, I - C * U),
            d.push(T + x * w, I + C * w),
            uo >= 0 &&
            (a.join === 'round' ? (g += St(T, I, T - x * U, I - C * U, T - X * U, I - L * U, d, !1) + 4) : (g += 2),
              d.push(T - X * w, I - L * w),
              d.push(T + X * U, I + L * U));
          continue;
        }
        const fo = (-x + E) * (-C + I) - (-x + T) * (-C + b),
          po = (-X + B) * (-L + I) - (-X + T) * (-L + y),
          ii = (nt * po - uA * fo) / Ai,
          ri = (dA * fo - cA * po) / Ai,
          mr = (ii - T) * (ii - T) + (ri - I) * (ri - I),
          ft = T + (ii - T) * U,
          pt = I + (ri - I) * U,
          gt = T - (ii - T) * w,
          mt = I - (ri - I) * w,
          Vp = Math.min(nt * nt + cA * cA, uA * uA + dA * dA),
          go = fA ? U : w,
          Tp = Vp + go * go * S;
        mr <= Tp
          ? a.join === 'bevel' || mr / S > q
            ? (fA
              ? (d.push(ft, pt), d.push(T + x * w, I + C * w), d.push(ft, pt), d.push(T + X * w, I + L * w))
              : (d.push(T - x * U, I - C * U), d.push(gt, mt), d.push(T - X * U, I - L * U), d.push(gt, mt)),
              (g += 2))
            : a.join === 'round'
              ? fA
                ? (d.push(ft, pt),
                  d.push(T + x * w, I + C * w),
                  (g += St(T, I, T + x * w, I + C * w, T + X * w, I + L * w, d, !0) + 4),
                  d.push(ft, pt),
                  d.push(T + X * w, I + L * w))
                : (d.push(T - x * U, I - C * U),
                  d.push(gt, mt),
                  (g += St(T, I, T - x * U, I - C * U, T - X * U, I - L * U, d, !1) + 4),
                  d.push(T - X * U, I - L * U),
                  d.push(gt, mt))
              : (d.push(ft, pt), d.push(gt, mt))
          : (d.push(T - x * U, I - C * U),
            d.push(T + x * w, I + C * w),
            a.join === 'round'
              ? fA
                ? (g += St(T, I, T + x * w, I + C * w, T + X * w, I + L * w, d, !0) + 2)
                : (g += St(T, I, T - x * U, I - C * U, T - X * U, I - L * U, d, !1) + 2)
              : a.join === 'miter' &&
              mr / S <= q &&
              (fA ? (d.push(gt, mt), d.push(gt, mt)) : (d.push(ft, pt), d.push(ft, pt)), (g += 2)),
            d.push(T - X * U, I - L * U),
            d.push(T + X * w, I + L * w),
            (g += 2));
      }
      (E = i[(f - 2) * 2]),
        (b = i[(f - 2) * 2 + 1]),
        (T = i[(f - 1) * 2]),
        (I = i[(f - 1) * 2 + 1]),
        (x = -(b - I)),
        (C = E - T),
        (O = Math.sqrt(x * x + C * C)),
        (x /= O),
        (C /= O),
        (x *= m),
        (C *= m),
        d.push(T - x * U, I - C * U),
        d.push(T + x * w, I + C * w),
        o ||
        (a.cap === 'round'
          ? (g += St(T - x * (U - w) * 0.5, I - C * (U - w) * 0.5, T - x * U, I - C * U, T + x * w, I + C * w, d, !1) + 2)
          : a.cap === 'square' && (g += ll(T, I, x, C, U, w, !1, d)));
      const hA = Es * Es;
      for (let D = p; D < g + p - 2; ++D)
        (E = d[D * 2]),
          (b = d[D * 2 + 1]),
          (T = d[(D + 1) * 2]),
          (I = d[(D + 1) * 2 + 1]),
          (B = d[(D + 2) * 2]),
          (y = d[(D + 2) * 2 + 1]),
          !(Math.abs(E * (I - y) + T * (y - b) + B * (b - I)) < hA) && s.push(D, D + 1, D + 2);
    }
    function jc(i, e, t, A) {
      const r = En;
      if (i.length === 0) return;
      const s = i[0],
        n = i[1],
        a = i[i.length - 2],
        l = i[i.length - 1],
        h = e || (Math.abs(s - a) < r && Math.abs(n - l) < r),
        u = t,
        o = i.length / 2,
        c = u.length / 2;
      for (let d = 0; d < o; d++) u.push(i[d * 2]), u.push(i[d * 2 + 1]);
      for (let d = 0; d < o - 1; d++) A.push(c + d, c + d + 1);
      h && A.push(c + o - 1, c);
    }
    function Vn(i, e, t, A, r, s, n) {
      const a = oc(i, e, 2);
      if (!a) return;
      for (let h = 0; h < a.length; h += 3) (s[n++] = a[h] + r), (s[n++] = a[h + 1] + r), (s[n++] = a[h + 2] + r);
      let l = r * A;
      for (let h = 0; h < i.length; h += 2) (t[l] = i[h]), (t[l + 1] = i[h + 1]), (l += A);
    }
    const zg = [],
      Zc = {
        extension: { type: M.ShapeBuilder, name: 'polygon' },
        build(i, e) {
          for (let t = 0; t < i.points.length; t++) e[t] = i.points[t];
          return !0;
        },
        triangulate(i, e, t, A, r, s) {
          Vn(i, zg, e, t, A, r, s);
        },
      },
      Xc = {
        extension: { type: M.ShapeBuilder, name: 'rectangle' },
        build(i, e) {
          const t = i,
            A = t.x,
            r = t.y,
            s = t.width,
            n = t.height;
          return s > 0 && n > 0
            ? ((e[0] = A),
              (e[1] = r),
              (e[2] = A + s),
              (e[3] = r),
              (e[4] = A + s),
              (e[5] = r + n),
              (e[6] = A),
              (e[7] = r + n),
              !0)
            : !1;
        },
        triangulate(i, e, t, A, r, s) {
          let n = 0;
          (A *= t),
            (e[A + n] = i[0]),
            (e[A + n + 1] = i[1]),
            (n += t),
            (e[A + n] = i[2]),
            (e[A + n + 1] = i[3]),
            (n += t),
            (e[A + n] = i[6]),
            (e[A + n + 1] = i[7]),
            (n += t),
            (e[A + n] = i[4]),
            (e[A + n + 1] = i[5]),
            (n += t);
          const a = A / t;
          (r[s++] = a), (r[s++] = a + 1), (r[s++] = a + 2), (r[s++] = a + 1), (r[s++] = a + 3), (r[s++] = a + 2);
        },
      },
      Hc = {
        extension: { type: M.ShapeBuilder, name: 'triangle' },
        build(i, e) {
          return (e[0] = i.x), (e[1] = i.y), (e[2] = i.x2), (e[3] = i.y2), (e[4] = i.x3), (e[5] = i.y3), !0;
        },
        triangulate(i, e, t, A, r, s) {
          let n = 0;
          (A *= t),
            (e[A + n] = i[0]),
            (e[A + n + 1] = i[1]),
            (n += t),
            (e[A + n] = i[2]),
            (e[A + n + 1] = i[3]),
            (n += t),
            (e[A + n] = i[4]),
            (e[A + n + 1] = i[5]);
          const a = A / t;
          (r[s++] = a), (r[s++] = a + 1), (r[s++] = a + 2);
        },
      },
      _g = new R(),
      $g = new F();
    function zc(i, e, t, A) {
      const r = e.matrix ? i.copyFrom(e.matrix).invert() : i.identity();
      if (e.textureSpace === 'local') {
        const n = t.getBounds($g);
        e.width && n.pad(e.width);
        const { x: a, y: l } = n,
          h = 1 / n.width,
          u = 1 / n.height,
          o = -a * h,
          c = -l * u,
          d = r.a,
          f = r.b,
          g = r.c,
          p = r.d;
        (r.a *= h), (r.b *= h), (r.c *= u), (r.d *= u), (r.tx = o * d + c * g + r.tx), (r.ty = o * f + c * p + r.ty);
      } else
        r.translate(e.texture.frame.x, e.texture.frame.y), r.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
      const s = e.texture.source.style;
      return (
        !(e.fill instanceof Ze) && s.addressMode === 'clamp-to-edge' && ((s.addressMode = 'repeat'), s.update()),
        A && r.append(_g.copyFrom(A).invert()),
        r
      );
    }
    const $A = {};
    Q.handleByMap(M.ShapeBuilder, $A);
    Q.add(Xc, Zc, Hc, tA, Yc, Dc);
    const em = new F(),
      tm = new R();
    function _c(i, e) {
      const { geometryData: t, batches: A } = e;
      (A.length = 0), (t.indices.length = 0), (t.vertices.length = 0), (t.uvs.length = 0);
      for (let r = 0; r < i.instructions.length; r++) {
        const s = i.instructions[r];
        if (s.action === 'texture') Am(s.data, A, t);
        else if (s.action === 'fill' || s.action === 'stroke') {
          const n = s.action === 'stroke',
            a = s.data.path.shapePath,
            l = s.data.style,
            h = s.data.hole;
          n && h && hl(h.shapePath, l, !0, A, t),
            h && (a.shapePrimitives[a.shapePrimitives.length - 1].holes = h.shapePath.shapePrimitives),
            hl(a, l, n, A, t);
        }
      }
    }
    function Am(i, e, t) {
      const A = [],
        r = $A.rectangle,
        s = em;
      (s.x = i.dx), (s.y = i.dy), (s.width = i.dw), (s.height = i.dh);
      const n = i.transform;
      if (!r.build(s, A)) return;
      const { vertices: a, uvs: l, indices: h } = t,
        u = h.length,
        o = a.length / 2;
      n && Mn(A, n), r.triangulate(A, a, 2, o, h, u);
      const c = i.image,
        d = c.uvs;
      l.push(d.x0, d.y0, d.x1, d.y1, d.x3, d.y3, d.x2, d.y2);
      const f = se.get(nr);
      (f.indexOffset = u),
        (f.indexSize = h.length - u),
        (f.attributeOffset = o),
        (f.attributeSize = a.length / 2 - o),
        (f.baseColor = i.style),
        (f.alpha = i.alpha),
        (f.texture = c),
        (f.geometryData = t),
        e.push(f);
    }
    function hl(i, e, t, A, r) {
      const { vertices: s, uvs: n, indices: a } = r;
      i.shapePrimitives.forEach(({ shape: l, transform: h, holes: u }) => {
        const o = [],
          c = $A[l.type];
        if (!c.build(l, o)) return;
        const d = a.length,
          f = s.length / 2;
        let g = 'triangle-list';
        if ((h && Mn(o, h), t)) {
          const q = l.closePath ?? !0,
            E = e;
          E.pixelLine ? (jc(o, q, s, a), (g = 'line-list')) : Lc(o, E, !1, q, s, a);
        } else if (u) {
          const q = [],
            E = o.slice();
          im(u).forEach((T) => {
            q.push(E.length / 2), E.push(...T);
          }),
            Vn(E, q, s, 2, f, a, d);
        } else c.triangulate(o, s, 2, f, a, d);
        const p = n.length / 2,
          m = e.texture;
        if (m !== v.WHITE) {
          const q = zc(tm, e, l, h);
          Kc(s, 2, f, n, p, 2, s.length / 2 - f, q);
        } else Fc(n, p, 2, s.length / 2 - f);
        const S = se.get(nr);
        (S.indexOffset = d),
          (S.indexSize = a.length - d),
          (S.attributeOffset = f),
          (S.attributeSize = s.length / 2 - f),
          (S.baseColor = e.color),
          (S.alpha = e.alpha),
          (S.texture = m),
          (S.geometryData = r),
          (S.topology = g),
          A.push(S);
      });
    }
    function im(i) {
      const e = [];
      for (let t = 0; t < i.length; t++) {
        const A = i[t].shape,
          r = [];
        $A[A.type].build(A, r) && e.push(r);
      }
      return e;
    }
    class $c {
      constructor() {
        (this.batches = []), (this.geometryData = { vertices: [], uvs: [], indices: [] });
      }
    }
    class eu {
      constructor() {
        this.instructions = new Hs();
      }
      init(e) {
        const t = e.maxTextures;
        this.batcher ? this.batcher._updateMaxTextures(t) : (this.batcher = new sr({ maxTextures: t })),
          this.instructions.reset();
      }
      get geometry() {
        return (
          P(Hl, 'GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.'), this.batcher.geometry
        );
      }
      destroy() {
        this.batcher.destroy(), this.instructions.destroy(), (this.batcher = null), (this.instructions = null);
      }
    }
    const Tn = class Vs {
      constructor(e) {
        (this._gpuContextHash = {}),
          (this._graphicsDataContextHash = Object.create(null)),
          (this._renderer = e),
          e.renderableGC.addManagedHash(this, '_gpuContextHash'),
          e.renderableGC.addManagedHash(this, '_graphicsDataContextHash');
      }
      init(e) {
        Vs.defaultOptions.bezierSmoothness = e?.bezierSmoothness ?? Vs.defaultOptions.bezierSmoothness;
      }
      getContextRenderData(e) {
        return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e);
      }
      updateGpuContext(e) {
        let t = this._gpuContextHash[e.uid] || this._initContext(e);
        if (e.dirty) {
          t ? this._cleanGraphicsContextData(e) : (t = this._initContext(e)), _c(e, t);
          const A = e.batchMode;
          e.customShader || A === 'no-batch'
            ? (t.isBatchable = !1)
            : A === 'auto'
              ? (t.isBatchable = t.geometryData.vertices.length < 400)
              : (t.isBatchable = !0),
            (e.dirty = !1);
        }
        return t;
      }
      getGpuContext(e) {
        return this._gpuContextHash[e.uid] || this._initContext(e);
      }
      _initContextRenderData(e) {
        const t = se.get(eu, { maxTextures: this._renderer.limits.maxBatchableTextures }),
          { batches: A, geometryData: r } = this._gpuContextHash[e.uid],
          s = r.vertices.length,
          n = r.indices.length;
        for (let u = 0; u < A.length; u++) A[u].applyTransform = !1;
        const a = t.batcher;
        a.ensureAttributeBuffer(s), a.ensureIndexBuffer(n), a.begin();
        for (let u = 0; u < A.length; u++) {
          const o = A[u];
          a.add(o);
        }
        a.finish(t.instructions);
        const l = a.geometry;
        l.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, !0),
          l.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, !0);
        const h = a.batches;
        for (let u = 0; u < h.length; u++) {
          const o = h[u];
          o.bindGroup = $i(o.textures.textures, o.textures.count, this._renderer.limits.maxBatchableTextures);
        }
        return (this._graphicsDataContextHash[e.uid] = t), t;
      }
      _initContext(e) {
        const t = new $c();
        return (
          (t.context = e),
          (this._gpuContextHash[e.uid] = t),
          e.on('destroy', this.onGraphicsContextDestroy, this),
          this._gpuContextHash[e.uid]
        );
      }
      onGraphicsContextDestroy(e) {
        this._cleanGraphicsContextData(e),
          e.off('destroy', this.onGraphicsContextDestroy, this),
          (this._gpuContextHash[e.uid] = null);
      }
      _cleanGraphicsContextData(e) {
        const t = this._gpuContextHash[e.uid];
        t.isBatchable ||
          (this._graphicsDataContextHash[e.uid] &&
            (se.return(this.getContextRenderData(e)), (this._graphicsDataContextHash[e.uid] = null))),
          t.batches &&
          t.batches.forEach((A) => {
            se.return(A);
          });
      }
      destroy() {
        for (const e in this._gpuContextHash)
          this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context);
        (this._gpuContextHash = {}), (this._graphicsDataContextHash = {}), (this._renderer = null);
      }
    };
    Tn.extension = { type: [M.WebGLSystem, M.WebGPUSystem, M.CanvasSystem], name: 'graphicsContext' };
    Tn.defaultOptions = { bezierSmoothness: 0.5 };
    let ar = Tn;
    const rm = 8,
      Si = 11920929e-14,
      sm = 1;
    function In(i, e, t, A, r, s, n, a, l, h) {
      const o = Math.min(0.99, Math.max(0, h ?? ar.defaultOptions.bezierSmoothness));
      let c = (sm - o) / 1;
      return (c *= c), nm(e, t, A, r, s, n, a, l, i, c), i;
    }
    function nm(i, e, t, A, r, s, n, a, l, h) {
      Ts(i, e, t, A, r, s, n, a, l, h, 0), l.push(n, a);
    }
    function Ts(i, e, t, A, r, s, n, a, l, h, u) {
      if (u > rm) return;
      const o = (i + t) / 2,
        c = (e + A) / 2,
        d = (t + r) / 2,
        f = (A + s) / 2,
        g = (r + n) / 2,
        p = (s + a) / 2,
        m = (o + d) / 2,
        S = (c + f) / 2,
        q = (d + g) / 2,
        E = (f + p) / 2,
        b = (m + q) / 2,
        T = (S + E) / 2;
      if (u > 0) {
        let I = n - i,
          B = a - e;
        const y = Math.abs((t - n) * B - (A - a) * I),
          x = Math.abs((r - n) * B - (s - a) * I);
        if (y > Si && x > Si) {
          if ((y + x) * (y + x) <= h * (I * I + B * B)) {
            l.push(b, T);
            return;
          }
        } else if (y > Si) {
          if (y * y <= h * (I * I + B * B)) {
            l.push(b, T);
            return;
          }
        } else if (x > Si) {
          if (x * x <= h * (I * I + B * B)) {
            l.push(b, T);
            return;
          }
        } else if (((I = b - (i + n) / 2), (B = T - (e + a) / 2), I * I + B * B <= h)) {
          l.push(b, T);
          return;
        }
      }
      Ts(i, e, o, c, m, S, b, T, l, h, u + 1), Ts(b, T, q, E, g, p, n, a, l, h, u + 1);
    }
    const am = 8,
      om = 11920929e-14,
      lm = 1;
    function tu(i, e, t, A, r, s, n, a) {
      const h = Math.min(0.99, Math.max(0, a ?? ar.defaultOptions.bezierSmoothness));
      let u = (lm - h) / 1;
      return (u *= u), hm(e, t, A, r, s, n, i, u), i;
    }
    function hm(i, e, t, A, r, s, n, a) {
      Is(n, i, e, t, A, r, s, a, 0), n.push(r, s);
    }
    function Is(i, e, t, A, r, s, n, a, l) {
      if (l > am) return;
      const h = (e + A) / 2,
        u = (t + r) / 2,
        o = (A + s) / 2,
        c = (r + n) / 2,
        d = (h + o) / 2,
        f = (u + c) / 2;
      let g = s - e,
        p = n - t;
      const m = Math.abs((A - s) * p - (r - n) * g);
      if (m > om) {
        if (m * m <= a * (g * g + p * p)) {
          i.push(d, f);
          return;
        }
      } else if (((g = d - (e + s) / 2), (p = f - (t + n) / 2), g * g + p * p <= a)) {
        i.push(d, f);
        return;
      }
      Is(i, e, t, h, u, d, f, a, l + 1), Is(i, d, f, o, c, s, n, a, l + 1);
    }
    function bn(i, e, t, A, r, s, n, a) {
      let l = Math.abs(r - s);
      ((!n && r > s) || (n && s > r)) && (l = 2 * Math.PI - l),
        a || (a = Math.max(6, Math.floor(6 * Math.pow(A, 1 / 3) * (l / Math.PI)))),
        (a = Math.max(a, 3));
      let h = l / a,
        u = r;
      h *= n ? -1 : 1;
      for (let o = 0; o < a + 1; o++) {
        const c = Math.cos(u),
          d = Math.sin(u),
          f = e + c * A,
          g = t + d * A;
        i.push(f, g), (u += h);
      }
    }
    function Au(i, e, t, A, r, s) {
      const n = i[i.length - 2],
        l = i[i.length - 1] - t,
        h = n - e,
        u = r - t,
        o = A - e,
        c = Math.abs(l * o - h * u);
      if (c < 1e-8 || s === 0) {
        (i[i.length - 2] !== e || i[i.length - 1] !== t) && i.push(e, t);
        return;
      }
      const d = l * l + h * h,
        f = u * u + o * o,
        g = l * u + h * o,
        p = (s * Math.sqrt(d)) / c,
        m = (s * Math.sqrt(f)) / c,
        S = (p * g) / d,
        q = (m * g) / f,
        E = p * o + m * h,
        b = p * u + m * l,
        T = h * (m + S),
        I = l * (m + S),
        B = o * (p + q),
        y = u * (p + q),
        x = Math.atan2(I - b, T - E),
        C = Math.atan2(y - b, B - E);
      bn(i, E + e, b + t, s, x, C, h * u > o * l);
    }
    const kA = Math.PI * 2,
      Yr = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 },
      Dr = ({ x: i, y: e }, t, A, r, s, n, a, l) => {
        (i *= t), (e *= A);
        const h = r * i - s * e,
          u = s * i + r * e;
        return (l.x = h + n), (l.y = u + a), l;
      };
    function cm(i, e) {
      const t = e === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(e / 4),
        A = e === 1.5707963267948966 ? 0.551915024494 : t,
        r = Math.cos(i),
        s = Math.sin(i),
        n = Math.cos(i + e),
        a = Math.sin(i + e);
      return [
        { x: r - s * A, y: s + r * A },
        { x: n + a * A, y: a - n * A },
        { x: n, y: a },
      ];
    }
    const cl = (i, e, t, A) => {
      const r = i * A - e * t < 0 ? -1 : 1;
      let s = i * t + e * A;
      return s > 1 && (s = 1), s < -1 && (s = -1), r * Math.acos(s);
    },
      um = (i, e, t, A, r, s, n, a, l, h, u, o, c) => {
        const d = Math.pow(r, 2),
          f = Math.pow(s, 2),
          g = Math.pow(u, 2),
          p = Math.pow(o, 2);
        let m = d * f - d * p - f * g;
        m < 0 && (m = 0), (m /= d * p + f * g), (m = Math.sqrt(m) * (n === a ? -1 : 1));
        const S = ((m * r) / s) * o,
          q = ((m * -s) / r) * u,
          E = h * S - l * q + (i + t) / 2,
          b = l * S + h * q + (e + A) / 2,
          T = (u - S) / r,
          I = (o - q) / s,
          B = (-u - S) / r,
          y = (-o - q) / s,
          x = cl(1, 0, T, I);
        let C = cl(T, I, B, y);
        a === 0 && C > 0 && (C -= kA),
          a === 1 && C < 0 && (C += kA),
          (c.centerX = E),
          (c.centerY = b),
          (c.ang1 = x),
          (c.ang2 = C);
      };
    function iu(i, e, t, A, r, s, n, a = 0, l = 0, h = 0) {
      if (s === 0 || n === 0) return;
      const u = Math.sin((a * kA) / 360),
        o = Math.cos((a * kA) / 360),
        c = (o * (e - A)) / 2 + (u * (t - r)) / 2,
        d = (-u * (e - A)) / 2 + (o * (t - r)) / 2;
      if (c === 0 && d === 0) return;
      (s = Math.abs(s)), (n = Math.abs(n));
      const f = Math.pow(c, 2) / Math.pow(s, 2) + Math.pow(d, 2) / Math.pow(n, 2);
      f > 1 && ((s *= Math.sqrt(f)), (n *= Math.sqrt(f))), um(e, t, A, r, s, n, l, h, u, o, c, d, Yr);
      let { ang1: g, ang2: p } = Yr;
      const { centerX: m, centerY: S } = Yr;
      let q = Math.abs(p) / (kA / 4);
      Math.abs(1 - q) < 1e-7 && (q = 1);
      const E = Math.max(Math.ceil(q), 1);
      p /= E;
      let b = i[i.length - 2],
        T = i[i.length - 1];
      const I = { x: 0, y: 0 };
      for (let B = 0; B < E; B++) {
        const y = cm(g, p),
          { x, y: C } = Dr(y[0], s, n, o, u, m, S, I),
          { x: X, y: L } = Dr(y[1], s, n, o, u, m, S, I),
          { x: O, y: st } = Dr(y[2], s, n, o, u, m, S, I);
        In(i, b, T, x, C, X, L, O, st), (b = O), (T = st), (g += p);
      }
    }
    function ru(i, e, t) {
      const A = (n, a) => {
        const l = a.x - n.x,
          h = a.y - n.y,
          u = Math.sqrt(l * l + h * h),
          o = l / u,
          c = h / u;
        return { len: u, nx: o, ny: c };
      },
        r = (n, a) => {
          n === 0 ? i.moveTo(a.x, a.y) : i.lineTo(a.x, a.y);
        };
      let s = e[e.length - 1];
      for (let n = 0; n < e.length; n++) {
        const a = e[n % e.length],
          l = a.radius ?? t;
        if (l <= 0) {
          r(n, a), (s = a);
          continue;
        }
        const h = e[(n + 1) % e.length],
          u = A(a, s),
          o = A(a, h);
        if (u.len < 1e-4 || o.len < 1e-4) {
          r(n, a), (s = a);
          continue;
        }
        let c = Math.asin(u.nx * o.ny - u.ny * o.nx),
          d = 1,
          f = !1;
        u.nx * o.nx - u.ny * -o.ny < 0
          ? c < 0
            ? (c = Math.PI + c)
            : ((c = Math.PI - c), (d = -1), (f = !0))
          : c > 0 && ((d = -1), (f = !0));
        const g = c / 2;
        let p,
          m = Math.abs((Math.cos(g) * l) / Math.sin(g));
        m > Math.min(u.len / 2, o.len / 2)
          ? ((m = Math.min(u.len / 2, o.len / 2)), (p = Math.abs((m * Math.sin(g)) / Math.cos(g))))
          : (p = l);
        const S = a.x + o.nx * m + -o.ny * p * d,
          q = a.y + o.ny * m + o.nx * p * d,
          E = Math.atan2(u.ny, u.nx) + (Math.PI / 2) * d,
          b = Math.atan2(o.ny, o.nx) - (Math.PI / 2) * d;
        n === 0 && i.moveTo(S + Math.cos(E) * p, q + Math.sin(E) * p), i.arc(S, q, p, E, b, f), (s = a);
      }
    }
    function su(i, e, t, A) {
      const r = (a, l) => Math.sqrt((a.x - l.x) ** 2 + (a.y - l.y) ** 2),
        s = (a, l, h) => ({ x: a.x + (l.x - a.x) * h, y: a.y + (l.y - a.y) * h }),
        n = e.length;
      for (let a = 0; a < n; a++) {
        const l = e[(a + 1) % n],
          h = l.radius ?? t;
        if (h <= 0) {
          a === 0 ? i.moveTo(l.x, l.y) : i.lineTo(l.x, l.y);
          continue;
        }
        const u = e[a],
          o = e[(a + 2) % n],
          c = r(u, l);
        let d;
        if (c < 1e-4) d = l;
        else {
          const p = Math.min(c / 2, h);
          d = s(l, u, p / c);
        }
        const f = r(o, l);
        let g;
        if (f < 1e-4) g = l;
        else {
          const p = Math.min(f / 2, h);
          g = s(l, o, p / f);
        }
        a === 0 ? i.moveTo(d.x, d.y) : i.lineTo(d.x, d.y), i.quadraticCurveTo(l.x, l.y, g.x, g.y, A);
      }
    }
    const dm = new F();
    class nu {
      constructor(e) {
        (this.shapePrimitives = []),
          (this._currentPoly = null),
          (this._bounds = new de()),
          (this._graphicsPath2D = e),
          (this.signed = e.checkForHoles);
      }
      moveTo(e, t) {
        return this.startPoly(e, t), this;
      }
      lineTo(e, t) {
        this._ensurePoly();
        const A = this._currentPoly.points,
          r = A[A.length - 2],
          s = A[A.length - 1];
        return (r !== e || s !== t) && A.push(e, t), this;
      }
      arc(e, t, A, r, s, n) {
        this._ensurePoly(!1);
        const a = this._currentPoly.points;
        return bn(a, e, t, A, r, s, n), this;
      }
      arcTo(e, t, A, r, s) {
        this._ensurePoly();
        const n = this._currentPoly.points;
        return Au(n, e, t, A, r, s), this;
      }
      arcToSvg(e, t, A, r, s, n, a) {
        const l = this._currentPoly.points;
        return iu(l, this._currentPoly.lastX, this._currentPoly.lastY, n, a, e, t, A, r, s), this;
      }
      bezierCurveTo(e, t, A, r, s, n, a) {
        this._ensurePoly();
        const l = this._currentPoly;
        return In(this._currentPoly.points, l.lastX, l.lastY, e, t, A, r, s, n, a), this;
      }
      quadraticCurveTo(e, t, A, r, s) {
        this._ensurePoly();
        const n = this._currentPoly;
        return tu(this._currentPoly.points, n.lastX, n.lastY, e, t, A, r, s), this;
      }
      closePath() {
        return this.endPoly(!0), this;
      }
      addPath(e, t) {
        this.endPoly(), t && !t.isIdentity() && ((e = e.clone(!0)), e.transform(t));
        const A = this.shapePrimitives,
          r = A.length;
        for (let s = 0; s < e.instructions.length; s++) {
          const n = e.instructions[s];
          this[n.action](...n.data);
        }
        if (e.checkForHoles && A.length - r > 1) {
          let s = null;
          for (let n = r; n < A.length; n++) {
            const a = A[n];
            if (a.shape.type === 'polygon') {
              const l = a.shape,
                h = s?.shape;
              h && h.containsPolygon(l)
                ? (s.holes || (s.holes = []), s.holes.push(a), A.copyWithin(n, n + 1), A.length--, n--)
                : (s = a);
            }
          }
        }
        return this;
      }
      finish(e = !1) {
        this.endPoly(e);
      }
      rect(e, t, A, r, s) {
        return this.drawShape(new F(e, t, A, r), s), this;
      }
      circle(e, t, A, r) {
        return this.drawShape(new Hi(e, t, A), r), this;
      }
      poly(e, t, A) {
        const r = new Lt(e);
        return (r.closePath = t), this.drawShape(r, A), this;
      }
      regularPoly(e, t, A, r, s = 0, n) {
        r = Math.max(r | 0, 3);
        const a = (-1 * Math.PI) / 2 + s,
          l = (Math.PI * 2) / r,
          h = [];
        for (let u = 0; u < r; u++) {
          const o = a - u * l;
          h.push(e + A * Math.cos(o), t + A * Math.sin(o));
        }
        return this.poly(h, !0, n), this;
      }
      roundPoly(e, t, A, r, s, n = 0, a) {
        if (((r = Math.max(r | 0, 3)), s <= 0)) return this.regularPoly(e, t, A, r, n);
        const l = A * Math.sin(Math.PI / r) - 0.001;
        s = Math.min(s, l);
        const h = (-1 * Math.PI) / 2 + n,
          u = (Math.PI * 2) / r,
          o = ((r - 2) * Math.PI) / r / 2;
        for (let c = 0; c < r; c++) {
          const d = c * u + h,
            f = e + A * Math.cos(d),
            g = t + A * Math.sin(d),
            p = d + Math.PI + o,
            m = d - Math.PI - o,
            S = f + s * Math.cos(p),
            q = g + s * Math.sin(p),
            E = f + s * Math.cos(m),
            b = g + s * Math.sin(m);
          c === 0 ? this.moveTo(S, q) : this.lineTo(S, q), this.quadraticCurveTo(f, g, E, b, a);
        }
        return this.closePath();
      }
      roundShape(e, t, A = !1, r) {
        return e.length < 3 ? this : (A ? su(this, e, t, r) : ru(this, e, t), this.closePath());
      }
      filletRect(e, t, A, r, s) {
        if (s === 0) return this.rect(e, t, A, r);
        const n = Math.min(A, r) / 2,
          a = Math.min(n, Math.max(-n, s)),
          l = e + A,
          h = t + r,
          u = a < 0 ? -a : 0,
          o = Math.abs(a);
        return this.moveTo(e, t + o)
          .arcTo(e + u, t + u, e + o, t, o)
          .lineTo(l - o, t)
          .arcTo(l - u, t + u, l, t + o, o)
          .lineTo(l, h - o)
          .arcTo(l - u, h - u, e + A - o, h, o)
          .lineTo(e + o, h)
          .arcTo(e + u, h - u, e, h - o, o)
          .closePath();
      }
      chamferRect(e, t, A, r, s, n) {
        if (s <= 0) return this.rect(e, t, A, r);
        const a = Math.min(s, Math.min(A, r) / 2),
          l = e + A,
          h = t + r,
          u = [e + a, t, l - a, t, l, t + a, l, h - a, l - a, h, e + a, h, e, h - a, e, t + a];
        for (let o = u.length - 1; o >= 2; o -= 2) u[o] === u[o - 2] && u[o - 1] === u[o - 3] && u.splice(o - 1, 2);
        return this.poly(u, !0, n);
      }
      ellipse(e, t, A, r, s) {
        return this.drawShape(new zi(e, t, A, r), s), this;
      }
      roundRect(e, t, A, r, s, n) {
        return this.drawShape(new _i(e, t, A, r, s), n), this;
      }
      drawShape(e, t) {
        return this.endPoly(), this.shapePrimitives.push({ shape: e, transform: t }), this;
      }
      startPoly(e, t) {
        let A = this._currentPoly;
        return A && this.endPoly(), (A = new Lt()), A.points.push(e, t), (this._currentPoly = A), this;
      }
      endPoly(e = !1) {
        const t = this._currentPoly;
        return (
          t && t.points.length > 2 && ((t.closePath = e), this.shapePrimitives.push({ shape: t })),
          (this._currentPoly = null),
          this
        );
      }
      _ensurePoly(e = !0) {
        if (!this._currentPoly && ((this._currentPoly = new Lt()), e)) {
          const t = this.shapePrimitives[this.shapePrimitives.length - 1];
          if (t) {
            let A = t.shape.x,
              r = t.shape.y;
            if (t.transform && !t.transform.isIdentity()) {
              const s = t.transform,
                n = A;
              (A = s.a * A + s.c * r + s.tx), (r = s.b * n + s.d * r + s.ty);
            }
            this._currentPoly.points.push(A, r);
          } else this._currentPoly.points.push(0, 0);
        }
      }
      buildPath() {
        const e = this._graphicsPath2D;
        (this.shapePrimitives.length = 0), (this._currentPoly = null);
        for (let t = 0; t < e.instructions.length; t++) {
          const A = e.instructions[t];
          this[A.action](...A.data);
        }
        this.finish();
      }
      get bounds() {
        const e = this._bounds;
        e.clear();
        const t = this.shapePrimitives;
        for (let A = 0; A < t.length; A++) {
          const r = t[A],
            s = r.shape.getBounds(dm);
          r.transform ? e.addRect(s, r.transform) : e.addRect(s);
        }
        return e;
      }
    }
    class je {
      constructor(e, t = !1) {
        (this.instructions = []),
          (this.uid = z('graphicsPath')),
          (this._dirty = !0),
          (this.checkForHoles = t),
          typeof e == 'string' ? gc(e, this) : (this.instructions = e?.slice() ?? []);
      }
      get shapePath() {
        return (
          this._shapePath || (this._shapePath = new nu(this)),
          this._dirty && ((this._dirty = !1), this._shapePath.buildPath()),
          this._shapePath
        );
      }
      addPath(e, t) {
        return (e = e.clone()), this.instructions.push({ action: 'addPath', data: [e, t] }), (this._dirty = !0), this;
      }
      arc(...e) {
        return this.instructions.push({ action: 'arc', data: e }), (this._dirty = !0), this;
      }
      arcTo(...e) {
        return this.instructions.push({ action: 'arcTo', data: e }), (this._dirty = !0), this;
      }
      arcToSvg(...e) {
        return this.instructions.push({ action: 'arcToSvg', data: e }), (this._dirty = !0), this;
      }
      bezierCurveTo(...e) {
        return this.instructions.push({ action: 'bezierCurveTo', data: e }), (this._dirty = !0), this;
      }
      bezierCurveToShort(e, t, A, r, s) {
        const n = this.instructions[this.instructions.length - 1],
          a = this.getLastPoint(H.shared);
        let l = 0,
          h = 0;
        if (!n || n.action !== 'bezierCurveTo') (l = a.x), (h = a.y);
        else {
          (l = n.data[2]), (h = n.data[3]);
          const u = a.x,
            o = a.y;
          (l = u + (u - l)), (h = o + (o - h));
        }
        return this.instructions.push({ action: 'bezierCurveTo', data: [l, h, e, t, A, r, s] }), (this._dirty = !0), this;
      }
      closePath() {
        return this.instructions.push({ action: 'closePath', data: [] }), (this._dirty = !0), this;
      }
      ellipse(...e) {
        return this.instructions.push({ action: 'ellipse', data: e }), (this._dirty = !0), this;
      }
      lineTo(...e) {
        return this.instructions.push({ action: 'lineTo', data: e }), (this._dirty = !0), this;
      }
      moveTo(...e) {
        return this.instructions.push({ action: 'moveTo', data: e }), this;
      }
      quadraticCurveTo(...e) {
        return this.instructions.push({ action: 'quadraticCurveTo', data: e }), (this._dirty = !0), this;
      }
      quadraticCurveToShort(e, t, A) {
        const r = this.instructions[this.instructions.length - 1],
          s = this.getLastPoint(H.shared);
        let n = 0,
          a = 0;
        if (!r || r.action !== 'quadraticCurveTo') (n = s.x), (a = s.y);
        else {
          (n = r.data[0]), (a = r.data[1]);
          const l = s.x,
            h = s.y;
          (n = l + (l - n)), (a = h + (h - a));
        }
        return this.instructions.push({ action: 'quadraticCurveTo', data: [n, a, e, t, A] }), (this._dirty = !0), this;
      }
      rect(e, t, A, r, s) {
        return this.instructions.push({ action: 'rect', data: [e, t, A, r, s] }), (this._dirty = !0), this;
      }
      circle(e, t, A, r) {
        return this.instructions.push({ action: 'circle', data: [e, t, A, r] }), (this._dirty = !0), this;
      }
      roundRect(...e) {
        return this.instructions.push({ action: 'roundRect', data: e }), (this._dirty = !0), this;
      }
      poly(...e) {
        return this.instructions.push({ action: 'poly', data: e }), (this._dirty = !0), this;
      }
      regularPoly(...e) {
        return this.instructions.push({ action: 'regularPoly', data: e }), (this._dirty = !0), this;
      }
      roundPoly(...e) {
        return this.instructions.push({ action: 'roundPoly', data: e }), (this._dirty = !0), this;
      }
      roundShape(...e) {
        return this.instructions.push({ action: 'roundShape', data: e }), (this._dirty = !0), this;
      }
      filletRect(...e) {
        return this.instructions.push({ action: 'filletRect', data: e }), (this._dirty = !0), this;
      }
      chamferRect(...e) {
        return this.instructions.push({ action: 'chamferRect', data: e }), (this._dirty = !0), this;
      }
      star(e, t, A, r, s, n, a) {
        s || (s = r / 2);
        const l = (-1 * Math.PI) / 2 + n,
          h = A * 2,
          u = (Math.PI * 2) / h,
          o = [];
        for (let c = 0; c < h; c++) {
          const d = c % 2 ? s : r,
            f = c * u + l;
          o.push(e + d * Math.cos(f), t + d * Math.sin(f));
        }
        return this.poly(o, !0, a), this;
      }
      clone(e = !1) {
        const t = new je();
        if (((t.checkForHoles = this.checkForHoles), !e)) t.instructions = this.instructions.slice();
        else
          for (let A = 0; A < this.instructions.length; A++) {
            const r = this.instructions[A];
            t.instructions.push({ action: r.action, data: r.data.slice() });
          }
        return t;
      }
      clear() {
        return (this.instructions.length = 0), (this._dirty = !0), this;
      }
      transform(e) {
        if (e.isIdentity()) return this;
        const t = e.a,
          A = e.b,
          r = e.c,
          s = e.d,
          n = e.tx,
          a = e.ty;
        let l = 0,
          h = 0,
          u = 0,
          o = 0,
          c = 0,
          d = 0,
          f = 0,
          g = 0;
        for (let p = 0; p < this.instructions.length; p++) {
          const m = this.instructions[p],
            S = m.data;
          switch (m.action) {
            case 'moveTo':
            case 'lineTo':
              (l = S[0]), (h = S[1]), (S[0] = t * l + r * h + n), (S[1] = A * l + s * h + a);
              break;
            case 'bezierCurveTo':
              (u = S[0]),
                (o = S[1]),
                (c = S[2]),
                (d = S[3]),
                (l = S[4]),
                (h = S[5]),
                (S[0] = t * u + r * o + n),
                (S[1] = A * u + s * o + a),
                (S[2] = t * c + r * d + n),
                (S[3] = A * c + s * d + a),
                (S[4] = t * l + r * h + n),
                (S[5] = A * l + s * h + a);
              break;
            case 'quadraticCurveTo':
              (u = S[0]),
                (o = S[1]),
                (l = S[2]),
                (h = S[3]),
                (S[0] = t * u + r * o + n),
                (S[1] = A * u + s * o + a),
                (S[2] = t * l + r * h + n),
                (S[3] = A * l + s * h + a);
              break;
            case 'arcToSvg':
              (l = S[5]),
                (h = S[6]),
                (f = S[0]),
                (g = S[1]),
                (S[0] = t * f + r * g),
                (S[1] = A * f + s * g),
                (S[5] = t * l + r * h + n),
                (S[6] = A * l + s * h + a);
              break;
            case 'circle':
              S[4] = VA(S[3], e);
              break;
            case 'rect':
              S[4] = VA(S[4], e);
              break;
            case 'ellipse':
              S[8] = VA(S[8], e);
              break;
            case 'roundRect':
              S[5] = VA(S[5], e);
              break;
            case 'addPath':
              S[0].transform(e);
              break;
            case 'poly':
              S[2] = VA(S[2], e);
              break;
            default:
              N('unknown transform action', m.action);
              break;
          }
        }
        return (this._dirty = !0), this;
      }
      get bounds() {
        return this.shapePath.bounds;
      }
      getLastPoint(e) {
        let t = this.instructions.length - 1,
          A = this.instructions[t];
        if (!A) return (e.x = 0), (e.y = 0), e;
        for (; A.action === 'closePath';) {
          if ((t--, t < 0)) return (e.x = 0), (e.y = 0), e;
          A = this.instructions[t];
        }
        switch (A.action) {
          case 'moveTo':
          case 'lineTo':
            (e.x = A.data[0]), (e.y = A.data[1]);
            break;
          case 'quadraticCurveTo':
            (e.x = A.data[2]), (e.y = A.data[3]);
            break;
          case 'bezierCurveTo':
            (e.x = A.data[4]), (e.y = A.data[5]);
            break;
          case 'arc':
          case 'arcToSvg':
            (e.x = A.data[5]), (e.y = A.data[6]);
            break;
          case 'addPath':
            A.data[0].getLastPoint(e);
            break;
        }
        return e;
      }
    }
    function VA(i, e) {
      return i ? i.prepend(e) : e.clone();
    }
    function ee(i, e, t) {
      const A = i.getAttribute(e);
      return A ? Number(A) : t;
    }
    function au(i, e) {
      const t = i.querySelectorAll('defs');
      for (let A = 0; A < t.length; A++) {
        const r = t[A];
        for (let s = 0; s < r.children.length; s++) {
          const n = r.children[s];
          switch (n.nodeName.toLowerCase()) {
            case 'lineargradient':
              e.defs[n.id] = fm(n);
              break;
            case 'radialgradient':
              e.defs[n.id] = pm();
              break;
          }
        }
      }
    }
    function fm(i) {
      const e = ee(i, 'x1', 0),
        t = ee(i, 'y1', 0),
        A = ee(i, 'x2', 1),
        r = ee(i, 'y2', 0),
        s = i.getAttribute('gradientUnits') || 'objectBoundingBox',
        n = new Ze(e, t, A, r, s === 'objectBoundingBox' ? 'local' : 'global');
      for (let a = 0; a < i.children.length; a++) {
        const l = i.children[a],
          h = ee(l, 'offset', 0),
          u = $.shared.setValue(l.getAttribute('stop-color')).toNumber();
        n.addColorStop(h, u);
      }
      return n;
    }
    function pm(i) {
      return N('[SVG Parser] Radial gradients are not yet supported'), new Ze(0, 0, 1, 0);
    }
    function bs(i) {
      const e = i.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
      return e ? e[1] : '';
    }
    const ys = {
      fill: { type: 'paint', default: 0 },
      'fill-opacity': { type: 'number', default: 1 },
      stroke: { type: 'paint', default: 0 },
      'stroke-width': { type: 'number', default: 1 },
      'stroke-opacity': { type: 'number', default: 1 },
      'stroke-linecap': { type: 'string', default: 'butt' },
      'stroke-linejoin': { type: 'string', default: 'miter' },
      'stroke-miterlimit': { type: 'number', default: 10 },
      'stroke-dasharray': { type: 'string', default: 'none' },
      'stroke-dashoffset': { type: 'number', default: 0 },
      opacity: { type: 'number', default: 1 },
    };
    function yn(i, e) {
      const t = i.getAttribute('style'),
        A = {},
        r = {},
        s = { strokeStyle: A, fillStyle: r, useFill: !1, useStroke: !1 };
      for (const n in ys) {
        const a = i.getAttribute(n);
        a && ul(e, s, n, a.trim());
      }
      if (t) {
        const n = t.split(';');
        for (let a = 0; a < n.length; a++) {
          const l = n[a].trim(),
            [h, u] = l.split(':');
          ys[h] && ul(e, s, h, u.trim());
        }
      }
      return {
        strokeStyle: s.useStroke ? A : null,
        fillStyle: s.useFill ? r : null,
        useFill: s.useFill,
        useStroke: s.useStroke,
      };
    }
    function ul(i, e, t, A) {
      switch (t) {
        case 'stroke':
          if (A !== 'none') {
            if (A.startsWith('url(')) {
              const r = bs(A);
              e.strokeStyle.fill = i.defs[r];
            } else e.strokeStyle.color = $.shared.setValue(A).toNumber();
            e.useStroke = !0;
          }
          break;
        case 'stroke-width':
          e.strokeStyle.width = Number(A);
          break;
        case 'fill':
          if (A !== 'none') {
            if (A.startsWith('url(')) {
              const r = bs(A);
              e.fillStyle.fill = i.defs[r];
            } else e.fillStyle.color = $.shared.setValue(A).toNumber();
            e.useFill = !0;
          }
          break;
        case 'fill-opacity':
          e.fillStyle.alpha = Number(A);
          break;
        case 'stroke-opacity':
          e.strokeStyle.alpha = Number(A);
          break;
        case 'opacity':
          (e.fillStyle.alpha = Number(A)), (e.strokeStyle.alpha = Number(A));
          break;
      }
    }
    function ou(i) {
      if (i.length <= 2) return !0;
      const e = i.map((a) => a.area).sort((a, l) => l - a),
        [t, A] = e,
        r = e[e.length - 1],
        s = t / A,
        n = A / r;
      return !(s > 3 && n < 2);
    }
    function lu(i) {
      return i.split(/(?=[Mm])/).filter((A) => A.trim().length > 0);
    }
    function hu(i) {
      const e = i.match(/[-+]?[0-9]*\.?[0-9]+/g);
      if (!e || e.length < 4) return 0;
      const t = e.map(Number),
        A = [],
        r = [];
      for (let u = 0; u < t.length; u += 2) u + 1 < t.length && (A.push(t[u]), r.push(t[u + 1]));
      if (A.length === 0 || r.length === 0) return 0;
      const s = Math.min(...A),
        n = Math.max(...A),
        a = Math.min(...r),
        l = Math.max(...r);
      return (n - s) * (l - a);
    }
    function xs(i, e) {
      const t = new je(i, !1);
      for (const A of t.instructions) e.instructions.push(A);
    }
    function cu(i, e) {
      if (typeof i == 'string') {
        const n = document.createElement('div');
        (n.innerHTML = i.trim()), (i = n.querySelector('svg'));
      }
      const t = { context: e, defs: {}, path: new je() };
      au(i, t);
      const A = i.children,
        { fillStyle: r, strokeStyle: s } = yn(i, t);
      for (let n = 0; n < A.length; n++) {
        const a = A[n];
        a.nodeName.toLowerCase() !== 'defs' && uu(a, t, r, s);
      }
      return e;
    }
    function uu(i, e, t, A) {
      const r = i.children,
        { fillStyle: s, strokeStyle: n } = yn(i, e);
      s && t ? (t = { ...t, ...s }) : s && (t = s), n && A ? (A = { ...A, ...n }) : n && (A = n);
      const a = !t && !A;
      a && (t = { color: 0 });
      let l, h, u, o, c, d, f, g, p, m, S, q, E, b, T, I, B;
      switch (i.nodeName.toLowerCase()) {
        case 'path': {
          b = i.getAttribute('d');
          const y = i.getAttribute('fill-rule'),
            x = lu(b),
            C = y === 'evenodd',
            X = x.length > 1;
          if (C && X) {
            const O = x.map((U) => ({ path: U, area: hu(U) }));
            if ((O.sort((U, w) => w.area - U.area), x.length > 3 || !ou(O)))
              for (let U = 0; U < O.length; U++) {
                const w = O[U],
                  hA = U === 0;
                e.context.beginPath();
                const D = new je(void 0, !0);
                xs(w.path, D), e.context.path(D), hA ? (t && e.context.fill(t), A && e.context.stroke(A)) : e.context.cut();
              }
            else
              for (let U = 0; U < O.length; U++) {
                const w = O[U],
                  hA = U % 2 === 1;
                e.context.beginPath();
                const D = new je(void 0, !0);
                xs(w.path, D), e.context.path(D), hA ? e.context.cut() : (t && e.context.fill(t), A && e.context.stroke(A));
              }
          } else {
            const O = y ? y === 'evenodd' : !0;
            (T = new je(b, O)), e.context.path(T), t && e.context.fill(t), A && e.context.stroke(A);
          }
          break;
        }
        case 'circle':
          (f = ee(i, 'cx', 0)),
            (g = ee(i, 'cy', 0)),
            (p = ee(i, 'r', 0)),
            e.context.ellipse(f, g, p, p),
            t && e.context.fill(t),
            A && e.context.stroke(A);
          break;
        case 'rect':
          (l = ee(i, 'x', 0)),
            (h = ee(i, 'y', 0)),
            (I = ee(i, 'width', 0)),
            (B = ee(i, 'height', 0)),
            (m = ee(i, 'rx', 0)),
            (S = ee(i, 'ry', 0)),
            m || S ? e.context.roundRect(l, h, I, B, m || S) : e.context.rect(l, h, I, B),
            t && e.context.fill(t),
            A && e.context.stroke(A);
          break;
        case 'ellipse':
          (f = ee(i, 'cx', 0)),
            (g = ee(i, 'cy', 0)),
            (m = ee(i, 'rx', 0)),
            (S = ee(i, 'ry', 0)),
            e.context.beginPath(),
            e.context.ellipse(f, g, m, S),
            t && e.context.fill(t),
            A && e.context.stroke(A);
          break;
        case 'line':
          (u = ee(i, 'x1', 0)),
            (o = ee(i, 'y1', 0)),
            (c = ee(i, 'x2', 0)),
            (d = ee(i, 'y2', 0)),
            e.context.beginPath(),
            e.context.moveTo(u, o),
            e.context.lineTo(c, d),
            A && e.context.stroke(A);
          break;
        case 'polygon':
          (E = i.getAttribute('points')),
            (q = E.match(/\d+/g).map((y) => parseInt(y, 10))),
            e.context.poly(q, !0),
            t && e.context.fill(t),
            A && e.context.stroke(A);
          break;
        case 'polyline':
          (E = i.getAttribute('points')),
            (q = E.match(/\d+/g).map((y) => parseInt(y, 10))),
            e.context.poly(q, !1),
            A && e.context.stroke(A);
          break;
        case 'g':
        case 'svg':
          break;
        default: {
          N(`[SVG parser] <${i.nodeName}> elements unsupported`);
          break;
        }
      }
      a && (t = null);
      for (let y = 0; y < r.length; y++) uu(r[y], e, t, A);
    }
    function gm(i) {
      return $.isColorLike(i);
    }
    function dl(i) {
      return i instanceof _A;
    }
    function fl(i) {
      return i instanceof Ze;
    }
    function mm(i) {
      return i instanceof v;
    }
    function Sm(i, e, t) {
      const A = $.shared.setValue(e ?? 0);
      return (i.color = A.toNumber()), (i.alpha = A.alpha === 1 ? t.alpha : A.alpha), (i.texture = v.WHITE), { ...t, ...i };
    }
    function qm(i, e, t) {
      return (i.texture = e), { ...t, ...i };
    }
    function pl(i, e, t) {
      return (i.fill = e), (i.color = 16777215), (i.texture = e.texture), (i.matrix = e.transform), { ...t, ...i };
    }
    function gl(i, e, t) {
      return (
        e.buildGradient(),
        (i.fill = e),
        (i.color = 16777215),
        (i.texture = e.texture),
        (i.matrix = e.transform),
        (i.textureSpace = e.textureSpace),
        { ...t, ...i }
      );
    }
    function Mm(i, e) {
      const t = { ...e, ...i },
        A = $.shared.setValue(t.color);
      return (t.alpha *= A.alpha), (t.color = A.toNumber()), t;
    }
    function lt(i, e) {
      if (i == null) return null;
      const t = {},
        A = i;
      return gm(i)
        ? Sm(t, i, e)
        : mm(i)
          ? qm(t, i, e)
          : dl(i)
            ? pl(t, i, e)
            : fl(i)
              ? gl(t, i, e)
              : A.fill && dl(A.fill)
                ? pl(A, A.fill, e)
                : A.fill && fl(A.fill)
                  ? gl(A, A.fill, e)
                  : Mm(A, e);
    }
    function jA(i, e) {
      const { width: t, alignment: A, miterLimit: r, cap: s, join: n, pixelLine: a, ...l } = e,
        h = lt(i, l);
      return h ? { width: t, alignment: A, miterLimit: r, cap: s, join: n, pixelLine: a, ...h } : null;
    }
    const Em = new H(),
      ml = new R(),
      xn = class Ke extends ye {
        constructor() {
          super(...arguments),
            (this.uid = z('graphicsContext')),
            (this.dirty = !0),
            (this.batchMode = 'auto'),
            (this.instructions = []),
            (this._activePath = new je()),
            (this._transform = new R()),
            (this._fillStyle = { ...Ke.defaultFillStyle }),
            (this._strokeStyle = { ...Ke.defaultStrokeStyle }),
            (this._stateStack = []),
            (this._tick = 0),
            (this._bounds = new de()),
            (this._boundsDirty = !0);
        }
        clone() {
          const e = new Ke();
          return (
            (e.batchMode = this.batchMode),
            (e.instructions = this.instructions.slice()),
            (e._activePath = this._activePath.clone()),
            (e._transform = this._transform.clone()),
            (e._fillStyle = { ...this._fillStyle }),
            (e._strokeStyle = { ...this._strokeStyle }),
            (e._stateStack = this._stateStack.slice()),
            (e._bounds = this._bounds.clone()),
            (e._boundsDirty = !0),
            e
          );
        }
        get fillStyle() {
          return this._fillStyle;
        }
        set fillStyle(e) {
          this._fillStyle = lt(e, Ke.defaultFillStyle);
        }
        get strokeStyle() {
          return this._strokeStyle;
        }
        set strokeStyle(e) {
          this._strokeStyle = jA(e, Ke.defaultStrokeStyle);
        }
        setFillStyle(e) {
          return (this._fillStyle = lt(e, Ke.defaultFillStyle)), this;
        }
        setStrokeStyle(e) {
          return (this._strokeStyle = lt(e, Ke.defaultStrokeStyle)), this;
        }
        texture(e, t, A, r, s, n) {
          return (
            this.instructions.push({
              action: 'texture',
              data: {
                image: e,
                dx: A || 0,
                dy: r || 0,
                dw: s || e.frame.width,
                dh: n || e.frame.height,
                transform: this._transform.clone(),
                alpha: this._fillStyle.alpha,
                style: t ? $.shared.setValue(t).toNumber() : 16777215,
              },
            }),
            this.onUpdate(),
            this
          );
        }
        beginPath() {
          return (this._activePath = new je()), this;
        }
        fill(e, t) {
          let A;
          const r = this.instructions[this.instructions.length - 1];
          return (
            this._tick === 0 && r?.action === 'stroke' ? (A = r.data.path) : (A = this._activePath.clone()),
            A
              ? (e != null &&
                (t !== void 0 &&
                  typeof e == 'number' &&
                  (P(
                    W,
                    'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead'
                  ),
                    (e = { color: e, alpha: t })),
                  (this._fillStyle = lt(e, Ke.defaultFillStyle))),
                this.instructions.push({ action: 'fill', data: { style: this.fillStyle, path: A } }),
                this.onUpdate(),
                this._initNextPathLocation(),
                (this._tick = 0),
                this)
              : this
          );
        }
        _initNextPathLocation() {
          const { x: e, y: t } = this._activePath.getLastPoint(H.shared);
          this._activePath.clear(), this._activePath.moveTo(e, t);
        }
        stroke(e) {
          let t;
          const A = this.instructions[this.instructions.length - 1];
          return (
            this._tick === 0 && A?.action === 'fill' ? (t = A.data.path) : (t = this._activePath.clone()),
            t
              ? (e != null && (this._strokeStyle = jA(e, Ke.defaultStrokeStyle)),
                this.instructions.push({ action: 'stroke', data: { style: this.strokeStyle, path: t } }),
                this.onUpdate(),
                this._initNextPathLocation(),
                (this._tick = 0),
                this)
              : this
          );
        }
        cut() {
          for (let e = 0; e < 2; e++) {
            const t = this.instructions[this.instructions.length - 1 - e],
              A = this._activePath.clone();
            if (t && (t.action === 'stroke' || t.action === 'fill'))
              if (t.data.hole) t.data.hole.addPath(A);
              else {
                t.data.hole = A;
                break;
              }
          }
          return this._initNextPathLocation(), this;
        }
        arc(e, t, A, r, s, n) {
          this._tick++;
          const a = this._transform;
          return this._activePath.arc(a.a * e + a.c * t + a.tx, a.b * e + a.d * t + a.ty, A, r, s, n), this;
        }
        arcTo(e, t, A, r, s) {
          this._tick++;
          const n = this._transform;
          return (
            this._activePath.arcTo(
              n.a * e + n.c * t + n.tx,
              n.b * e + n.d * t + n.ty,
              n.a * A + n.c * r + n.tx,
              n.b * A + n.d * r + n.ty,
              s
            ),
            this
          );
        }
        arcToSvg(e, t, A, r, s, n, a) {
          this._tick++;
          const l = this._transform;
          return this._activePath.arcToSvg(e, t, A, r, s, l.a * n + l.c * a + l.tx, l.b * n + l.d * a + l.ty), this;
        }
        bezierCurveTo(e, t, A, r, s, n, a) {
          this._tick++;
          const l = this._transform;
          return (
            this._activePath.bezierCurveTo(
              l.a * e + l.c * t + l.tx,
              l.b * e + l.d * t + l.ty,
              l.a * A + l.c * r + l.tx,
              l.b * A + l.d * r + l.ty,
              l.a * s + l.c * n + l.tx,
              l.b * s + l.d * n + l.ty,
              a
            ),
            this
          );
        }
        closePath() {
          return this._tick++, this._activePath?.closePath(), this;
        }
        ellipse(e, t, A, r) {
          return this._tick++, this._activePath.ellipse(e, t, A, r, this._transform.clone()), this;
        }
        circle(e, t, A) {
          return this._tick++, this._activePath.circle(e, t, A, this._transform.clone()), this;
        }
        path(e) {
          return this._tick++, this._activePath.addPath(e, this._transform.clone()), this;
        }
        lineTo(e, t) {
          this._tick++;
          const A = this._transform;
          return this._activePath.lineTo(A.a * e + A.c * t + A.tx, A.b * e + A.d * t + A.ty), this;
        }
        moveTo(e, t) {
          this._tick++;
          const A = this._transform,
            r = this._activePath.instructions,
            s = A.a * e + A.c * t + A.tx,
            n = A.b * e + A.d * t + A.ty;
          return r.length === 1 && r[0].action === 'moveTo'
            ? ((r[0].data[0] = s), (r[0].data[1] = n), this)
            : (this._activePath.moveTo(s, n), this);
        }
        quadraticCurveTo(e, t, A, r, s) {
          this._tick++;
          const n = this._transform;
          return (
            this._activePath.quadraticCurveTo(
              n.a * e + n.c * t + n.tx,
              n.b * e + n.d * t + n.ty,
              n.a * A + n.c * r + n.tx,
              n.b * A + n.d * r + n.ty,
              s
            ),
            this
          );
        }
        rect(e, t, A, r) {
          return this._tick++, this._activePath.rect(e, t, A, r, this._transform.clone()), this;
        }
        roundRect(e, t, A, r, s) {
          return this._tick++, this._activePath.roundRect(e, t, A, r, s, this._transform.clone()), this;
        }
        poly(e, t) {
          return this._tick++, this._activePath.poly(e, t, this._transform.clone()), this;
        }
        regularPoly(e, t, A, r, s = 0, n) {
          return this._tick++, this._activePath.regularPoly(e, t, A, r, s, n), this;
        }
        roundPoly(e, t, A, r, s, n) {
          return this._tick++, this._activePath.roundPoly(e, t, A, r, s, n), this;
        }
        roundShape(e, t, A, r) {
          return this._tick++, this._activePath.roundShape(e, t, A, r), this;
        }
        filletRect(e, t, A, r, s) {
          return this._tick++, this._activePath.filletRect(e, t, A, r, s), this;
        }
        chamferRect(e, t, A, r, s, n) {
          return this._tick++, this._activePath.chamferRect(e, t, A, r, s, n), this;
        }
        star(e, t, A, r, s = 0, n = 0) {
          return this._tick++, this._activePath.star(e, t, A, r, s, n, this._transform.clone()), this;
        }
        svg(e) {
          return this._tick++, cu(e, this), this;
        }
        restore() {
          const e = this._stateStack.pop();
          return (
            e && ((this._transform = e.transform), (this._fillStyle = e.fillStyle), (this._strokeStyle = e.strokeStyle)), this
          );
        }
        save() {
          return (
            this._stateStack.push({
              transform: this._transform.clone(),
              fillStyle: { ...this._fillStyle },
              strokeStyle: { ...this._strokeStyle },
            }),
            this
          );
        }
        getTransform() {
          return this._transform;
        }
        resetTransform() {
          return this._transform.identity(), this;
        }
        rotate(e) {
          return this._transform.rotate(e), this;
        }
        scale(e, t = e) {
          return this._transform.scale(e, t), this;
        }
        setTransform(e, t, A, r, s, n) {
          return e instanceof R
            ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this)
            : (this._transform.set(e, t, A, r, s, n), this);
        }
        transform(e, t, A, r, s, n) {
          return e instanceof R
            ? (this._transform.append(e), this)
            : (ml.set(e, t, A, r, s, n), this._transform.append(ml), this);
        }
        translate(e, t = e) {
          return this._transform.translate(e, t), this;
        }
        clear() {
          return this._activePath.clear(), (this.instructions.length = 0), this.resetTransform(), this.onUpdate(), this;
        }
        onUpdate() {
          (this._boundsDirty = !0), !this.dirty && (this.emit('update', this, 16), (this.dirty = !0));
        }
        get bounds() {
          if (!this._boundsDirty) return this._bounds;
          this._boundsDirty = !1;
          const e = this._bounds;
          e.clear();
          for (let t = 0; t < this.instructions.length; t++) {
            const A = this.instructions[t],
              r = A.action;
            if (r === 'fill') {
              const s = A.data;
              e.addBounds(s.path.bounds);
            } else if (r === 'texture') {
              const s = A.data;
              e.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform);
            }
            if (r === 'stroke') {
              const s = A.data,
                n = s.style.alignment,
                a = s.style.width * (1 - n),
                l = s.path.bounds;
              e.addFrame(l.minX - a, l.minY - a, l.maxX + a, l.maxY + a);
            }
          }
          return e;
        }
        containsPoint(e) {
          if (!this.bounds.containsPoint(e.x, e.y)) return !1;
          const t = this.instructions;
          let A = !1;
          for (let r = 0; r < t.length; r++) {
            const s = t[r],
              n = s.data,
              a = n.path;
            if (!s.action || !a) continue;
            const l = n.style,
              h = a.shapePath.shapePrimitives;
            for (let u = 0; u < h.length; u++) {
              const o = h[u].shape;
              if (!l || !o) continue;
              const c = h[u].transform,
                d = c ? c.applyInverse(e, Em) : e;
              if (s.action === 'fill') A = o.contains(d.x, d.y);
              else {
                const g = l;
                A = o.strokeContains(d.x, d.y, g.width, g.alignment);
              }
              const f = n.hole;
              if (f) {
                const g = f.shapePath?.shapePrimitives;
                if (g) for (let p = 0; p < g.length; p++) g[p].shape.contains(d.x, d.y) && (A = !1);
              }
              if (A) return !0;
            }
          }
          return A;
        }
        destroy(e = !1) {
          if (
            ((this._stateStack.length = 0),
              (this._transform = null),
              this.emit('destroy', this),
              this.removeAllListeners(),
              typeof e == 'boolean' ? e : e?.texture)
          ) {
            const A = typeof e == 'boolean' ? e : e?.textureSource;
            this._fillStyle.texture &&
              (this._fillStyle.fill && 'uid' in this._fillStyle.fill
                ? this._fillStyle.fill.destroy()
                : this._fillStyle.texture.destroy(A)),
              this._strokeStyle.texture &&
              (this._strokeStyle.fill && 'uid' in this._strokeStyle.fill
                ? this._strokeStyle.fill.destroy()
                : this._strokeStyle.texture.destroy(A));
          }
          (this._fillStyle = null),
            (this._strokeStyle = null),
            (this.instructions = null),
            (this._activePath = null),
            (this._bounds = null),
            (this._stateStack = null),
            (this.customShader = null),
            (this._transform = null);
        }
      };
    xn.defaultFillStyle = { color: 16777215, alpha: 1, texture: v.WHITE, matrix: null, fill: null, textureSpace: 'local' };
    xn.defaultStrokeStyle = {
      width: 1,
      color: 16777215,
      alpha: 1,
      alignment: 0.5,
      miterLimit: 10,
      cap: 'butt',
      join: 'miter',
      texture: v.WHITE,
      matrix: null,
      fill: null,
      textureSpace: 'local',
      pixelLine: !1,
    };
    let Ce = xn;
    const vn = class Wt extends ye {
      constructor(e = {}) {
        super(), (this.uid = z('textStyle')), (this._tick = 0), Vm(e);
        const t = { ...Wt.defaultTextStyle, ...e };
        for (const A in t) {
          const r = A;
          this[r] = t[A];
        }
        this.update(), (this._tick = 0);
      }
      get align() {
        return this._align;
      }
      set align(e) {
        this._align !== e && ((this._align = e), this.update());
      }
      get breakWords() {
        return this._breakWords;
      }
      set breakWords(e) {
        this._breakWords !== e && ((this._breakWords = e), this.update());
      }
      get dropShadow() {
        return this._dropShadow;
      }
      set dropShadow(e) {
        this._dropShadow !== e &&
          (e !== null && typeof e == 'object'
            ? (this._dropShadow = this._createProxy({ ...Wt.defaultDropShadow, ...e }))
            : (this._dropShadow = e ? this._createProxy({ ...Wt.defaultDropShadow }) : null),
            this.update());
      }
      get fontFamily() {
        return this._fontFamily;
      }
      set fontFamily(e) {
        this._fontFamily !== e && ((this._fontFamily = e), this.update());
      }
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(e) {
        this._fontSize !== e &&
          (typeof e == 'string' ? (this._fontSize = parseInt(e, 10)) : (this._fontSize = e), this.update());
      }
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(e) {
        this._fontStyle !== e && ((this._fontStyle = e.toLowerCase()), this.update());
      }
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(e) {
        this._fontVariant !== e && ((this._fontVariant = e), this.update());
      }
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(e) {
        this._fontWeight !== e && ((this._fontWeight = e), this.update());
      }
      get leading() {
        return this._leading;
      }
      set leading(e) {
        this._leading !== e && ((this._leading = e), this.update());
      }
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(e) {
        this._letterSpacing !== e && ((this._letterSpacing = e), this.update());
      }
      get lineHeight() {
        return this._lineHeight;
      }
      set lineHeight(e) {
        this._lineHeight !== e && ((this._lineHeight = e), this.update());
      }
      get padding() {
        return this._padding;
      }
      set padding(e) {
        this._padding !== e && ((this._padding = e), this.update());
      }
      get filters() {
        return this._filters;
      }
      set filters(e) {
        this._filters !== e && ((this._filters = Object.freeze(e)), this.update());
      }
      get trim() {
        return this._trim;
      }
      set trim(e) {
        this._trim !== e && ((this._trim = e), this.update());
      }
      get textBaseline() {
        return this._textBaseline;
      }
      set textBaseline(e) {
        this._textBaseline !== e && ((this._textBaseline = e), this.update());
      }
      get whiteSpace() {
        return this._whiteSpace;
      }
      set whiteSpace(e) {
        this._whiteSpace !== e && ((this._whiteSpace = e), this.update());
      }
      get wordWrap() {
        return this._wordWrap;
      }
      set wordWrap(e) {
        this._wordWrap !== e && ((this._wordWrap = e), this.update());
      }
      get wordWrapWidth() {
        return this._wordWrapWidth;
      }
      set wordWrapWidth(e) {
        this._wordWrapWidth !== e && ((this._wordWrapWidth = e), this.update());
      }
      get fill() {
        return this._originalFill;
      }
      set fill(e) {
        e !== this._originalFill &&
          ((this._originalFill = e),
            this._isFillStyle(e) &&
            (this._originalFill = this._createProxy({ ...Ce.defaultFillStyle, ...e }, () => {
              this._fill = lt({ ...this._originalFill }, Ce.defaultFillStyle);
            })),
            (this._fill = lt(e === 0 ? 'black' : e, Ce.defaultFillStyle)),
            this.update());
      }
      get stroke() {
        return this._originalStroke;
      }
      set stroke(e) {
        e !== this._originalStroke &&
          ((this._originalStroke = e),
            this._isFillStyle(e) &&
            (this._originalStroke = this._createProxy({ ...Ce.defaultStrokeStyle, ...e }, () => {
              this._stroke = jA({ ...this._originalStroke }, Ce.defaultStrokeStyle);
            })),
            (this._stroke = jA(e, Ce.defaultStrokeStyle)),
            this.update());
      }
      update() {
        this._tick++, this.emit('update', this);
      }
      reset() {
        const e = Wt.defaultTextStyle;
        for (const t in e) this[t] = e[t];
      }
      get styleKey() {
        return `${this.uid}-${this._tick}`;
      }
      clone() {
        return new Wt({
          align: this.align,
          breakWords: this.breakWords,
          dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
          fill: this._fill,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          fontStyle: this.fontStyle,
          fontVariant: this.fontVariant,
          fontWeight: this.fontWeight,
          leading: this.leading,
          letterSpacing: this.letterSpacing,
          lineHeight: this.lineHeight,
          padding: this.padding,
          stroke: this._stroke,
          textBaseline: this.textBaseline,
          whiteSpace: this.whiteSpace,
          wordWrap: this.wordWrap,
          wordWrapWidth: this.wordWrapWidth,
          filters: this._filters ? [...this._filters] : void 0,
        });
      }
      _getFinalPadding() {
        let e = 0;
        if (this._filters) for (let t = 0; t < this._filters.length; t++) e += this._filters[t].padding;
        return Math.max(this._padding, e);
      }
      destroy(e = !1) {
        if ((this.removeAllListeners(), typeof e == 'boolean' ? e : e?.texture)) {
          const A = typeof e == 'boolean' ? e : e?.textureSource;
          this._fill?.texture && this._fill.texture.destroy(A),
            this._originalFill?.texture && this._originalFill.texture.destroy(A),
            this._stroke?.texture && this._stroke.texture.destroy(A),
            this._originalStroke?.texture && this._originalStroke.texture.destroy(A);
        }
        (this._fill = null),
          (this._stroke = null),
          (this.dropShadow = null),
          (this._originalStroke = null),
          (this._originalFill = null);
      }
      _createProxy(e, t) {
        return new Proxy(e, { set: (A, r, s) => (A[r] === s || ((A[r] = s), t?.(r, s), this.update()), !0) });
      }
      _isFillStyle(e) {
        return (e ?? null) !== null && !($.isColorLike(e) || e instanceof Ze || e instanceof _A);
      }
    };
    vn.defaultDropShadow = { alpha: 1, angle: Math.PI / 6, blur: 0, color: 'black', distance: 5 };
    vn.defaultTextStyle = {
      align: 'left',
      breakWords: !1,
      dropShadow: null,
      fill: 'black',
      fontFamily: 'Arial',
      fontSize: 26,
      fontStyle: 'normal',
      fontVariant: 'normal',
      fontWeight: 'normal',
      leading: 0,
      letterSpacing: 0,
      lineHeight: 0,
      padding: 0,
      stroke: null,
      textBaseline: 'alphabetic',
      trim: !1,
      whiteSpace: 'pre',
      wordWrap: !1,
      wordWrapWidth: 100,
    };
    let tt = vn;
    function Vm(i) {
      const e = i;
      if (typeof e.dropShadow == 'boolean' && e.dropShadow) {
        const t = tt.defaultDropShadow;
        i.dropShadow = {
          alpha: e.dropShadowAlpha ?? t.alpha,
          angle: e.dropShadowAngle ?? t.angle,
          blur: e.dropShadowBlur ?? t.blur,
          color: e.dropShadowColor ?? t.color,
          distance: e.dropShadowDistance ?? t.distance,
        };
      }
      if (e.strokeThickness !== void 0) {
        P(W, 'strokeThickness is now a part of stroke');
        const t = e.stroke;
        let A = {};
        if ($.isColorLike(t)) A.color = t;
        else if (t instanceof Ze || t instanceof _A) A.fill = t;
        else if (Object.hasOwnProperty.call(t, 'color') || Object.hasOwnProperty.call(t, 'fill')) A = t;
        else throw new Error('Invalid stroke value.');
        i.stroke = { ...A, width: e.strokeThickness };
      }
      if (Array.isArray(e.fillGradientStops)) {
        if (
          (P(W, 'gradient fill is now a fill pattern: `new FillGradient(...)`'), !Array.isArray(e.fill) || e.fill.length === 0)
        )
          throw new Error('Invalid fill value. Expected an array of colors for gradient fill.');
        e.fill.length !== e.fillGradientStops.length &&
          N('The number of fill colors must match the number of fill gradient stops.');
        const t = new Ze({ start: { x: 0, y: 0 }, end: { x: 0, y: 1 }, textureSpace: 'local' }),
          A = e.fillGradientStops.slice(),
          r = e.fill.map((s) => $.shared.setValue(s).toNumber());
        A.forEach((s, n) => {
          t.addColorStop(s, r[n]);
        }),
          (i.fill = { fill: t });
      }
    }
    class du {
      constructor(e) {
        (this._canvasPool = Object.create(null)), (this.canvasOptions = e || {}), (this.enableFullScreen = !1);
      }
      _createCanvasAndContext(e, t) {
        const A = J.get().createCanvas();
        (A.width = e), (A.height = t);
        const r = A.getContext('2d');
        return { canvas: A, context: r };
      }
      getOptimalCanvasAndContext(e, t, A = 1) {
        (e = Math.ceil(e * A - 1e-6)), (t = Math.ceil(t * A - 1e-6)), (e = xt(e)), (t = xt(t));
        const r = (e << 17) + (t << 1);
        this._canvasPool[r] || (this._canvasPool[r] = []);
        let s = this._canvasPool[r].pop();
        return s || (s = this._createCanvasAndContext(e, t)), s;
      }
      returnCanvasAndContext(e) {
        const t = e.canvas,
          { width: A, height: r } = t,
          s = (A << 17) + (r << 1);
        e.context.resetTransform(), e.context.clearRect(0, 0, A, r), this._canvasPool[s].push(e);
      }
      clear() {
        this._canvasPool = {};
      }
    }
    const Xe = new du();
    kt.register(Xe);
    const Sl = 1e5;
    function ZA(i, e, t, A = 0) {
      if (i.texture === v.WHITE && !i.fill)
        return $.shared
          .setValue(i.color)
          .setAlpha(i.alpha ?? 1)
          .toHexa();
      if (i.fill) {
        if (i.fill instanceof _A) {
          const r = i.fill,
            s = e.createPattern(r.texture.source.resource, 'repeat'),
            n = r.transform.copyTo(R.shared);
          return n.scale(r.texture.frame.width, r.texture.frame.height), s.setTransform(n), s;
        } else if (i.fill instanceof Ze) {
          const r = i.fill,
            s = r.type === 'linear',
            n = r.textureSpace === 'local';
          let a = 1,
            l = 1;
          n && t && ((a = t.width + A), (l = t.height + A));
          let h,
            u = !1;
          if (s) {
            const { start: o, end: c } = r;
            (h = e.createLinearGradient(o.x * a, o.y * l, c.x * a, c.y * l)),
              (u = Math.abs(c.x - o.x) < Math.abs((c.y - o.y) * 0.1));
          } else {
            const { center: o, innerRadius: c, outerCenter: d, outerRadius: f } = r;
            h = e.createRadialGradient(o.x * a, o.y * l, c * a, d.x * a, d.y * l, f * a);
          }
          if (u && n && t) {
            const o = t.lineHeight / l;
            for (let c = 0; c < t.lines.length; c++) {
              const d = (c * t.lineHeight + A / 2) / l;
              r.colorStops.forEach((f) => {
                const g = d + f.offset * o;
                h.addColorStop(Math.floor(g * Sl) / Sl, $.shared.setValue(f.color).toHex());
              });
            }
          } else
            r.colorStops.forEach((o) => {
              h.addColorStop(o.offset, $.shared.setValue(o.color).toHex());
            });
          return h;
        }
      } else {
        const r = e.createPattern(i.texture.source.resource, 'repeat'),
          s = i.matrix.copyTo(R.shared);
        return s.scale(i.texture.frame.width, i.texture.frame.height), r.setTransform(s), r;
      }
      return N('FillStyle not recognised', i), 'red';
    }
    const fu = class pu extends gn {
      constructor(e) {
        super(),
          (this.resolution = 1),
          (this.pages = []),
          (this._padding = 0),
          (this._measureCache = Object.create(null)),
          (this._currentChars = []),
          (this._currentX = 0),
          (this._currentY = 0),
          (this._currentMaxCharHeight = 0),
          (this._currentPageIndex = -1),
          (this._skipKerning = !1);
        const t = { ...pu.defaultOptions, ...e };
        (this._textureSize = t.textureSize), (this._mipmap = t.mipmap);
        const A = t.style.clone();
        t.overrideFill && ((A._fill.color = 16777215), (A._fill.alpha = 1), (A._fill.texture = v.WHITE), (A._fill.fill = null)),
          (this.applyFillAsTint = t.overrideFill);
        const r = A.fontSize;
        A.fontSize = this.baseMeasurementFontSize;
        const s = LA(A);
        t.overrideSize
          ? A._stroke && (A._stroke.width *= this.baseRenderedFontSize / r)
          : (A.fontSize = this.baseRenderedFontSize = r),
          (this._style = A),
          (this._skipKerning = t.skipKerning ?? !1),
          (this.resolution = t.resolution ?? 1),
          (this._padding = t.padding ?? 4),
          t.textureStyle && (this._textureStyle = t.textureStyle instanceof Je ? t.textureStyle : new Je(t.textureStyle)),
          (this.fontMetrics = Ne.measureFont(s)),
          (this.lineHeight = A.lineHeight || this.fontMetrics.fontSize || A.fontSize);
      }
      ensureCharacters(e) {
        const t = Ne.graphemeSegmenter(e)
          .filter((p) => !this._currentChars.includes(p))
          .filter((p, m, S) => S.indexOf(p) === m);
        if (!t.length) return;
        this._currentChars = [...this._currentChars, ...t];
        let A;
        this._currentPageIndex === -1 ? (A = this._nextPage()) : (A = this.pages[this._currentPageIndex]);
        let { canvas: r, context: s } = A.canvasAndContext,
          n = A.texture.source;
        const a = this._style;
        let l = this._currentX,
          h = this._currentY,
          u = this._currentMaxCharHeight;
        const o = this.baseRenderedFontSize / this.baseMeasurementFontSize,
          c = this._padding * o;
        let d = !1;
        const f = r.width / this.resolution,
          g = r.height / this.resolution;
        for (let p = 0; p < t.length; p++) {
          const m = t[p],
            S = Ne.measureText(m, a, r, !1);
          S.lineHeight = S.height;
          const q = S.width * o,
            E = Math.ceil((a.fontStyle === 'italic' ? 2 : 1) * q),
            b = S.height * o,
            T = E + c * 2,
            I = b + c * 2;
          if (
            ((d = !1),
              m !==
              `
` &&
              m !== '\r' &&
              m !== '	' &&
              m !== ' ' &&
              ((d = !0), (u = Math.ceil(Math.max(I, u)))),
              l + T > f && ((h += u), (u = I), (l = 0), h + u > g))
          ) {
            n.update();
            const y = this._nextPage();
            (r = y.canvasAndContext.canvas),
              (s = y.canvasAndContext.context),
              (n = y.texture.source),
              (l = 0),
              (h = 0),
              (u = 0);
          }
          const B = q / o - (a.dropShadow?.distance ?? 0) - (a._stroke?.width ?? 0);
          if (
            ((this.chars[m] = {
              id: m.codePointAt(0),
              xOffset: -this._padding,
              yOffset: -this._padding,
              xAdvance: B,
              kerning: {},
            }),
              d)
          ) {
            this._drawGlyph(s, S, l + c, h + c, o, a);
            const y = n.width * o,
              x = n.height * o,
              C = new F((l / y) * n.width, (h / x) * n.height, (T / y) * n.width, (I / x) * n.height);
            (this.chars[m].texture = new v({ source: n, frame: C })), (l += Math.ceil(T));
          }
        }
        n.update(),
          (this._currentX = l),
          (this._currentY = h),
          (this._currentMaxCharHeight = u),
          this._skipKerning && this._applyKerning(t, s);
      }
      get pageTextures() {
        return P(W, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.'), this.pages;
      }
      _applyKerning(e, t) {
        const A = this._measureCache;
        for (let r = 0; r < e.length; r++) {
          const s = e[r];
          for (let n = 0; n < this._currentChars.length; n++) {
            const a = this._currentChars[n];
            let l = A[s];
            l || (l = A[s] = t.measureText(s).width);
            let h = A[a];
            h || (h = A[a] = t.measureText(a).width);
            let u = t.measureText(s + a).width,
              o = u - (l + h);
            o && (this.chars[s].kerning[a] = o),
              (u = t.measureText(s + a).width),
              (o = u - (l + h)),
              o && (this.chars[a].kerning[s] = o);
          }
        }
      }
      _nextPage() {
        this._currentPageIndex++;
        const e = this.resolution,
          t = Xe.getOptimalCanvasAndContext(this._textureSize, this._textureSize, e);
        this._setupContext(t.context, this._style, e);
        const A = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize),
          r = new v({
            source: new ct({
              resource: t.canvas,
              resolution: A,
              alphaMode: 'premultiply-alpha-on-upload',
              autoGenerateMipmaps: this._mipmap,
            }),
          });
        this._textureStyle && (r.source.style = this._textureStyle);
        const s = { canvasAndContext: t, texture: r };
        return (this.pages[this._currentPageIndex] = s), s;
      }
      _setupContext(e, t, A) {
        (t.fontSize = this.baseRenderedFontSize),
          e.scale(A, A),
          (e.font = LA(t)),
          (t.fontSize = this.baseMeasurementFontSize),
          (e.textBaseline = t.textBaseline);
        const r = t._stroke,
          s = r?.width ?? 0;
        if (
          (r && ((e.lineWidth = s), (e.lineJoin = r.join), (e.miterLimit = r.miterLimit), (e.strokeStyle = ZA(r, e))),
            t._fill && (e.fillStyle = ZA(t._fill, e)),
            t.dropShadow)
        ) {
          const n = t.dropShadow,
            a = $.shared.setValue(n.color).toArray(),
            l = n.blur * A,
            h = n.distance * A;
          (e.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${n.alpha})`),
            (e.shadowBlur = l),
            (e.shadowOffsetX = Math.cos(n.angle) * h),
            (e.shadowOffsetY = Math.sin(n.angle) * h);
        } else (e.shadowColor = 'black'), (e.shadowBlur = 0), (e.shadowOffsetX = 0), (e.shadowOffsetY = 0);
      }
      _drawGlyph(e, t, A, r, s, n) {
        const a = t.text,
          l = t.fontProperties,
          u = (n._stroke?.width ?? 0) * s,
          o = A + u / 2,
          c = r - u / 2,
          d = l.descent * s,
          f = t.lineHeight * s;
        let g = !1;
        n.stroke && u && ((g = !0), e.strokeText(a, o, c + f - d));
        const { shadowBlur: p, shadowOffsetX: m, shadowOffsetY: S } = e;
        n._fill && (g && ((e.shadowBlur = 0), (e.shadowOffsetX = 0), (e.shadowOffsetY = 0)), e.fillText(a, o, c + f - d)),
          g && ((e.shadowBlur = p), (e.shadowOffsetX = m), (e.shadowOffsetY = S));
      }
      destroy() {
        super.destroy();
        for (let e = 0; e < this.pages.length; e++) {
          const { canvasAndContext: t, texture: A } = this.pages[e];
          Xe.returnCanvasAndContext(t), A.destroy(!0);
        }
        this.pages = null;
      }
    };
    fu.defaultOptions = { textureSize: 512, style: new tt(), mipmap: !0 };
    let vs = fu;
    function Cn(i, e, t, A) {
      const r = {
        width: 0,
        height: 0,
        offsetY: 0,
        scale: e.fontSize / t.baseMeasurementFontSize,
        lines: [{ width: 0, charPositions: [], spaceWidth: 0, spacesIndex: [], chars: [] }],
      };
      r.offsetY = t.baseLineOffset;
      let s = r.lines[0],
        n = null,
        a = !0;
      const l = { width: 0, start: 0, index: 0, positions: [], chars: [] },
        h = t.baseMeasurementFontSize / e.fontSize,
        u = e.letterSpacing * h,
        o = e.wordWrapWidth * h,
        c = e.lineHeight ? e.lineHeight * h : t.lineHeight,
        d = e.wordWrap && e.breakWords,
        f = (m) => {
          const S = s.width;
          for (let q = 0; q < l.index; q++) {
            const E = m.positions[q];
            s.chars.push(m.chars[q]), s.charPositions.push(E + S);
          }
          (s.width += m.width), (a = !1), (l.width = 0), (l.index = 0), (l.chars.length = 0);
        },
        g = () => {
          let m = s.chars.length - 1;
          if (A) {
            let S = s.chars[m];
            for (; S === ' ';) (s.width -= t.chars[S].xAdvance), (S = s.chars[--m]);
          }
          (r.width = Math.max(r.width, s.width)),
            (s = { width: 0, charPositions: [], chars: [], spaceWidth: 0, spacesIndex: [] }),
            (a = !0),
            r.lines.push(s),
            (r.height += c);
        },
        p = (m) => m - u > o;
      for (let m = 0; m < i.length + 1; m++) {
        let S;
        const q = m === i.length;
        q || (S = i[m]);
        const E = t.chars[S] || t.chars[' '];
        if (
          /(?:\s)/.test(S) ||
          S === '\r' ||
          S ===
          `
` ||
          q
        ) {
          if (
            (!a && e.wordWrap && p(s.width + l.width)
              ? (g(), f(l), q || s.charPositions.push(0))
              : ((l.start = s.width), f(l), q || s.charPositions.push(0)),
              S === '\r' ||
              S ===
              `
`)
          )
            g();
          else if (!q) {
            const B = E.xAdvance + (E.kerning[n] || 0) + u;
            (s.width += B), (s.spaceWidth = B), s.spacesIndex.push(s.charPositions.length), s.chars.push(S);
          }
        } else {
          const I = E.kerning[n] || 0,
            B = E.xAdvance + I + u;
          d && p(s.width + l.width + B) && (f(l), g()), (l.positions[l.index++] = l.width + I), l.chars.push(S), (l.width += B);
        }
        n = S;
      }
      return g(), e.align === 'center' ? Tm(r) : e.align === 'right' ? Im(r) : e.align === 'justify' && bm(r), r;
    }
    function Tm(i) {
      for (let e = 0; e < i.lines.length; e++) {
        const t = i.lines[e],
          A = i.width / 2 - t.width / 2;
        for (let r = 0; r < t.charPositions.length; r++) t.charPositions[r] += A;
      }
    }
    function Im(i) {
      for (let e = 0; e < i.lines.length; e++) {
        const t = i.lines[e],
          A = i.width - t.width;
        for (let r = 0; r < t.charPositions.length; r++) t.charPositions[r] += A;
      }
    }
    function bm(i) {
      const e = i.width;
      for (let t = 0; t < i.lines.length; t++) {
        const A = i.lines[t];
        let r = 0,
          s = A.spacesIndex[r++],
          n = 0;
        const a = A.spacesIndex.length,
          h = (e - A.width) / a;
        for (let u = 0; u < A.charPositions.length; u++)
          u === s && ((s = A.spacesIndex[r++]), (n += h)), (A.charPositions[u] += n);
      }
    }
    function gu(i) {
      if (i === '') return [];
      typeof i == 'string' && (i = [i]);
      const e = [];
      for (let t = 0, A = i.length; t < A; t++) {
        const r = i[t];
        if (Array.isArray(r)) {
          if (r.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
          if (r[0].length === 0 || r[1].length === 0) throw new Error('[BitmapFont]: Invalid character delimiter.');
          const s = r[0].charCodeAt(0),
            n = r[1].charCodeAt(0);
          if (n < s) throw new Error('[BitmapFont]: Invalid character range.');
          for (let a = s, l = n; a <= l; a++) e.push(String.fromCharCode(a));
        } else e.push(...Array.from(r));
      }
      if (e.length === 0) throw new Error('[BitmapFont]: Empty set when resolving characters.');
      return e;
    }
    let qi = 0;
    class ym {
      constructor() {
        (this.ALPHA = [['a', 'z'], ['A', 'Z'], ' ']),
          (this.NUMERIC = [['0', '9']]),
          (this.ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' ']),
          (this.ASCII = [[' ', '~']]),
          (this.defaultOptions = { chars: this.ALPHANUMERIC, resolution: 1, padding: 4, skipKerning: !1, textureStyle: null }),
          (this.measureCache = pc(1e3));
      }
      getFont(e, t) {
        let A = `${t.fontFamily}-bitmap`,
          r = !0;
        if (
          (t._fill.fill && !t._stroke
            ? ((A += t._fill.fill.styleKey), (r = !1))
            : (t._stroke || t.dropShadow) && ((A = `${t.styleKey}-bitmap`), (r = !1)),
            !Z.has(A))
        ) {
          const n = Object.create(t);
          n.lineHeight = 0;
          const a = new vs({ style: n, overrideFill: r, overrideSize: !0, ...this.defaultOptions });
          qi++,
            qi > 50 &&
            N(
              'BitmapText',
              `You have dynamically created ${qi} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``
            ),
            a.once('destroy', () => {
              qi--, Z.remove(A);
            }),
            Z.set(A, a);
        }
        const s = Z.get(A);
        return s.ensureCharacters?.(e), s;
      }
      getLayout(e, t, A = !0) {
        const r = this.getFont(e, t),
          s = `${e}-${t.styleKey}-${A}`;
        if (this.measureCache.has(s)) return this.measureCache.get(s);
        const n = Ne.graphemeSegmenter(e),
          a = Cn(n, t, r, A);
        return this.measureCache.set(s, a), a;
      }
      measureText(e, t, A = !0) {
        return this.getLayout(e, t, A);
      }
      install(...e) {
        let t = e[0];
        typeof t == 'string' &&
          ((t = {
            name: t,
            style: e[1],
            chars: e[2]?.chars,
            resolution: e[2]?.resolution,
            padding: e[2]?.padding,
            skipKerning: e[2]?.skipKerning,
          }),
            P(
              W,
              'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})'
            ));
        const A = t?.name;
        if (!A) throw new Error('[BitmapFontManager] Property `name` is required.');
        t = { ...this.defaultOptions, ...t };
        const r = t.style,
          s = r instanceof tt ? r : new tt(r),
          n = t.dynamicFill ?? this._canUseTintForStyle(s),
          a = new vs({
            style: s,
            overrideFill: n,
            skipKerning: t.skipKerning,
            padding: t.padding,
            resolution: t.resolution,
            overrideSize: !1,
            textureStyle: t.textureStyle,
          }),
          l = gu(t.chars);
        return a.ensureCharacters(l.join('')), Z.set(`${A}-bitmap`, a), a.once('destroy', () => Z.remove(`${A}-bitmap`)), a;
      }
      uninstall(e) {
        const t = `${e}-bitmap`,
          A = Z.get(t);
        A && A.destroy();
      }
      _canUseTintForStyle(e) {
        return !e._stroke && (!e.dropShadow || e.dropShadow.color === 0) && !e._fill.fill && e._fill.color === 16777215;
      }
    }
    const Pi = new ym();
    class Un extends gn {
      constructor(e, t) {
        super();
        const { textures: A, data: r } = e;
        Object.keys(r.pages).forEach((s) => {
          const n = r.pages[parseInt(s, 10)],
            a = A[n.id];
          this.pages.push({ texture: a });
        }),
          Object.keys(r.chars).forEach((s) => {
            const n = r.chars[s],
              { frame: a, source: l, rotate: h } = A[n.page],
              u = j.transformRectCoords(n, a, h, new F()),
              o = new v({ frame: u, orig: new F(0, 0, n.width, n.height), source: l, rotate: h });
            this.chars[s] = {
              id: s.codePointAt(0),
              xOffset: n.xOffset,
              yOffset: n.yOffset,
              xAdvance: n.xAdvance,
              kerning: n.kerning ?? {},
              texture: o,
            };
          }),
          (this.baseRenderedFontSize = r.fontSize),
          (this.baseMeasurementFontSize = r.fontSize),
          (this.fontMetrics = { ascent: 0, descent: 0, fontSize: r.fontSize }),
          (this.baseLineOffset = r.baseLineOffset),
          (this.lineHeight = r.lineHeight),
          (this.fontFamily = r.fontFamily),
          (this.distanceField = r.distanceField ?? { type: 'none', range: 0 }),
          (this.url = t);
      }
      destroy() {
        super.destroy();
        for (let e = 0; e < this.pages.length; e++) {
          const { texture: t } = this.pages[e];
          t.destroy(!0);
        }
        this.pages = null;
      }
      static install(e) {
        Pi.install(e);
      }
      static uninstall(e) {
        Pi.uninstall(e);
      }
    }
    const xi = {
      test(i) {
        return typeof i == 'string' && i.startsWith('info face=');
      },
      parse(i) {
        const e = i.match(/^[a-z]+\s+.+$/gm),
          t = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: [] };
        for (const o in e) {
          const c = e[o].match(/^[a-z]+/gm)[0],
            d = e[o].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
            f = {};
          for (const g in d) {
            const p = d[g].split('='),
              m = p[0],
              S = p[1].replace(/"/gm, ''),
              q = parseFloat(S),
              E = isNaN(q) ? S : q;
            f[m] = E;
          }
          t[c].push(f);
        }
        const A = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: '',
          distanceField: null,
          baseLineOffset: 0,
        },
          [r] = t.info,
          [s] = t.common,
          [n] = t.distanceField ?? [];
        n && (A.distanceField = { range: parseInt(n.distanceRange, 10), type: n.fieldType }),
          (A.fontSize = parseInt(r.size, 10)),
          (A.fontFamily = r.face),
          (A.lineHeight = parseInt(s.lineHeight, 10));
        const a = t.page;
        for (let o = 0; o < a.length; o++) A.pages.push({ id: parseInt(a[o].id, 10) || 0, file: a[o].file });
        const l = {};
        A.baseLineOffset = A.lineHeight - parseInt(s.base, 10);
        const h = t.char;
        for (let o = 0; o < h.length; o++) {
          const c = h[o],
            d = parseInt(c.id, 10);
          let f = c.letter ?? c.char ?? String.fromCharCode(d);
          f === 'space' && (f = ' '),
            (l[d] = f),
            (A.chars[f] = {
              id: d,
              page: parseInt(c.page, 10) || 0,
              x: parseInt(c.x, 10),
              y: parseInt(c.y, 10),
              width: parseInt(c.width, 10),
              height: parseInt(c.height, 10),
              xOffset: parseInt(c.xoffset, 10),
              yOffset: parseInt(c.yoffset, 10),
              xAdvance: parseInt(c.xadvance, 10),
              kerning: {},
            });
        }
        const u = t.kerning || [];
        for (let o = 0; o < u.length; o++) {
          const c = parseInt(u[o].first, 10),
            d = parseInt(u[o].second, 10),
            f = parseInt(u[o].amount, 10);
          A.chars[l[d]].kerning[l[c]] = f;
        }
        return A;
      },
    },
      Cs = {
        test(i) {
          const e = i;
          return (
            typeof e != 'string' &&
            'getElementsByTagName' in e &&
            e.getElementsByTagName('page').length &&
            e.getElementsByTagName('info')[0].getAttribute('face') !== null
          );
        },
        parse(i) {
          const e = {
            chars: {},
            pages: [],
            lineHeight: 0,
            fontSize: 0,
            fontFamily: '',
            distanceField: null,
            baseLineOffset: 0,
          },
            t = i.getElementsByTagName('info')[0],
            A = i.getElementsByTagName('common')[0],
            r = i.getElementsByTagName('distanceField')[0];
          r && (e.distanceField = { type: r.getAttribute('fieldType'), range: parseInt(r.getAttribute('distanceRange'), 10) });
          const s = i.getElementsByTagName('page'),
            n = i.getElementsByTagName('char'),
            a = i.getElementsByTagName('kerning');
          (e.fontSize = parseInt(t.getAttribute('size'), 10)),
            (e.fontFamily = t.getAttribute('face')),
            (e.lineHeight = parseInt(A.getAttribute('lineHeight'), 10));
          for (let h = 0; h < s.length; h++)
            e.pages.push({ id: parseInt(s[h].getAttribute('id'), 10) || 0, file: s[h].getAttribute('file') });
          const l = {};
          e.baseLineOffset = e.lineHeight - parseInt(A.getAttribute('base'), 10);
          for (let h = 0; h < n.length; h++) {
            const u = n[h],
              o = parseInt(u.getAttribute('id'), 10);
            let c = u.getAttribute('letter') ?? u.getAttribute('char') ?? String.fromCharCode(o);
            c === 'space' && (c = ' '),
              (l[o] = c),
              (e.chars[c] = {
                id: o,
                page: parseInt(u.getAttribute('page'), 10) || 0,
                x: parseInt(u.getAttribute('x'), 10),
                y: parseInt(u.getAttribute('y'), 10),
                width: parseInt(u.getAttribute('width'), 10),
                height: parseInt(u.getAttribute('height'), 10),
                xOffset: parseInt(u.getAttribute('xoffset'), 10),
                yOffset: parseInt(u.getAttribute('yoffset'), 10),
                xAdvance: parseInt(u.getAttribute('xadvance'), 10),
                kerning: {},
              });
          }
          for (let h = 0; h < a.length; h++) {
            const u = parseInt(a[h].getAttribute('first'), 10),
              o = parseInt(a[h].getAttribute('second'), 10),
              c = parseInt(a[h].getAttribute('amount'), 10);
            e.chars[l[o]].kerning[l[u]] = c;
          }
          return e;
        },
      },
      Us = {
        test(i) {
          return typeof i == 'string' && i.match(/<font(\s|>)/) ? Cs.test(J.get().parseXML(i)) : !1;
        },
        parse(i) {
          return Cs.parse(J.get().parseXML(i));
        },
      },
      xm = ['.xml', '.fnt'],
      mu = {
        extension: { type: M.CacheParser, name: 'cacheBitmapFont' },
        test: (i) => i instanceof Un,
        getCacheableAssets(i, e) {
          const t = {};
          return (
            i.forEach((A) => {
              (t[A] = e), (t[`${A}-bitmap`] = e);
            }),
            (t[`${e.fontFamily}-bitmap`] = e),
            t
          );
        },
      },
      Su = {
        extension: { type: M.LoadParser, priority: At.Normal },
        name: 'loadBitmapFont',
        id: 'bitmap-font',
        test(i) {
          return xm.includes(Ie.extname(i).toLowerCase());
        },
        async testParse(i) {
          return xi.test(i) || Us.test(i);
        },
        async parse(i, e, t) {
          const A = xi.test(i) ? xi.parse(i) : Us.parse(i),
            { src: r } = e,
            { pages: s } = A,
            n = [],
            a = A.distanceField
              ? { scaleMode: 'linear', alphaMode: 'premultiply-alpha-on-upload', autoGenerateMipmaps: !1, resolution: 1 }
              : {};
          for (let o = 0; o < s.length; ++o) {
            const c = s[o].file;
            let d = Ie.join(Ie.dirname(r), c);
            (d = Ni(d, r)), n.push({ src: d, data: a });
          }
          const l = await t.load(n),
            h = n.map((o) => l[o.src]);
          return new Un({ data: A, textures: h }, r);
        },
        async load(i, e) {
          return await (await J.get().fetch(i)).text();
        },
        async unload(i, e, t) {
          await Promise.all(i.pages.map((A) => t.unload(A.texture.source._sourceOrigin))), i.destroy();
        },
      };
    class qu {
      constructor(e, t = !1) {
        (this._loader = e), (this._assetList = []), (this._isLoading = !1), (this._maxConcurrent = 1), (this.verbose = t);
      }
      add(e) {
        e.forEach((t) => {
          this._assetList.push(t);
        }),
          this.verbose,
          this._isActive && !this._isLoading && this._next();
      }
      async _next() {
        if (this._assetList.length && this._isActive) {
          this._isLoading = !0;
          const e = [],
            t = Math.min(this._assetList.length, this._maxConcurrent);
          for (let A = 0; A < t; A++) e.push(this._assetList.pop());
          await this._loader.load(e), (this._isLoading = !1), this._next();
        }
      }
      get active() {
        return this._isActive;
      }
      set active(e) {
        this._isActive !== e && ((this._isActive = e), e && !this._isLoading && this._next());
      }
    }
    const Mu = {
      extension: { type: M.CacheParser, name: 'cacheTextureArray' },
      test: (i) => Array.isArray(i) && i.every((e) => e instanceof v),
      getCacheableAssets: (i, e) => {
        const t = {};
        return (
          i.forEach((A) => {
            e.forEach((r, s) => {
              t[A + (s === 0 ? '' : s + 1)] = r;
            });
          }),
          t
        );
      },
    };
    async function kn(i) {
      if ('Image' in globalThis)
        return new Promise((e) => {
          const t = new Image();
          (t.onload = () => {
            e(!0);
          }),
            (t.onerror = () => {
              e(!1);
            }),
            (t.src = i);
        });
      if ('createImageBitmap' in globalThis && 'fetch' in globalThis) {
        try {
          const e = await (await fetch(i)).blob();
          await createImageBitmap(e);
        } catch {
          return !1;
        }
        return !0;
      }
      return !1;
    }
    const Eu = {
      extension: { type: M.DetectionParser, priority: 1 },
      test: async () =>
        kn(
          '[PLACEHOLDER:image/avif]'
        ),
      add: async (i) => [...i, 'avif'],
      remove: async (i) => i.filter((e) => e !== 'avif'),
    },
      ql = ['png', 'jpg', 'jpeg'],
      Vu = {
        extension: { type: M.DetectionParser, priority: -1 },
        test: () => Promise.resolve(!0),
        add: async (i) => [...i, ...ql],
        remove: async (i) => i.filter((e) => !ql.includes(e)),
      },
      vm = 'WorkerGlobalScope' in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
    function ei(i) {
      return vm ? !1 : document.createElement('video').canPlayType(i) !== '';
    }
    const Tu = {
      extension: { type: M.DetectionParser, priority: 0 },
      test: async () => ei('video/mp4'),
      add: async (i) => [...i, 'mp4', 'm4v'],
      remove: async (i) => i.filter((e) => e !== 'mp4' && e !== 'm4v'),
    },
      Iu = {
        extension: { type: M.DetectionParser, priority: 0 },
        test: async () => ei('video/ogg'),
        add: async (i) => [...i, 'ogv'],
        remove: async (i) => i.filter((e) => e !== 'ogv'),
      },
      bu = {
        extension: { type: M.DetectionParser, priority: 0 },
        test: async () => ei('video/webm'),
        add: async (i) => [...i, 'webm'],
        remove: async (i) => i.filter((e) => e !== 'webm'),
      },
      yu = {
        extension: { type: M.DetectionParser, priority: 0 },
        test: async () => kn('[PLACEHOLDER:image/webp]'),
        add: async (i) => [...i, 'webp'],
        remove: async (i) => i.filter((e) => e !== 'webp'),
      },
      xu = class vi {
        constructor() {
          (this.loadOptions = { ...vi.defaultOptions }),
            (this._parsers = []),
            (this._parsersValidated = !1),
            (this.parsers = new Proxy(this._parsers, { set: (e, t, A) => ((this._parsersValidated = !1), (e[t] = A), !0) })),
            (this.promiseCache = {});
        }
        reset() {
          (this._parsersValidated = !1), (this.promiseCache = {});
        }
        _getLoadPromiseAndParser(e, t) {
          const A = { promise: null, parser: null };
          return (
            (A.promise = (async () => {
              let r = null,
                s = null;
              if (
                ((t.parser || t.loadParser) &&
                  ((s = this._parserHash[t.parser || t.loadParser]),
                    t.loadParser && N(`[Assets] "loadParser" is deprecated, use "parser" instead for ${e}`),
                    s || N(`[Assets] specified load parser "${t.parser || t.loadParser}" not found while loading ${e}`)),
                  !s)
              ) {
                for (let n = 0; n < this.parsers.length; n++) {
                  const a = this.parsers[n];
                  if (a.load && a.test?.(e, t, this)) {
                    s = a;
                    break;
                  }
                }
                if (!s)
                  return (
                    N(
                      `[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`
                    ),
                    null
                  );
              }
              (r = await s.load(e, t, this)), (A.parser = s);
              for (let n = 0; n < this.parsers.length; n++) {
                const a = this.parsers[n];
                a.parse &&
                  a.parse &&
                  (await a.testParse?.(r, t, this)) &&
                  ((r = (await a.parse(r, t, this)) || r), (A.parser = a));
              }
              return r;
            })()),
            A
          );
        }
        async load(e, t) {
          this._parsersValidated || this._validateParsers();
          const A =
            typeof t == 'function'
              ? { ...vi.defaultOptions, ...this.loadOptions, onProgress: t }
              : { ...vi.defaultOptions, ...this.loadOptions, ...(t || {}) },
            { onProgress: r, onError: s, strategy: n, retryCount: a, retryDelay: l } = A;
          let h = 0;
          const u = {},
            o = WA(e),
            c = Be(e, (g) => ({ alias: [g], src: g, data: {} })),
            d = c.reduce((g, p) => g + (p.progressSize || 1), 0),
            f = c.map(async (g) => {
              const p = Ie.toAbsolute(g.src);
              u[g.src] ||
                (await this._loadAssetWithRetry(
                  p,
                  g,
                  { onProgress: r, onError: s, strategy: n, retryCount: a, retryDelay: l },
                  u
                ),
                  (h += g.progressSize || 1),
                  r && r(h / d));
            });
          return await Promise.all(f), o ? u[c[0].src] : u;
        }
        async unload(e) {
          const A = Be(e, (r) => ({ alias: [r], src: r })).map(async (r) => {
            const s = Ie.toAbsolute(r.src),
              n = this.promiseCache[s];
            if (n) {
              const a = await n.promise;
              delete this.promiseCache[s], await n.parser?.unload?.(a, r, this);
            }
          });
          await Promise.all(A);
        }
        _validateParsers() {
          (this._parsersValidated = !0),
            (this._parserHash = this._parsers
              .filter((e) => e.name || e.id)
              .reduce(
                (e, t) => (
                  !t.name && !t.id
                    ? N('[Assets] parser should have an id')
                    : (e[t.name] || e[t.id]) && N(`[Assets] parser id conflict "${t.id}"`),
                  (e[t.name] = t),
                  t.id && (e[t.id] = t),
                  e
                ),
                {}
              ));
        }
        async _loadAssetWithRetry(e, t, A, r) {
          let s = 0;
          const { onError: n, strategy: a, retryCount: l, retryDelay: h } = A,
            u = (o) => new Promise((c) => setTimeout(c, o));
          for (; ;)
            try {
              this.promiseCache[e] || (this.promiseCache[e] = this._getLoadPromiseAndParser(e, t)),
                (r[t.src] = await this.promiseCache[e].promise);
              return;
            } catch (o) {
              delete this.promiseCache[e], delete r[t.src], s++;
              const c = a !== 'retry' || s > l;
              if (a === 'retry' && !c) {
                n && n(o, t), await u(h);
                continue;
              }
              if (a === 'skip') {
                n && n(o, t);
                return;
              }
              throw (
                (n && n(o, t),
                  new Error(`[Loader.load] Failed to load ${e}.
${o}`))
              );
            }
        }
      };
    xu.defaultOptions = { onProgress: void 0, onError: void 0, strategy: 'throw', retryCount: 3, retryDelay: 250 };
    let vu = xu;
    function Nt(i, e) {
      if (Array.isArray(e)) {
        for (const t of e) if (i.startsWith(`data:${t}`)) return !0;
        return !1;
      }
      return i.startsWith(`data:${e}`);
    }
    function Qt(i, e) {
      const t = i.split('?')[0],
        A = Ie.extname(t).toLowerCase();
      return Array.isArray(e) ? e.includes(A) : A === e;
    }
    const Cm = '.json',
      Um = 'application/json',
      Cu = {
        extension: { type: M.LoadParser, priority: At.Low },
        name: 'loadJson',
        id: 'json',
        test(i) {
          return Nt(i, Um) || Qt(i, Cm);
        },
        async load(i) {
          return await (await J.get().fetch(i)).json();
        },
      },
      km = '.txt',
      Rm = 'text/plain',
      Uu = {
        name: 'loadTxt',
        id: 'text',
        extension: { type: M.LoadParser, priority: At.Low, name: 'loadTxt' },
        test(i) {
          return Nt(i, Rm) || Qt(i, km);
        },
        async load(i) {
          return await (await J.get().fetch(i)).text();
        },
      },
      Bm = ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900'],
      Nm = ['.ttf', '.otf', '.woff', '.woff2'],
      Qm = ['font/ttf', 'font/otf', 'font/woff', 'font/woff2'],
      wm = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
    function ku(i) {
      const e = Ie.extname(i),
        r = Ie.basename(i, e)
          .replace(/(-|_)/g, ' ')
          .toLowerCase()
          .split(' ')
          .map((a) => a.charAt(0).toUpperCase() + a.slice(1));
      let s = r.length > 0;
      for (const a of r)
        if (!a.match(wm)) {
          s = !1;
          break;
        }
      let n = r.join(' ');
      return s || (n = `"${n.replace(/[\\"]/g, '\\$&')}"`), n;
    }
    const Pm = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
    function Jm(i) {
      return Pm.test(i) ? i : encodeURI(i);
    }
    const Ru = {
      extension: { type: M.LoadParser, priority: At.Low },
      name: 'loadWebFont',
      id: 'web-font',
      test(i) {
        return Nt(i, Qm) || Qt(i, Nm);
      },
      async load(i, e) {
        const t = J.get().getFontFaceSet();
        if (t) {
          const A = [],
            r = e.data?.family ?? ku(i),
            s = e.data?.weights?.filter((a) => Bm.includes(a)) ?? ['normal'],
            n = e.data ?? {};
          for (let a = 0; a < s.length; a++) {
            const l = s[a],
              h = new FontFace(r, `url(${Jm(i)})`, { ...n, weight: l });
            await h.load(), t.add(h), A.push(h);
          }
          return (
            Z.has(`${r}-and-url`)
              ? Z.get(`${r}-and-url`).entries.push({ url: i, faces: A })
              : Z.set(`${r}-and-url`, { entries: [{ url: i, faces: A }] }),
            A.length === 1 ? A[0] : A
          );
        }
        return N('[loadWebFont] FontFace API is not supported. Skipping loading font'), null;
      },
      unload(i) {
        const e = Array.isArray(i) ? i : [i],
          t = e[0].family,
          A = Z.get(`${t}-and-url`),
          r = A.entries.find((s) => s.faces.some((n) => e.indexOf(n) !== -1));
        (r.faces = r.faces.filter((s) => e.indexOf(s) === -1)),
          r.faces.length === 0 && (A.entries = A.entries.filter((s) => s !== r)),
          e.forEach((s) => {
            J.get().getFontFaceSet().delete(s);
          }),
          A.entries.length === 0 && Z.remove(`${t}-and-url`);
      },
    };
    function or(i, e = 1) {
      const t = Rt.RETINA_PREFIX?.exec(i);
      return t ? parseFloat(t[1]) : e;
    }
    function lr(i, e, t) {
      (i.label = t), (i._sourceOrigin = t);
      const A = new v({ source: i, label: t }),
        r = () => {
          delete e.promiseCache[t], Z.has(t) && Z.remove(t);
        };
      return (
        A.source.once('destroy', () => {
          e.promiseCache[t] &&
            (N(
              '[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.'
            ),
              r());
        }),
        A.once('destroy', () => {
          i.destroyed ||
            (N(
              '[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.'
            ),
              r());
        }),
        A
      );
    }
    const Gm = '.svg',
      Wm = 'image/svg+xml',
      Bu = {
        extension: { type: M.LoadParser, priority: At.Low, name: 'loadSVG' },
        name: 'loadSVG',
        id: 'svg',
        config: { crossOrigin: 'anonymous', parseAsGraphicsContext: !1 },
        test(i) {
          return Nt(i, Wm) || Qt(i, Gm);
        },
        async load(i, e, t) {
          return e.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext
            ? Fm(i)
            : Km(i, e, t, this.config.crossOrigin);
        },
        unload(i) {
          i.destroy(!0);
        },
      };
    async function Km(i, e, t, A) {
      const r = await J.get().fetch(i),
        s = J.get().createImage();
      (s.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await r.text())}`), (s.crossOrigin = A), await s.decode();
      const n = e.data?.width ?? s.width,
        a = e.data?.height ?? s.height,
        l = e.data?.resolution || or(i),
        h = Math.ceil(n * l),
        u = Math.ceil(a * l),
        o = J.get().createCanvas(h, u),
        c = o.getContext('2d');
      (c.imageSmoothingEnabled = !0), (c.imageSmoothingQuality = 'high'), c.drawImage(s, 0, 0, n * l, a * l);
      const { parseAsGraphicsContext: d, ...f } = e.data ?? {},
        g = new ct({ resource: o, alphaMode: 'premultiply-alpha-on-upload', resolution: l, ...f });
      return lr(g, t, i);
    }
    async function Fm(i) {
      const t = await (await J.get().fetch(i)).text(),
        A = new Ce();
      return A.svg(t), A;
    }
    const Ym = `(function () {
    'use strict';

    const WHITE_PNG = "[PLACEHOLDER:image/png]";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
    let jt = null,
      ks = class {
        constructor() {
          jt || (jt = URL.createObjectURL(new Blob([Ym], { type: 'application/javascript' }))), (this.worker = new Worker(jt));
        }
      };
    ks.revokeObjectURL = function () {
      jt && (URL.revokeObjectURL(jt), (jt = null));
    };
    const Dm = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
    let Zt = null;
    class Nu {
      constructor() {
        Zt || (Zt = URL.createObjectURL(new Blob([Dm], { type: 'application/javascript' }))), (this.worker = new Worker(Zt));
      }
    }
    Nu.revokeObjectURL = function () {
      Zt && (URL.revokeObjectURL(Zt), (Zt = null));
    };
    let Ml = 0,
      Or;
    class Om {
      constructor() {
        (this._initialized = !1),
          (this._createdWorkers = 0),
          (this._workerPool = []),
          (this._queue = []),
          (this._resolveHash = {});
      }
      isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0
          ? this._isImageBitmapSupported
          : ((this._isImageBitmapSupported = new Promise((e) => {
            const { worker: t } = new ks();
            t.addEventListener('message', (A) => {
              t.terminate(), ks.revokeObjectURL(), e(A.data);
            });
          })),
            this._isImageBitmapSupported);
      }
      loadImageBitmap(e, t) {
        return this._run('loadImageBitmap', [e, t?.data?.alphaMode]);
      }
      async _initWorkers() {
        this._initialized || (this._initialized = !0);
      }
      _getWorker() {
        Or === void 0 && (Or = navigator.hardwareConcurrency || 4);
        let e = this._workerPool.pop();
        return (
          !e &&
          this._createdWorkers < Or &&
          (this._createdWorkers++,
            (e = new Nu().worker),
            e.addEventListener('message', (t) => {
              this._complete(t.data), this._returnWorker(t.target), this._next();
            })),
          e
        );
      }
      _returnWorker(e) {
        this._workerPool.push(e);
      }
      _complete(e) {
        this._resolveHash[e.uuid] &&
          (e.error !== void 0 ? this._resolveHash[e.uuid].reject(e.error) : this._resolveHash[e.uuid].resolve(e.data),
            delete this._resolveHash[e.uuid]);
      }
      async _run(e, t) {
        await this._initWorkers();
        const A = new Promise((r, s) => {
          this._queue.push({ id: e, arguments: t, resolve: r, reject: s });
        });
        return this._next(), A;
      }
      _next() {
        if (!this._queue.length) return;
        const e = this._getWorker();
        if (!e) return;
        const t = this._queue.pop(),
          A = t.id;
        (this._resolveHash[Ml] = { resolve: t.resolve, reject: t.reject }),
          e.postMessage({ data: t.arguments, uuid: Ml++, id: A });
      }
      reset() {
        this._workerPool.forEach((e) => e.terminate()),
          (this._workerPool.length = 0),
          Object.values(this._resolveHash).forEach(({ reject: e }) => {
            e?.(new Error('WorkerManager has been reset before completion'));
          }),
          (this._resolveHash = {}),
          (this._queue.length = 0),
          (this._initialized = !1),
          (this._createdWorkers = 0);
      }
    }
    const Rs = new Om(),
      Lm = ['.jpeg', '.jpg', '.png', '.webp', '.avif'],
      jm = ['image/jpeg', 'image/png', 'image/webp', 'image/avif'];
    async function Qu(i, e) {
      const t = await J.get().fetch(i);
      if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${t.status} ${t.statusText}`);
      const A = await t.blob();
      return e?.data?.alphaMode === 'premultiplied-alpha'
        ? createImageBitmap(A, { premultiplyAlpha: 'none' })
        : createImageBitmap(A);
    }
    const Rn = {
      name: 'loadTextures',
      id: 'texture',
      extension: { type: M.LoadParser, priority: At.High, name: 'loadTextures' },
      config: { preferWorkers: !0, preferCreateImageBitmap: !0, crossOrigin: 'anonymous' },
      test(i) {
        return Nt(i, jm) || Qt(i, Lm);
      },
      async load(i, e, t) {
        let A = null;
        globalThis.createImageBitmap && this.config.preferCreateImageBitmap
          ? this.config.preferWorkers && (await Rs.isImageBitmapSupported())
            ? (A = await Rs.loadImageBitmap(i, e))
            : (A = await Qu(i, e))
          : (A = await new Promise((s, n) => {
            (A = J.get().createImage()),
              (A.crossOrigin = this.config.crossOrigin),
              (A.src = i),
              A.complete
                ? s(A)
                : ((A.onload = () => {
                  s(A);
                }),
                  (A.onerror = n));
          }));
        const r = new ct({
          resource: A,
          alphaMode: 'premultiply-alpha-on-upload',
          resolution: e.data?.resolution || or(i),
          ...e.data,
        });
        return lr(r, t, i);
      },
      unload(i) {
        i.destroy(!0);
      },
    },
      Zm = ['.mp4', '.m4v', '.webm', '.ogg', '.ogv', '.h264', '.avi', '.mov'];
    let Lr, jr;
    function wu(i, e, t) {
      t === void 0 && !e.startsWith('data:')
        ? (i.crossOrigin = Ju(e))
        : t !== !1 && (i.crossOrigin = typeof t == 'string' ? t : 'anonymous');
    }
    function Pu(i) {
      return new Promise((e, t) => {
        i.addEventListener('canplaythrough', A), i.addEventListener('error', r), i.load();
        function A() {
          s(), e();
        }
        function r(n) {
          s(), t(n);
        }
        function s() {
          i.removeEventListener('canplaythrough', A), i.removeEventListener('error', r);
        }
      });
    }
    function Ju(i, e = globalThis.location) {
      if (i.startsWith('data:')) return '';
      e || (e = globalThis.location);
      const t = new URL(i, document.baseURI);
      return t.hostname !== e.hostname || t.port !== e.port || t.protocol !== e.protocol ? 'anonymous' : '';
    }
    function Xm() {
      const i = [],
        e = [];
      for (const t of Zm) {
        const A = Ot.MIME_TYPES[t.substring(1)] || `video/${t.substring(1)}`;
        ei(A) && (i.push(t), e.includes(A) || e.push(A));
      }
      return { validVideoExtensions: i, validVideoMime: e };
    }
    const Gu = {
      name: 'loadVideo',
      id: 'video',
      extension: { type: M.LoadParser, name: 'loadVideo' },
      test(i) {
        if (!Lr || !jr) {
          const { validVideoExtensions: A, validVideoMime: r } = Xm();
          (Lr = A), (jr = r);
        }
        const e = Nt(i, jr),
          t = Qt(i, Lr);
        return e || t;
      },
      async load(i, e, t) {
        const A = {
          ...Ot.defaultOptions,
          resolution: e.data?.resolution || or(i),
          alphaMode: e.data?.alphaMode || (await An()),
          ...e.data,
        },
          r = document.createElement('video'),
          s = {
            preload: A.autoLoad !== !1 ? 'auto' : void 0,
            'webkit-playsinline': A.playsinline !== !1 ? '' : void 0,
            playsinline: A.playsinline !== !1 ? '' : void 0,
            muted: A.muted === !0 ? '' : void 0,
            loop: A.loop === !0 ? '' : void 0,
            autoplay: A.autoPlay !== !1 ? '' : void 0,
          };
        Object.keys(s).forEach((l) => {
          const h = s[l];
          h !== void 0 && r.setAttribute(l, h);
        }),
          A.muted === !0 && (r.muted = !0),
          wu(r, i, A.crossorigin);
        const n = document.createElement('source');
        let a;
        if (A.mime) a = A.mime;
        else if (i.startsWith('data:')) a = i.slice(5, i.indexOf(';'));
        else if (!i.startsWith('blob:')) {
          const l = i
            .split('?')[0]
            .slice(i.lastIndexOf('.') + 1)
            .toLowerCase();
          a = Ot.MIME_TYPES[l] || `video/${l}`;
        }
        return (
          (n.src = i),
          a && (n.type = a),
          new Promise((l) => {
            const h = async () => {
              const u = new Ot({ ...A, resource: r });
              r.removeEventListener('canplay', h), e.data.preload && (await Pu(r)), l(lr(u, t, i));
            };
            A.preload && !A.autoPlay && r.load(), r.addEventListener('canplay', h), r.appendChild(n);
          })
        );
      },
      unload(i) {
        i.destroy(!0);
      },
    },
      Bn = {
        extension: { type: M.ResolveParser, name: 'resolveTexture' },
        test: Rn.test,
        parse: (i) => ({ resolution: parseFloat(Rt.RETINA_PREFIX.exec(i)?.[1] ?? '1'), format: i.split('.').pop(), src: i }),
      },
      Wu = {
        extension: { type: M.ResolveParser, priority: -2, name: 'resolveJson' },
        test: (i) => Rt.RETINA_PREFIX.test(i) && i.endsWith('.json'),
        parse: Bn.parse,
      };
    class Ku {
      constructor() {
        (this._detections = []),
          (this._initialized = !1),
          (this.resolver = new Rt()),
          (this.loader = new vu()),
          (this.cache = Z),
          (this._backgroundLoader = new qu(this.loader)),
          (this._backgroundLoader.active = !0),
          this.reset();
      }
      async init(e = {}) {
        if (this._initialized) {
          N('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');
          return;
        }
        if (
          ((this._initialized = !0),
            e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams),
            e.basePath && (this.resolver.basePath = e.basePath),
            e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier),
            e.manifest)
        ) {
          let s = e.manifest;
          typeof s == 'string' && (s = await this.load(s)), this.resolver.addManifest(s);
        }
        const t = e.texturePreference?.resolution ?? 1,
          A = typeof t == 'number' ? [t] : t,
          r = await this._detectFormats({
            preferredFormats: e.texturePreference?.format,
            skipDetections: e.skipDetections,
            detections: this._detections,
          });
        this.resolver.prefer({ params: { format: r, resolution: A } }),
          e.preferences && this.setPreferences(e.preferences),
          e.loadOptions && (this.loader.loadOptions = { ...this.loader.loadOptions, ...e.loadOptions });
      }
      add(e) {
        this.resolver.add(e);
      }
      async load(e, t) {
        this._initialized || (await this.init());
        const A = WA(e),
          r = Be(e).map((a) => {
            if (typeof a != 'string') {
              const l = this.resolver.getAlias(a);
              return l.some((h) => !this.resolver.hasKey(h)) && this.add(a), Array.isArray(l) ? l[0] : l;
            }
            return this.resolver.hasKey(a) || this.add({ alias: a, src: a }), a;
          }),
          s = this.resolver.resolve(r),
          n = await this._mapLoadToResolve(s, t);
        return A ? n[r[0]] : n;
      }
      addBundle(e, t) {
        this.resolver.addBundle(e, t);
      }
      async loadBundle(e, t) {
        this._initialized || (await this.init());
        let A = !1;
        typeof e == 'string' && ((A = !0), (e = [e]));
        const r = this.resolver.resolveBundle(e),
          s = {},
          n = Object.keys(r);
        let a = 0;
        const l = [],
          h = () => {
            t?.(l.reduce((o, c) => o + c, 0) / a);
          },
          u = n.map((o, c) => {
            const d = r[o],
              f = Object.values(d),
              p = [...new Set(f.flat())].reduce((m, S) => m + (S.progressSize || 1), 0);
            return (
              l.push(0),
              (a += p),
              this._mapLoadToResolve(d, (m) => {
                (l[c] = m * p), h();
              }).then((m) => {
                s[o] = m;
              })
            );
          });
        return await Promise.all(u), A ? s[e[0]] : s;
      }
      async backgroundLoad(e) {
        this._initialized || (await this.init()), typeof e == 'string' && (e = [e]);
        const t = this.resolver.resolve(e);
        this._backgroundLoader.add(Object.values(t));
      }
      async backgroundLoadBundle(e) {
        this._initialized || (await this.init()), typeof e == 'string' && (e = [e]);
        const t = this.resolver.resolveBundle(e);
        Object.values(t).forEach((A) => {
          this._backgroundLoader.add(Object.values(A));
        });
      }
      reset() {
        this.resolver.reset(), this.loader.reset(), this.cache.reset(), (this._initialized = !1);
      }
      get(e) {
        if (typeof e == 'string') return Z.get(e);
        const t = {};
        for (let A = 0; A < e.length; A++) t[A] = Z.get(e[A]);
        return t;
      }
      async _mapLoadToResolve(e, t) {
        const A = [...new Set(Object.values(e))];
        this._backgroundLoader.active = !1;
        const r = await this.loader.load(A, t);
        this._backgroundLoader.active = !0;
        const s = {};
        return (
          A.forEach((n) => {
            const a = r[n.src],
              l = [n.src];
            n.alias && l.push(...n.alias),
              l.forEach((h) => {
                s[h] = a;
              }),
              Z.set(l, a);
          }),
          s
        );
      }
      async unload(e) {
        this._initialized || (await this.init());
        const t = Be(e).map((r) => (typeof r != 'string' ? r.src : r)),
          A = this.resolver.resolve(t);
        await this._unloadFromResolved(A);
      }
      async unloadBundle(e) {
        this._initialized || (await this.init()), (e = Be(e));
        const t = this.resolver.resolveBundle(e),
          A = Object.keys(t).map((r) => this._unloadFromResolved(t[r]));
        await Promise.all(A);
      }
      async _unloadFromResolved(e) {
        const t = Object.values(e);
        t.forEach((A) => {
          Z.remove(A.src);
        }),
          await this.loader.unload(t);
      }
      async _detectFormats(e) {
        let t = [];
        e.preferredFormats && (t = Array.isArray(e.preferredFormats) ? e.preferredFormats : [e.preferredFormats]);
        for (const A of e.detections)
          e.skipDetections || (await A.test()) ? (t = await A.add(t)) : e.skipDetections || (t = await A.remove(t));
        return (t = t.filter((A, r) => t.indexOf(A) === r)), t;
      }
      get detections() {
        return this._detections;
      }
      setPreferences(e) {
        this.loader.parsers.forEach((t) => {
          t.config &&
            Object.keys(t.config)
              .filter((A) => A in e)
              .forEach((A) => {
                t.config[A] = e[A];
              });
        });
      }
    }
    const te = new Ku();
    Q.handleByList(M.LoadParser, te.loader.parsers)
      .handleByList(M.ResolveParser, te.resolver.parsers)
      .handleByList(M.CacheParser, te.cache.parsers)
      .handleByList(M.DetectionParser, te.detections);
    Q.add(Mu, Vu, Eu, yu, Tu, Iu, bu, Cu, Uu, Ru, Bu, Rn, Gu, Su, mu, Bn, Wu);
    const El = { loader: M.LoadParser, resolver: M.ResolveParser, cache: M.CacheParser, detection: M.DetectionParser };
    Q.handle(
      M.Asset,
      (i) => {
        const e = i.ref;
        Object.entries(El)
          .filter(([t]) => !!e[t])
          .forEach(([t, A]) => Q.add(Object.assign(e[t], { extension: e[t].extension ?? A })));
      },
      (i) => {
        const e = i.ref;
        Object.keys(El)
          .filter((t) => !!e[t])
          .forEach((t) => Q.remove(e[t]));
      }
    );
    class Nn {
      constructor(e) {
        (this._attachedDomElements = []),
          (this._renderer = e),
          this._renderer.runners.postrender.add(this),
          this._renderer.runners.init.add(this),
          (this._domElement = document.createElement('div')),
          (this._domElement.style.position = 'absolute'),
          (this._domElement.style.top = '0'),
          (this._domElement.style.left = '0'),
          (this._domElement.style.pointerEvents = 'none'),
          (this._domElement.style.zIndex = '1000');
      }
      init() {
        this._canvasObserver = new rn({ domElement: this._domElement, renderer: this._renderer });
      }
      addRenderable(e, t) {
        this._attachedDomElements.includes(e) || this._attachedDomElements.push(e);
      }
      updateRenderable(e) { }
      validateRenderable(e) {
        return !0;
      }
      postrender() {
        const e = this._attachedDomElements;
        if (e.length === 0) {
          this._domElement.remove();
          return;
        }
        this._canvasObserver.ensureAttached();
        for (let t = 0; t < e.length; t++) {
          const A = e[t],
            r = A.element;
          if (!A.parent || A.globalDisplayStatus < 7) r?.remove(), e.splice(t, 1), t--;
          else {
            this._domElement.contains(r) ||
              ((r.style.position = 'absolute'), (r.style.pointerEvents = 'auto'), this._domElement.appendChild(r));
            const s = A.worldTransform,
              n = A._anchor,
              a = A.width * n.x,
              l = A.height * n.y;
            (r.style.transformOrigin = `${a}px ${l}px`),
              (r.style.transform = `matrix(${s.a}, ${s.b}, ${s.c}, ${s.d}, ${s.tx - a}, ${s.ty - l})`),
              (r.style.opacity = A.groupAlpha.toString());
          }
        }
      }
      destroy() {
        this._renderer.runners.postrender.remove(this);
        for (let e = 0; e < this._attachedDomElements.length; e++) this._attachedDomElements[e].element?.remove();
        (this._attachedDomElements.length = 0),
          this._domElement.remove(),
          this._canvasObserver.destroy(),
          (this._renderer = null);
      }
    }
    Nn.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'dom' };
    class Hm {
      constructor() {
        (this.interactionFrequency = 10),
          (this._deltaTime = 0),
          (this._didMove = !1),
          (this._tickerAdded = !1),
          (this._pauseUpdate = !0);
      }
      init(e) {
        this.removeTickerListener(),
          (this.events = e),
          (this.interactionFrequency = 10),
          (this._deltaTime = 0),
          (this._didMove = !1),
          (this._tickerAdded = !1),
          (this._pauseUpdate = !0);
      }
      get pauseUpdate() {
        return this._pauseUpdate;
      }
      set pauseUpdate(e) {
        this._pauseUpdate = e;
      }
      addTickerListener() {
        this._tickerAdded ||
          !this.domElement ||
          (ue.system.add(this._tickerUpdate, this, ut.INTERACTION), (this._tickerAdded = !0));
      }
      removeTickerListener() {
        this._tickerAdded && (ue.system.remove(this._tickerUpdate, this), (this._tickerAdded = !1));
      }
      pointerMoved() {
        this._didMove = !0;
      }
      _update() {
        if (!this.domElement || this._pauseUpdate) return;
        if (this._didMove) {
          this._didMove = !1;
          return;
        }
        const e = this.events._rootPointerEvent;
        (this.events.supportsTouchEvents && e.pointerType === 'touch') ||
          globalThis.document.dispatchEvent(
            this.events.supportsPointerEvents
              ? new PointerEvent('pointermove', {
                clientX: e.clientX,
                clientY: e.clientY,
                pointerType: e.pointerType,
                pointerId: e.pointerId,
              })
              : new MouseEvent('mousemove', { clientX: e.clientX, clientY: e.clientY })
          );
      }
      _tickerUpdate(e) {
        (this._deltaTime += e.deltaTime),
          !(this._deltaTime < this.interactionFrequency) && ((this._deltaTime = 0), this._update());
      }
      destroy() {
        this.removeTickerListener(),
          (this.events = null),
          (this.domElement = null),
          (this._deltaTime = 0),
          (this._didMove = !1),
          (this._tickerAdded = !1),
          (this._pauseUpdate = !0);
      }
    }
    const Fe = new Hm();
    class XA extends iA {
      constructor() {
        super(...arguments),
          (this.client = new H()),
          (this.movement = new H()),
          (this.offset = new H()),
          (this.global = new H()),
          (this.screen = new H());
      }
      get clientX() {
        return this.client.x;
      }
      get clientY() {
        return this.client.y;
      }
      get x() {
        return this.clientX;
      }
      get y() {
        return this.clientY;
      }
      get movementX() {
        return this.movement.x;
      }
      get movementY() {
        return this.movement.y;
      }
      get offsetX() {
        return this.offset.x;
      }
      get offsetY() {
        return this.offset.y;
      }
      get globalX() {
        return this.global.x;
      }
      get globalY() {
        return this.global.y;
      }
      get screenX() {
        return this.screen.x;
      }
      get screenY() {
        return this.screen.y;
      }
      getLocalPosition(e, t, A) {
        return e.worldTransform.applyInverse(A || this.global, t);
      }
      getModifierState(e) {
        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(e);
      }
      initMouseEvent(e, t, A, r, s, n, a, l, h, u, o, c, d, f, g) {
        throw new Error('Method not implemented.');
      }
    }
    class Re extends XA {
      constructor() {
        super(...arguments), (this.width = 0), (this.height = 0), (this.isPrimary = !1);
      }
      getCoalescedEvents() {
        return this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove' ? [this] : [];
      }
      getPredictedEvents() {
        throw new Error('getPredictedEvents is not supported!');
      }
    }
    class Ct extends XA {
      constructor() {
        super(...arguments), (this.DOM_DELTA_PIXEL = 0), (this.DOM_DELTA_LINE = 1), (this.DOM_DELTA_PAGE = 2);
      }
    }
    Ct.DOM_DELTA_PIXEL = 0;
    Ct.DOM_DELTA_LINE = 1;
    Ct.DOM_DELTA_PAGE = 2;
    const zm = 2048,
      _m = new H(),
      TA = new H();
    class Fu {
      constructor(e) {
        (this.dispatch = new ye()),
          (this.moveOnAll = !1),
          (this.enableGlobalMoveEvents = !0),
          (this.mappingState = { trackingData: {} }),
          (this.eventPool = new Map()),
          (this._allInteractiveElements = []),
          (this._hitElements = []),
          (this._isPointerMoveEvent = !1),
          (this.rootTarget = e),
          (this.hitPruneFn = this.hitPruneFn.bind(this)),
          (this.hitTestFn = this.hitTestFn.bind(this)),
          (this.mapPointerDown = this.mapPointerDown.bind(this)),
          (this.mapPointerMove = this.mapPointerMove.bind(this)),
          (this.mapPointerOut = this.mapPointerOut.bind(this)),
          (this.mapPointerOver = this.mapPointerOver.bind(this)),
          (this.mapPointerUp = this.mapPointerUp.bind(this)),
          (this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this)),
          (this.mapWheel = this.mapWheel.bind(this)),
          (this.mappingTable = {}),
          this.addEventMapping('pointerdown', this.mapPointerDown),
          this.addEventMapping('pointermove', this.mapPointerMove),
          this.addEventMapping('pointerout', this.mapPointerOut),
          this.addEventMapping('pointerleave', this.mapPointerOut),
          this.addEventMapping('pointerover', this.mapPointerOver),
          this.addEventMapping('pointerup', this.mapPointerUp),
          this.addEventMapping('pointerupoutside', this.mapPointerUpOutside),
          this.addEventMapping('wheel', this.mapWheel);
      }
      addEventMapping(e, t) {
        this.mappingTable[e] || (this.mappingTable[e] = []),
          this.mappingTable[e].push({ fn: t, priority: 0 }),
          this.mappingTable[e].sort((A, r) => A.priority - r.priority);
      }
      dispatchEvent(e, t) {
        (e.propagationStopped = !1),
          (e.propagationImmediatelyStopped = !1),
          this.propagate(e, t),
          this.dispatch.emit(t || e.type, e);
      }
      mapEvent(e) {
        if (!this.rootTarget) return;
        const t = this.mappingTable[e.type];
        if (t) for (let A = 0, r = t.length; A < r; A++) t[A].fn(e);
        else N(`[EventBoundary]: Event mapping not defined for ${e.type}`);
      }
      hitTest(e, t) {
        Fe.pauseUpdate = !0;
        const r = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? 'hitTestMoveRecursive' : 'hitTestRecursive',
          s = this[r](this.rootTarget, this.rootTarget.eventMode, _m.set(e, t), this.hitTestFn, this.hitPruneFn);
        return s && s[0];
      }
      propagate(e, t) {
        if (!e.target) return;
        const A = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (let r = 0, s = A.length - 1; r < s; r++)
          if (((e.currentTarget = A[r]), this.notifyTarget(e, t), e.propagationStopped || e.propagationImmediatelyStopped))
            return;
        if (
          ((e.eventPhase = e.AT_TARGET),
            (e.currentTarget = e.target),
            this.notifyTarget(e, t),
            !(e.propagationStopped || e.propagationImmediatelyStopped))
        ) {
          e.eventPhase = e.BUBBLING_PHASE;
          for (let r = A.length - 2; r >= 0; r--)
            if (((e.currentTarget = A[r]), this.notifyTarget(e, t), e.propagationStopped || e.propagationImmediatelyStopped))
              return;
        }
      }
      all(e, t, A = this._allInteractiveElements) {
        if (A.length === 0) return;
        e.eventPhase = e.BUBBLING_PHASE;
        const r = Array.isArray(t) ? t : [t];
        for (let s = A.length - 1; s >= 0; s--)
          r.forEach((n) => {
            (e.currentTarget = A[s]), this.notifyTarget(e, n);
          });
      }
      propagationPath(e) {
        const t = [e];
        for (let A = 0; A < zm && e !== this.rootTarget && e.parent; A++) {
          if (!e.parent) throw new Error('Cannot find propagation path to disconnected target');
          t.push(e.parent), (e = e.parent);
        }
        return t.reverse(), t;
      }
      hitTestMoveRecursive(e, t, A, r, s, n = !1) {
        let a = !1;
        if (this._interactivePrune(e)) return null;
        if (((e.eventMode === 'dynamic' || t === 'dynamic') && (Fe.pauseUpdate = !1), e.interactiveChildren && e.children)) {
          const u = e.children;
          for (let o = u.length - 1; o >= 0; o--) {
            const c = u[o],
              d = this.hitTestMoveRecursive(c, this._isInteractive(t) ? t : c.eventMode, A, r, s, n || s(e, A));
            if (d) {
              if (d.length > 0 && !d[d.length - 1].parent) continue;
              const f = e.isInteractive();
              (d.length > 0 || f) && (f && this._allInteractiveElements.push(e), d.push(e)),
                this._hitElements.length === 0 && (this._hitElements = d),
                (a = !0);
            }
          }
        }
        const l = this._isInteractive(t),
          h = e.isInteractive();
        return (
          h && h && this._allInteractiveElements.push(e),
          n || this._hitElements.length > 0 ? null : a ? this._hitElements : l && !s(e, A) && r(e, A) ? (h ? [e] : []) : null
        );
      }
      hitTestRecursive(e, t, A, r, s) {
        if (this._interactivePrune(e) || s(e, A)) return null;
        if (((e.eventMode === 'dynamic' || t === 'dynamic') && (Fe.pauseUpdate = !1), e.interactiveChildren && e.children)) {
          const l = e.children,
            h = A;
          for (let u = l.length - 1; u >= 0; u--) {
            const o = l[u],
              c = this.hitTestRecursive(o, this._isInteractive(t) ? t : o.eventMode, h, r, s);
            if (c) {
              if (c.length > 0 && !c[c.length - 1].parent) continue;
              const d = e.isInteractive();
              return (c.length > 0 || d) && c.push(e), c;
            }
          }
        }
        const n = this._isInteractive(t),
          a = e.isInteractive();
        return n && r(e, A) ? (a ? [e] : []) : null;
      }
      _isInteractive(e) {
        return e === 'static' || e === 'dynamic';
      }
      _interactivePrune(e) {
        return (
          !e ||
          !e.visible ||
          !e.renderable ||
          !e.measurable ||
          e.eventMode === 'none' ||
          (e.eventMode === 'passive' && !e.interactiveChildren)
        );
      }
      hitPruneFn(e, t) {
        if (e.hitArea && (e.worldTransform.applyInverse(t, TA), !e.hitArea.contains(TA.x, TA.y))) return !0;
        if (e.effects && e.effects.length)
          for (let A = 0; A < e.effects.length; A++) {
            const r = e.effects[A];
            if (r.containsPoint && !r.containsPoint(t, this.hitTestFn)) return !0;
          }
        return !1;
      }
      hitTestFn(e, t) {
        return e.hitArea ? !0 : e?.containsPoint ? (e.worldTransform.applyInverse(t, TA), e.containsPoint(TA)) : !1;
      }
      notifyTarget(e, t) {
        if (!e.currentTarget.isInteractive()) return;
        t ?? (t = e.type);
        const A = `on${t}`;
        e.currentTarget[A]?.(e);
        const r = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${t}capture` : t;
        this._notifyListeners(e, r), e.eventPhase === e.AT_TARGET && this._notifyListeners(e, t);
      }
      mapPointerDown(e) {
        if (!(e instanceof Re)) {
          N('EventBoundary cannot map a non-pointer event as a pointer event');
          return;
        }
        const t = this.createPointerEvent(e);
        if ((this.dispatchEvent(t, 'pointerdown'), t.pointerType === 'touch')) this.dispatchEvent(t, 'touchstart');
        else if (t.pointerType === 'mouse' || t.pointerType === 'pen') {
          const r = t.button === 2;
          this.dispatchEvent(t, r ? 'rightdown' : 'mousedown');
        }
        const A = this.trackingData(e.pointerId);
        (A.pressTargetsByButton[e.button] = t.composedPath()), this.freeEvent(t);
      }
      mapPointerMove(e) {
        if (!(e instanceof Re)) {
          N('EventBoundary cannot map a non-pointer event as a pointer event');
          return;
        }
        (this._allInteractiveElements.length = 0), (this._hitElements.length = 0), (this._isPointerMoveEvent = !0);
        const t = this.createPointerEvent(e);
        this._isPointerMoveEvent = !1;
        const A = t.pointerType === 'mouse' || t.pointerType === 'pen',
          r = this.trackingData(e.pointerId),
          s = this.findMountedTarget(r.overTargets);
        if (r.overTargets?.length > 0 && s !== t.target) {
          const l = e.type === 'mousemove' ? 'mouseout' : 'pointerout',
            h = this.createPointerEvent(e, l, s);
          if ((this.dispatchEvent(h, 'pointerout'), A && this.dispatchEvent(h, 'mouseout'), !t.composedPath().includes(s))) {
            const u = this.createPointerEvent(e, 'pointerleave', s);
            for (u.eventPhase = u.AT_TARGET; u.target && !t.composedPath().includes(u.target);)
              (u.currentTarget = u.target),
                this.notifyTarget(u),
                A && this.notifyTarget(u, 'mouseleave'),
                (u.target = u.target.parent);
            this.freeEvent(u);
          }
          this.freeEvent(h);
        }
        if (s !== t.target) {
          const l = e.type === 'mousemove' ? 'mouseover' : 'pointerover',
            h = this.clonePointerEvent(t, l);
          this.dispatchEvent(h, 'pointerover'), A && this.dispatchEvent(h, 'mouseover');
          let u = s?.parent;
          for (; u && u !== this.rootTarget.parent && u !== t.target;) u = u.parent;
          if (!u || u === this.rootTarget.parent) {
            const c = this.clonePointerEvent(t, 'pointerenter');
            for (c.eventPhase = c.AT_TARGET; c.target && c.target !== s && c.target !== this.rootTarget.parent;)
              (c.currentTarget = c.target),
                this.notifyTarget(c),
                A && this.notifyTarget(c, 'mouseenter'),
                (c.target = c.target.parent);
            this.freeEvent(c);
          }
          this.freeEvent(h);
        }
        const n = [],
          a = this.enableGlobalMoveEvents ?? !0;
        this.moveOnAll ? n.push('pointermove') : this.dispatchEvent(t, 'pointermove'),
          a && n.push('globalpointermove'),
          t.pointerType === 'touch' &&
          (this.moveOnAll ? n.splice(1, 0, 'touchmove') : this.dispatchEvent(t, 'touchmove'), a && n.push('globaltouchmove')),
          A &&
          (this.moveOnAll ? n.splice(1, 0, 'mousemove') : this.dispatchEvent(t, 'mousemove'),
            a && n.push('globalmousemove'),
            (this.cursor = t.target?.cursor)),
          n.length > 0 && this.all(t, n),
          (this._allInteractiveElements.length = 0),
          (this._hitElements.length = 0),
          (r.overTargets = t.composedPath()),
          this.freeEvent(t);
      }
      mapPointerOver(e) {
        if (!(e instanceof Re)) {
          N('EventBoundary cannot map a non-pointer event as a pointer event');
          return;
        }
        const t = this.trackingData(e.pointerId),
          A = this.createPointerEvent(e),
          r = A.pointerType === 'mouse' || A.pointerType === 'pen';
        this.dispatchEvent(A, 'pointerover'),
          r && this.dispatchEvent(A, 'mouseover'),
          A.pointerType === 'mouse' && (this.cursor = A.target?.cursor);
        const s = this.clonePointerEvent(A, 'pointerenter');
        for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent;)
          (s.currentTarget = s.target),
            this.notifyTarget(s),
            r && this.notifyTarget(s, 'mouseenter'),
            (s.target = s.target.parent);
        (t.overTargets = A.composedPath()), this.freeEvent(A), this.freeEvent(s);
      }
      mapPointerOut(e) {
        if (!(e instanceof Re)) {
          N('EventBoundary cannot map a non-pointer event as a pointer event');
          return;
        }
        const t = this.trackingData(e.pointerId);
        if (t.overTargets) {
          const A = e.pointerType === 'mouse' || e.pointerType === 'pen',
            r = this.findMountedTarget(t.overTargets),
            s = this.createPointerEvent(e, 'pointerout', r);
          this.dispatchEvent(s), A && this.dispatchEvent(s, 'mouseout');
          const n = this.createPointerEvent(e, 'pointerleave', r);
          for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent;)
            (n.currentTarget = n.target),
              this.notifyTarget(n),
              A && this.notifyTarget(n, 'mouseleave'),
              (n.target = n.target.parent);
          (t.overTargets = null), this.freeEvent(s), this.freeEvent(n);
        }
        this.cursor = null;
      }
      mapPointerUp(e) {
        if (!(e instanceof Re)) {
          N('EventBoundary cannot map a non-pointer event as a pointer event');
          return;
        }
        const t = performance.now(),
          A = this.createPointerEvent(e);
        if ((this.dispatchEvent(A, 'pointerup'), A.pointerType === 'touch')) this.dispatchEvent(A, 'touchend');
        else if (A.pointerType === 'mouse' || A.pointerType === 'pen') {
          const a = A.button === 2;
          this.dispatchEvent(A, a ? 'rightup' : 'mouseup');
        }
        const r = this.trackingData(e.pointerId),
          s = this.findMountedTarget(r.pressTargetsByButton[e.button]);
        let n = s;
        if (s && !A.composedPath().includes(s)) {
          let a = s;
          for (; a && !A.composedPath().includes(a);) {
            if (((A.currentTarget = a), this.notifyTarget(A, 'pointerupoutside'), A.pointerType === 'touch'))
              this.notifyTarget(A, 'touchendoutside');
            else if (A.pointerType === 'mouse' || A.pointerType === 'pen') {
              const l = A.button === 2;
              this.notifyTarget(A, l ? 'rightupoutside' : 'mouseupoutside');
            }
            a = a.parent;
          }
          delete r.pressTargetsByButton[e.button], (n = a);
        }
        if (n) {
          const a = this.clonePointerEvent(A, 'click');
          (a.target = n),
            (a.path = null),
            r.clicksByButton[e.button] || (r.clicksByButton[e.button] = { clickCount: 0, target: a.target, timeStamp: t });
          const l = r.clicksByButton[e.button];
          if (
            (l.target === a.target && t - l.timeStamp < 200 ? ++l.clickCount : (l.clickCount = 1),
              (l.target = a.target),
              (l.timeStamp = t),
              (a.detail = l.clickCount),
              a.pointerType === 'mouse')
          ) {
            const h = a.button === 2;
            this.dispatchEvent(a, h ? 'rightclick' : 'click');
          } else a.pointerType === 'touch' && this.dispatchEvent(a, 'tap');
          this.dispatchEvent(a, 'pointertap'), this.freeEvent(a);
        }
        this.freeEvent(A);
      }
      mapPointerUpOutside(e) {
        if (!(e instanceof Re)) {
          N('EventBoundary cannot map a non-pointer event as a pointer event');
          return;
        }
        const t = this.trackingData(e.pointerId),
          A = this.findMountedTarget(t.pressTargetsByButton[e.button]),
          r = this.createPointerEvent(e);
        if (A) {
          let s = A;
          for (; s;)
            (r.currentTarget = s),
              this.notifyTarget(r, 'pointerupoutside'),
              r.pointerType === 'touch'
                ? this.notifyTarget(r, 'touchendoutside')
                : (r.pointerType === 'mouse' || r.pointerType === 'pen') &&
                this.notifyTarget(r, r.button === 2 ? 'rightupoutside' : 'mouseupoutside'),
              (s = s.parent);
          delete t.pressTargetsByButton[e.button];
        }
        this.freeEvent(r);
      }
      mapWheel(e) {
        if (!(e instanceof Ct)) {
          N('EventBoundary cannot map a non-wheel event as a wheel event');
          return;
        }
        const t = this.createWheelEvent(e);
        this.dispatchEvent(t), this.freeEvent(t);
      }
      findMountedTarget(e) {
        if (!e) return null;
        let t = e[0];
        for (let A = 1; A < e.length && e[A].parent === t; A++) t = e[A];
        return t;
      }
      createPointerEvent(e, t, A) {
        const r = this.allocateEvent(Re);
        return (
          this.copyPointerData(e, r),
          this.copyMouseData(e, r),
          this.copyData(e, r),
          (r.nativeEvent = e.nativeEvent),
          (r.originalEvent = e),
          (r.target = A ?? this.hitTest(r.global.x, r.global.y) ?? this._hitElements[0]),
          typeof t == 'string' && (r.type = t),
          r
        );
      }
      createWheelEvent(e) {
        const t = this.allocateEvent(Ct);
        return (
          this.copyWheelData(e, t),
          this.copyMouseData(e, t),
          this.copyData(e, t),
          (t.nativeEvent = e.nativeEvent),
          (t.originalEvent = e),
          (t.target = this.hitTest(t.global.x, t.global.y)),
          t
        );
      }
      clonePointerEvent(e, t) {
        const A = this.allocateEvent(Re);
        return (
          (A.nativeEvent = e.nativeEvent),
          (A.originalEvent = e.originalEvent),
          this.copyPointerData(e, A),
          this.copyMouseData(e, A),
          this.copyData(e, A),
          (A.target = e.target),
          (A.path = e.composedPath().slice()),
          (A.type = t ?? A.type),
          A
        );
      }
      copyWheelData(e, t) {
        (t.deltaMode = e.deltaMode), (t.deltaX = e.deltaX), (t.deltaY = e.deltaY), (t.deltaZ = e.deltaZ);
      }
      copyPointerData(e, t) {
        e instanceof Re &&
          t instanceof Re &&
          ((t.pointerId = e.pointerId),
            (t.width = e.width),
            (t.height = e.height),
            (t.isPrimary = e.isPrimary),
            (t.pointerType = e.pointerType),
            (t.pressure = e.pressure),
            (t.tangentialPressure = e.tangentialPressure),
            (t.tiltX = e.tiltX),
            (t.tiltY = e.tiltY),
            (t.twist = e.twist));
      }
      copyMouseData(e, t) {
        e instanceof XA &&
          t instanceof XA &&
          ((t.altKey = e.altKey),
            (t.button = e.button),
            (t.buttons = e.buttons),
            t.client.copyFrom(e.client),
            (t.ctrlKey = e.ctrlKey),
            (t.metaKey = e.metaKey),
            t.movement.copyFrom(e.movement),
            t.screen.copyFrom(e.screen),
            (t.shiftKey = e.shiftKey),
            t.global.copyFrom(e.global));
      }
      copyData(e, t) {
        (t.isTrusted = e.isTrusted),
          (t.srcElement = e.srcElement),
          (t.timeStamp = performance.now()),
          (t.type = e.type),
          (t.detail = e.detail),
          (t.view = e.view),
          (t.which = e.which),
          t.layer.copyFrom(e.layer),
          t.page.copyFrom(e.page);
      }
      trackingData(e) {
        return (
          this.mappingState.trackingData[e] ||
          (this.mappingState.trackingData[e] = { pressTargetsByButton: {}, clicksByButton: {}, overTarget: null }),
          this.mappingState.trackingData[e]
        );
      }
      allocateEvent(e) {
        this.eventPool.has(e) || this.eventPool.set(e, []);
        const t = this.eventPool.get(e).pop() || new e(this);
        return (
          (t.eventPhase = t.NONE), (t.currentTarget = null), (t.defaultPrevented = !1), (t.path = null), (t.target = null), t
        );
      }
      freeEvent(e) {
        if (e.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');
        const t = e.constructor;
        this.eventPool.has(t) || this.eventPool.set(t, []), this.eventPool.get(t).push(e);
      }
      _notifyListeners(e, t) {
        const A = e.currentTarget._events[t];
        if (A)
          if ('fn' in A) A.once && e.currentTarget.removeListener(t, A.fn, void 0, !0), A.fn.call(A.context, e);
          else
            for (let r = 0, s = A.length; r < s && !e.propagationImmediatelyStopped; r++)
              A[r].once && e.currentTarget.removeListener(t, A[r].fn, void 0, !0), A[r].fn.call(A[r].context, e);
      }
    }
    const $m = 1,
      eS = {
        touchstart: 'pointerdown',
        touchend: 'pointerup',
        touchendoutside: 'pointerupoutside',
        touchmove: 'pointermove',
        touchcancel: 'pointercancel',
      },
      Qn = class Bs {
        constructor(e) {
          (this.supportsTouchEvents = 'ontouchstart' in globalThis),
            (this.supportsPointerEvents = !!globalThis.PointerEvent),
            (this.domElement = null),
            (this.resolution = 1),
            (this.renderer = e),
            (this.rootBoundary = new Fu(null)),
            Fe.init(this),
            (this.autoPreventDefault = !0),
            (this._eventsAdded = !1),
            (this._rootPointerEvent = new Re(null)),
            (this._rootWheelEvent = new Ct(null)),
            (this.cursorStyles = { default: 'inherit', pointer: 'pointer' }),
            (this.features = new Proxy(
              { ...Bs.defaultEventFeatures },
              { set: (t, A, r) => (A === 'globalMove' && (this.rootBoundary.enableGlobalMoveEvents = r), (t[A] = r), !0) }
            )),
            (this._onPointerDown = this._onPointerDown.bind(this)),
            (this._onPointerMove = this._onPointerMove.bind(this)),
            (this._onPointerUp = this._onPointerUp.bind(this)),
            (this._onPointerOverOut = this._onPointerOverOut.bind(this)),
            (this.onWheel = this.onWheel.bind(this));
        }
        static get defaultEventMode() {
          return this._defaultEventMode;
        }
        init(e) {
          const { canvas: t, resolution: A } = this.renderer;
          this.setTargetElement(t),
            (this.resolution = A),
            (Bs._defaultEventMode = e.eventMode ?? 'passive'),
            Object.assign(this.features, e.eventFeatures ?? {}),
            (this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove);
        }
        resolutionChange(e) {
          this.resolution = e;
        }
        destroy() {
          Fe.destroy(), this.setTargetElement(null), (this.renderer = null), (this._currentCursor = null);
        }
        setCursor(e) {
          e || (e = 'default');
          let t = !0;
          if ((globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (t = !1), this._currentCursor === e))
            return;
          this._currentCursor = e;
          const A = this.cursorStyles[e];
          if (A)
            switch (typeof A) {
              case 'string':
                t && (this.domElement.style.cursor = A);
                break;
              case 'function':
                A(e);
                break;
              case 'object':
                t && Object.assign(this.domElement.style, A);
                break;
            }
          else
            t &&
              typeof e == 'string' &&
              !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) &&
              (this.domElement.style.cursor = e);
        }
        get pointer() {
          return this._rootPointerEvent;
        }
        _onPointerDown(e) {
          if (!this.features.click) return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const t = this._normalizeToPointerData(e);
          this.autoPreventDefault && t[0].isNormalized && (e.cancelable || !('cancelable' in e)) && e.preventDefault();
          for (let A = 0, r = t.length; A < r; A++) {
            const s = t[A],
              n = this._bootstrapEvent(this._rootPointerEvent, s);
            this.rootBoundary.mapEvent(n);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        _onPointerMove(e) {
          if (!this.features.move) return;
          (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered), Fe.pointerMoved();
          const t = this._normalizeToPointerData(e);
          for (let A = 0, r = t.length; A < r; A++) {
            const s = this._bootstrapEvent(this._rootPointerEvent, t[A]);
            this.rootBoundary.mapEvent(s);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        _onPointerUp(e) {
          if (!this.features.click) return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          let t = e.target;
          e.composedPath && e.composedPath().length > 0 && (t = e.composedPath()[0]);
          const A = t !== this.domElement ? 'outside' : '',
            r = this._normalizeToPointerData(e);
          for (let s = 0, n = r.length; s < n; s++) {
            const a = this._bootstrapEvent(this._rootPointerEvent, r[s]);
            (a.type += A), this.rootBoundary.mapEvent(a);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        _onPointerOverOut(e) {
          if (!this.features.click) return;
          this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
          const t = this._normalizeToPointerData(e);
          for (let A = 0, r = t.length; A < r; A++) {
            const s = this._bootstrapEvent(this._rootPointerEvent, t[A]);
            this.rootBoundary.mapEvent(s);
          }
          this.setCursor(this.rootBoundary.cursor);
        }
        onWheel(e) {
          if (!this.features.wheel) return;
          const t = this.normalizeWheelEvent(e);
          (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered), this.rootBoundary.mapEvent(t);
        }
        setTargetElement(e) {
          this._removeEvents(), (this.domElement = e), (Fe.domElement = e), this._addEvents();
        }
        _addEvents() {
          if (this._eventsAdded || !this.domElement) return;
          Fe.addTickerListener();
          const e = this.domElement.style;
          e &&
            (globalThis.navigator.msPointerEnabled
              ? ((e.msContentZooming = 'none'), (e.msTouchAction = 'none'))
              : this.supportsPointerEvents && (e.touchAction = 'none')),
            this.supportsPointerEvents
              ? (globalThis.document.addEventListener('pointermove', this._onPointerMove, !0),
                this.domElement.addEventListener('pointerdown', this._onPointerDown, !0),
                this.domElement.addEventListener('pointerleave', this._onPointerOverOut, !0),
                this.domElement.addEventListener('pointerover', this._onPointerOverOut, !0),
                globalThis.addEventListener('pointerup', this._onPointerUp, !0))
              : (globalThis.document.addEventListener('mousemove', this._onPointerMove, !0),
                this.domElement.addEventListener('mousedown', this._onPointerDown, !0),
                this.domElement.addEventListener('mouseout', this._onPointerOverOut, !0),
                this.domElement.addEventListener('mouseover', this._onPointerOverOut, !0),
                globalThis.addEventListener('mouseup', this._onPointerUp, !0),
                this.supportsTouchEvents &&
                (this.domElement.addEventListener('touchstart', this._onPointerDown, !0),
                  this.domElement.addEventListener('touchend', this._onPointerUp, !0),
                  this.domElement.addEventListener('touchmove', this._onPointerMove, !0))),
            this.domElement.addEventListener('wheel', this.onWheel, { passive: !0, capture: !0 }),
            (this._eventsAdded = !0);
        }
        _removeEvents() {
          if (!this._eventsAdded || !this.domElement) return;
          Fe.removeTickerListener();
          const e = this.domElement.style;
          e &&
            (globalThis.navigator.msPointerEnabled
              ? ((e.msContentZooming = ''), (e.msTouchAction = ''))
              : this.supportsPointerEvents && (e.touchAction = '')),
            this.supportsPointerEvents
              ? (globalThis.document.removeEventListener('pointermove', this._onPointerMove, !0),
                this.domElement.removeEventListener('pointerdown', this._onPointerDown, !0),
                this.domElement.removeEventListener('pointerleave', this._onPointerOverOut, !0),
                this.domElement.removeEventListener('pointerover', this._onPointerOverOut, !0),
                globalThis.removeEventListener('pointerup', this._onPointerUp, !0))
              : (globalThis.document.removeEventListener('mousemove', this._onPointerMove, !0),
                this.domElement.removeEventListener('mousedown', this._onPointerDown, !0),
                this.domElement.removeEventListener('mouseout', this._onPointerOverOut, !0),
                this.domElement.removeEventListener('mouseover', this._onPointerOverOut, !0),
                globalThis.removeEventListener('mouseup', this._onPointerUp, !0),
                this.supportsTouchEvents &&
                (this.domElement.removeEventListener('touchstart', this._onPointerDown, !0),
                  this.domElement.removeEventListener('touchend', this._onPointerUp, !0),
                  this.domElement.removeEventListener('touchmove', this._onPointerMove, !0))),
            this.domElement.removeEventListener('wheel', this.onWheel, !0),
            (this.domElement = null),
            (this._eventsAdded = !1);
        }
        mapPositionToPoint(e, t, A) {
          const r = this.domElement.isConnected
            ? this.domElement.getBoundingClientRect()
            : { width: this.domElement.width, height: this.domElement.height, left: 0, top: 0 },
            s = 1 / this.resolution;
          (e.x = (t - r.left) * (this.domElement.width / r.width) * s),
            (e.y = (A - r.top) * (this.domElement.height / r.height) * s);
        }
        _normalizeToPointerData(e) {
          const t = [];
          if (this.supportsTouchEvents && e instanceof TouchEvent)
            for (let A = 0, r = e.changedTouches.length; A < r; A++) {
              const s = e.changedTouches[A];
              typeof s.button > 'u' && (s.button = 0),
                typeof s.buttons > 'u' && (s.buttons = 1),
                typeof s.isPrimary > 'u' && (s.isPrimary = e.touches.length === 1 && e.type === 'touchstart'),
                typeof s.width > 'u' && (s.width = s.radiusX || 1),
                typeof s.height > 'u' && (s.height = s.radiusY || 1),
                typeof s.tiltX > 'u' && (s.tiltX = 0),
                typeof s.tiltY > 'u' && (s.tiltY = 0),
                typeof s.pointerType > 'u' && (s.pointerType = 'touch'),
                typeof s.pointerId > 'u' && (s.pointerId = s.identifier || 0),
                typeof s.pressure > 'u' && (s.pressure = s.force || 0.5),
                typeof s.twist > 'u' && (s.twist = 0),
                typeof s.tangentialPressure > 'u' && (s.tangentialPressure = 0),
                typeof s.layerX > 'u' && (s.layerX = s.offsetX = s.clientX),
                typeof s.layerY > 'u' && (s.layerY = s.offsetY = s.clientY),
                (s.isNormalized = !0),
                (s.type = e.type),
                t.push(s);
            }
          else if (
            !globalThis.MouseEvent ||
            (e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent)))
          ) {
            const A = e;
            typeof A.isPrimary > 'u' && (A.isPrimary = !0),
              typeof A.width > 'u' && (A.width = 1),
              typeof A.height > 'u' && (A.height = 1),
              typeof A.tiltX > 'u' && (A.tiltX = 0),
              typeof A.tiltY > 'u' && (A.tiltY = 0),
              typeof A.pointerType > 'u' && (A.pointerType = 'mouse'),
              typeof A.pointerId > 'u' && (A.pointerId = $m),
              typeof A.pressure > 'u' && (A.pressure = 0.5),
              typeof A.twist > 'u' && (A.twist = 0),
              typeof A.tangentialPressure > 'u' && (A.tangentialPressure = 0),
              (A.isNormalized = !0),
              t.push(A);
          } else t.push(e);
          return t;
        }
        normalizeWheelEvent(e) {
          const t = this._rootWheelEvent;
          return (
            this._transferMouseData(t, e),
            (t.deltaX = e.deltaX),
            (t.deltaY = e.deltaY),
            (t.deltaZ = e.deltaZ),
            (t.deltaMode = e.deltaMode),
            this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
            t.global.copyFrom(t.screen),
            t.offset.copyFrom(t.screen),
            (t.nativeEvent = e),
            (t.type = e.type),
            t
          );
        }
        _bootstrapEvent(e, t) {
          return (
            (e.originalEvent = null),
            (e.nativeEvent = t),
            (e.pointerId = t.pointerId),
            (e.width = t.width),
            (e.height = t.height),
            (e.isPrimary = t.isPrimary),
            (e.pointerType = t.pointerType),
            (e.pressure = t.pressure),
            (e.tangentialPressure = t.tangentialPressure),
            (e.tiltX = t.tiltX),
            (e.tiltY = t.tiltY),
            (e.twist = t.twist),
            this._transferMouseData(e, t),
            this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
            e.global.copyFrom(e.screen),
            e.offset.copyFrom(e.screen),
            (e.isTrusted = t.isTrusted),
            e.type === 'pointerleave' && (e.type = 'pointerout'),
            e.type.startsWith('mouse') && (e.type = e.type.replace('mouse', 'pointer')),
            e.type.startsWith('touch') && (e.type = eS[e.type] || e.type),
            e
          );
        }
        _transferMouseData(e, t) {
          (e.isTrusted = t.isTrusted),
            (e.srcElement = t.srcElement),
            (e.timeStamp = performance.now()),
            (e.type = t.type),
            (e.altKey = t.altKey),
            (e.button = t.button),
            (e.buttons = t.buttons),
            (e.client.x = t.clientX),
            (e.client.y = t.clientY),
            (e.ctrlKey = t.ctrlKey),
            (e.metaKey = t.metaKey),
            (e.movement.x = t.movementX),
            (e.movement.y = t.movementY),
            (e.page.x = t.pageX),
            (e.page.y = t.pageY),
            (e.relatedTarget = null),
            (e.shiftKey = t.shiftKey);
        }
      };
    Qn.extension = { name: 'events', type: [M.WebGLSystem, M.CanvasSystem, M.WebGPUSystem], priority: -1 };
    Qn.defaultEventFeatures = { move: !0, globalMove: !0, click: !0, wheel: !0 };
    let wn = Qn;
    const Yu = {
      onclick: null,
      onmousedown: null,
      onmouseenter: null,
      onmouseleave: null,
      onmousemove: null,
      onglobalmousemove: null,
      onmouseout: null,
      onmouseover: null,
      onmouseup: null,
      onmouseupoutside: null,
      onpointercancel: null,
      onpointerdown: null,
      onpointerenter: null,
      onpointerleave: null,
      onpointermove: null,
      onglobalpointermove: null,
      onpointerout: null,
      onpointerover: null,
      onpointertap: null,
      onpointerup: null,
      onpointerupoutside: null,
      onrightclick: null,
      onrightdown: null,
      onrightup: null,
      onrightupoutside: null,
      ontap: null,
      ontouchcancel: null,
      ontouchend: null,
      ontouchendoutside: null,
      ontouchmove: null,
      onglobaltouchmove: null,
      ontouchstart: null,
      onwheel: null,
      get interactive() {
        return this.eventMode === 'dynamic' || this.eventMode === 'static';
      },
      set interactive(i) {
        this.eventMode = i ? 'static' : 'passive';
      },
      _internalEventMode: void 0,
      get eventMode() {
        return this._internalEventMode ?? wn.defaultEventMode;
      },
      set eventMode(i) {
        this._internalEventMode = i;
      },
      isInteractive() {
        return this.eventMode === 'static' || this.eventMode === 'dynamic';
      },
      interactiveChildren: !0,
      hitArea: null,
      addEventListener(i, e, t) {
        const A = (typeof t == 'boolean' && t) || (typeof t == 'object' && t.capture),
          r = typeof t == 'object' ? t.signal : void 0,
          s = typeof t == 'object' ? t.once === !0 : !1,
          n = typeof e == 'function' ? void 0 : e;
        i = A ? `${i}capture` : i;
        const a = typeof e == 'function' ? e : e.handleEvent,
          l = this;
        r &&
          r.addEventListener('abort', () => {
            l.off(i, a, n);
          }),
          s ? l.once(i, a, n) : l.on(i, a, n);
      },
      removeEventListener(i, e, t) {
        const A = (typeof t == 'boolean' && t) || (typeof t == 'object' && t.capture),
          r = typeof e == 'function' ? void 0 : e;
        (i = A ? `${i}capture` : i), (e = typeof e == 'function' ? e : e.handleEvent), this.off(i, e, r);
      },
      dispatchEvent(i) {
        if (!(i instanceof iA)) throw new Error('Container cannot propagate events outside of the Federated Events API');
        return (i.defaultPrevented = !1), (i.path = null), (i.target = this), i.manager.dispatchEvent(i), !i.defaultPrevented;
      },
    };
    var Du = `in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,
      Ou = `in vec2 vTextureCoord;
out vec4 finalColor;
uniform sampler2D uTexture;
void main() {
    finalColor = texture(uTexture, vTextureCoord);
}
`,
      Ns = `struct GlobalFilterUniforms {
  uInputSize: vec4<f32>,
  uInputPixel: vec4<f32>,
  uInputClamp: vec4<f32>,
  uOutputFrame: vec4<f32>,
  uGlobalFrame: vec4<f32>,
  uOutputTexture: vec4<f32>,
};

@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler: sampler;

struct VSOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) uv: vec2<f32>
};

fn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

@vertex
fn mainVertex(
  @location(0) aPosition: vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
) -> @location(0) vec4<f32> {
    return textureSample(uTexture, uSampler, uv);
}
`;
    class Lu extends on {
      constructor() {
        const e = it.from({
          vertex: { source: Ns, entryPoint: 'mainVertex' },
          fragment: { source: Ns, entryPoint: 'mainFragment' },
          name: 'passthrough-filter',
        }),
          t = dt.from({ vertex: Du, fragment: Ou, name: 'passthrough-filter' });
        super({ gpuProgram: e, glProgram: t });
      }
    }
    class Pn {
      constructor(e) {
        this._renderer = e;
      }
      push(e, t, A) {
        this._renderer.renderPipes.batch.break(A),
          A.add({ renderPipeId: 'filter', canBundle: !1, action: 'pushFilter', container: t, filterEffect: e });
      }
      pop(e, t, A) {
        this._renderer.renderPipes.batch.break(A), A.add({ renderPipeId: 'filter', action: 'popFilter', canBundle: !1 });
      }
      execute(e) {
        e.action === 'pushFilter' ? this._renderer.filter.push(e) : e.action === 'popFilter' && this._renderer.filter.pop();
      }
      destroy() {
        this._renderer = null;
      }
    }
    Pn.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'filter' };
    function Qs(i, e, t, A, r, s, n, a) {
      const l = n - t,
        h = a - A,
        u = r - t,
        o = s - A,
        c = i - t,
        d = e - A,
        f = l * l + h * h,
        g = l * u + h * o,
        p = l * c + h * d,
        m = u * u + o * o,
        S = u * c + o * d,
        q = 1 / (f * m - g * g),
        E = (m * p - g * S) * q,
        b = (f * S - g * p) * q;
      return E >= 0 && b >= 0 && E + b < 1;
    }
    const Vl = new R();
    function ju(i, e) {
      e.clear();
      const t = e.matrix;
      for (let A = 0; A < i.length; A++) {
        const r = i[A];
        if (r.globalDisplayStatus < 7) continue;
        const s = r.renderGroup ?? r.parentRenderGroup;
        s?.isCachedAsTexture
          ? (e.matrix = Vl.copyFrom(s.textureOffsetInverseTransform).append(r.worldTransform))
          : s?._parentCacheAsTextureRenderGroup
            ? (e.matrix = Vl.copyFrom(s._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(r.groupTransform))
            : (e.matrix = r.worldTransform),
          e.addBounds(r.bounds);
      }
      return (e.matrix = t), e;
    }
    const tS = new Bt({
      attributes: {
        aPosition: { buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), format: 'float32x2', stride: 8, offset: 0 },
      },
      indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),
    });
    class AS {
      constructor() {
        (this.skip = !1),
          (this.inputTexture = null),
          (this.backTexture = null),
          (this.filters = null),
          (this.bounds = new de()),
          (this.container = null),
          (this.blendRequired = !1),
          (this.outputRenderSurface = null),
          (this.globalFrame = { x: 0, y: 0, width: 0, height: 0 }),
          (this.firstEnabledIndex = -1),
          (this.lastEnabledIndex = -1);
      }
    }
    class Jn {
      constructor(e) {
        (this._filterStackIndex = 0),
          (this._filterStack = []),
          (this._filterGlobalUniforms = new qe({
            uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },
            uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },
            uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },
            uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },
            uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },
            uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },
          })),
          (this._globalFilterBindGroup = new Le({})),
          (this.renderer = e);
      }
      get activeBackTexture() {
        return this._activeFilterData?.backTexture;
      }
      push(e) {
        const t = this.renderer,
          A = e.filterEffect.filters,
          r = this._pushFilterData();
        (r.skip = !1), (r.filters = A), (r.container = e.container), (r.outputRenderSurface = t.renderTarget.renderSurface);
        const s = t.renderTarget.renderTarget.colorTexture.source,
          n = s.resolution,
          a = s.antialias;
        if (A.every((d) => !d.enabled)) {
          r.skip = !0;
          return;
        }
        const l = r.bounds;
        if ((this._calculateFilterArea(e, l), this._calculateFilterBounds(r, t.renderTarget.rootViewPort, a, n, 1), r.skip))
          return;
        const h = this._getPreviousFilterData(),
          u = this._findFilterResolution(n);
        let o = 0,
          c = 0;
        h && ((o = h.bounds.minX), (c = h.bounds.minY)),
          this._calculateGlobalFrame(r, o, c, u, s.width, s.height),
          this._setupFilterTextures(r, l, t, h);
      }
      generateFilteredTexture({ texture: e, filters: t }) {
        const A = this._pushFilterData();
        (this._activeFilterData = A), (A.skip = !1), (A.filters = t);
        const r = e.source,
          s = r.resolution,
          n = r.antialias;
        if (t.every((d) => !d.enabled)) return (A.skip = !0), e;
        const a = A.bounds;
        if ((a.addRect(e.frame), this._calculateFilterBounds(A, a.rectangle, n, s, 0), A.skip)) return e;
        const l = s;
        this._calculateGlobalFrame(A, 0, 0, l, r.width, r.height),
          (A.outputRenderSurface = ce.getOptimalTexture(a.width, a.height, A.resolution, A.antialias)),
          (A.backTexture = v.EMPTY),
          (A.inputTexture = e),
          this.renderer.renderTarget.finishRenderPass(),
          this._applyFiltersToTexture(A, !0);
        const c = A.outputRenderSurface;
        return (c.source.alphaMode = 'premultiplied-alpha'), c;
      }
      pop() {
        const e = this.renderer,
          t = this._popFilterData();
        t.skip ||
          (e.globalUniforms.pop(),
            e.renderTarget.finishRenderPass(),
            (this._activeFilterData = t),
            this._applyFiltersToTexture(t, !1),
            t.blendRequired && ce.returnTexture(t.backTexture),
            ce.returnTexture(t.inputTexture));
      }
      getBackTexture(e, t, A) {
        const r = e.colorTexture.source._resolution,
          s = ce.getOptimalTexture(t.width, t.height, r, !1);
        let n = t.minX,
          a = t.minY;
        A && ((n -= A.minX), (a -= A.minY)), (n = Math.floor(n * r)), (a = Math.floor(a * r));
        const l = Math.ceil(t.width * r),
          h = Math.ceil(t.height * r);
        return this.renderer.renderTarget.copyToTexture(e, s, { x: n, y: a }, { width: l, height: h }, { x: 0, y: 0 }), s;
      }
      applyFilter(e, t, A, r) {
        const s = this.renderer,
          n = this._activeFilterData,
          l = n.outputRenderSurface === A,
          h = s.renderTarget.rootRenderTarget.colorTexture.source._resolution,
          u = this._findFilterResolution(h);
        let o = 0,
          c = 0;
        if (l) {
          const f = this._findPreviousFilterOffset();
          (o = f.x), (c = f.y);
        }
        this._updateFilterUniforms(t, A, n, o, c, u, l, r);
        const d = e.enabled ? e : this._getPassthroughFilter();
        this._setupBindGroupsAndRender(d, t, s);
      }
      calculateSpriteMatrix(e, t) {
        const A = this._activeFilterData,
          r = e.set(A.inputTexture._source.width, 0, 0, A.inputTexture._source.height, A.bounds.minX, A.bounds.minY),
          s = t.worldTransform.copyTo(R.shared),
          n = t.renderGroup || t.parentRenderGroup;
        return (
          n && n.cacheToLocalTransform && s.prepend(n.cacheToLocalTransform),
          s.invert(),
          r.prepend(s),
          r.scale(1 / t.texture.orig.width, 1 / t.texture.orig.height),
          r.translate(t.anchor.x, t.anchor.y),
          r
        );
      }
      destroy() {
        this._passthroughFilter?.destroy(!0), (this._passthroughFilter = null);
      }
      _getPassthroughFilter() {
        return this._passthroughFilter ?? (this._passthroughFilter = new Lu()), this._passthroughFilter;
      }
      _setupBindGroupsAndRender(e, t, A) {
        if (A.renderPipes.uniformBatch) {
          const r = A.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
          this._globalFilterBindGroup.setResource(r, 0);
        } else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
        this._globalFilterBindGroup.setResource(t.source, 1),
          this._globalFilterBindGroup.setResource(t.source.style, 2),
          (e.groups[0] = this._globalFilterBindGroup),
          A.encoder.draw({ geometry: tS, shader: e, state: e._state, topology: 'triangle-list' }),
          A.type === we.WEBGL && A.renderTarget.finishRenderPass();
      }
      _setupFilterTextures(e, t, A, r) {
        if (
          ((e.backTexture = v.EMPTY),
            (e.inputTexture = ce.getOptimalTexture(t.width, t.height, e.resolution, e.antialias)),
            e.blendRequired)
        ) {
          A.renderTarget.finishRenderPass();
          const s = A.renderTarget.getRenderTarget(e.outputRenderSurface);
          e.backTexture = this.getBackTexture(s, t, r?.bounds);
        }
        A.renderTarget.bind(e.inputTexture, !0), A.globalUniforms.push({ offset: t });
      }
      _calculateGlobalFrame(e, t, A, r, s, n) {
        const a = e.globalFrame;
        (a.x = t * r), (a.y = A * r), (a.width = s * r), (a.height = n * r);
      }
      _updateFilterUniforms(e, t, A, r, s, n, a, l) {
        const h = this._filterGlobalUniforms.uniforms,
          u = h.uOutputFrame,
          o = h.uInputSize,
          c = h.uInputPixel,
          d = h.uInputClamp,
          f = h.uGlobalFrame,
          g = h.uOutputTexture;
        a ? ((u[0] = A.bounds.minX - r), (u[1] = A.bounds.minY - s)) : ((u[0] = 0), (u[1] = 0)),
          (u[2] = e.frame.width),
          (u[3] = e.frame.height),
          (o[0] = e.source.width),
          (o[1] = e.source.height),
          (o[2] = 1 / o[0]),
          (o[3] = 1 / o[1]),
          (c[0] = e.source.pixelWidth),
          (c[1] = e.source.pixelHeight),
          (c[2] = 1 / c[0]),
          (c[3] = 1 / c[1]),
          (d[0] = 0.5 * c[2]),
          (d[1] = 0.5 * c[3]),
          (d[2] = e.frame.width * o[2] - 0.5 * c[2]),
          (d[3] = e.frame.height * o[3] - 0.5 * c[3]);
        const p = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        (f[0] = r * n),
          (f[1] = s * n),
          (f[2] = p.source.width * n),
          (f[3] = p.source.height * n),
          t instanceof v && (t.source.resource = null);
        const m = this.renderer.renderTarget.getRenderTarget(t);
        this.renderer.renderTarget.bind(t, !!l),
          t instanceof v ? ((g[0] = t.frame.width), (g[1] = t.frame.height)) : ((g[0] = m.width), (g[1] = m.height)),
          (g[2] = m.isRoot ? -1 : 1),
          this._filterGlobalUniforms.update();
      }
      _findFilterResolution(e) {
        let t = this._filterStackIndex - 1;
        for (; t > 0 && this._filterStack[t].skip;) --t;
        return t > 0 && this._filterStack[t].inputTexture ? this._filterStack[t].inputTexture.source._resolution : e;
      }
      _findPreviousFilterOffset() {
        let e = 0,
          t = 0,
          A = this._filterStackIndex;
        for (; A > 0;) {
          A--;
          const r = this._filterStack[A];
          if (!r.skip) {
            (e = r.bounds.minX), (t = r.bounds.minY);
            break;
          }
        }
        return { x: e, y: t };
      }
      _calculateFilterArea(e, t) {
        if (
          (e.renderables
            ? ju(e.renderables, t)
            : e.filterEffect.filterArea
              ? (t.clear(), t.addRect(e.filterEffect.filterArea), t.applyMatrix(e.container.worldTransform))
              : e.container.getFastGlobalBounds(!0, t),
            e.container)
        ) {
          const r = (e.container.renderGroup || e.container.parentRenderGroup).cacheToLocalTransform;
          r && t.applyMatrix(r);
        }
      }
      _applyFiltersToTexture(e, t) {
        const A = e.inputTexture,
          r = e.bounds,
          s = e.filters,
          n = e.firstEnabledIndex,
          a = e.lastEnabledIndex;
        if (
          (this._globalFilterBindGroup.setResource(A.source.style, 2),
            this._globalFilterBindGroup.setResource(e.backTexture.source, 3),
            n === a)
        )
          s[n].apply(this, A, e.outputRenderSurface, t);
        else {
          let l = e.inputTexture;
          const h = ce.getOptimalTexture(r.width, r.height, l.source._resolution, !1);
          let u = h;
          for (let o = n; o < a; o++) {
            const c = s[o];
            if (!c.enabled) continue;
            c.apply(this, l, u, !0);
            const d = l;
            (l = u), (u = d);
          }
          s[a].apply(this, l, e.outputRenderSurface, t), ce.returnTexture(h);
        }
      }
      _calculateFilterBounds(e, t, A, r, s) {
        const n = this.renderer,
          a = e.bounds,
          l = e.filters;
        let h = 1 / 0,
          u = 0,
          o = !0,
          c = !1,
          d = !1,
          f = !0,
          g = -1,
          p = -1;
        for (let m = 0; m < l.length; m++) {
          const S = l[m];
          if (!S.enabled) continue;
          if (
            (g === -1 && (g = m),
              (p = m),
              (h = Math.min(h, S.resolution === 'inherit' ? r : S.resolution)),
              (u += S.padding),
              S.antialias === 'off' ? (o = !1) : S.antialias === 'inherit' && o && (o = A),
              S.clipToViewport || (f = !1),
              !!!(S.compatibleRenderers & n.type))
          ) {
            d = !1;
            break;
          }
          if (S.blendRequired && !(n.backBuffer?.useBackBuffer ?? !0)) {
            N(
              'Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.'
            ),
              (d = !1);
            break;
          }
          (d = !0), c || (c = S.blendRequired);
        }
        if (!d) {
          e.skip = !0;
          return;
        }
        if (
          (f && a.fitBounds(0, t.width / r, 0, t.height / r),
            a
              .scale(h)
              .ceil()
              .scale(1 / h)
              .pad((u | 0) * s),
            !a.isPositive)
        ) {
          e.skip = !0;
          return;
        }
        (e.antialias = o), (e.resolution = h), (e.blendRequired = c), (e.firstEnabledIndex = g), (e.lastEnabledIndex = p);
      }
      _popFilterData() {
        return this._filterStackIndex--, this._filterStack[this._filterStackIndex];
      }
      _getPreviousFilterData() {
        let e,
          t = this._filterStackIndex - 1;
        for (; t > 0 && (t--, (e = this._filterStack[t]), !!e.skip););
        return e;
      }
      _pushFilterData() {
        let e = this._filterStack[this._filterStackIndex];
        return e || (e = this._filterStack[this._filterStackIndex] = new AS()), this._filterStackIndex++, e;
      }
    }
    Jn.extension = { type: [M.WebGLSystem, M.WebGPUSystem], name: 'filter' };
    var Zu = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`,
      Xu = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,
      ws = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
    class Hu extends on {
      constructor(e) {
        const { sprite: t, ...A } = e,
          r = new Os(t.texture),
          s = new qe({
            uFilterMatrix: { value: new R(), type: 'mat3x3<f32>' },
            uMaskClamp: { value: r.uClampFrame, type: 'vec4<f32>' },
            uAlpha: { value: 1, type: 'f32' },
            uInverse: { value: e.inverse ? 1 : 0, type: 'f32' },
          }),
          n = it.from({
            vertex: { source: ws, entryPoint: 'mainVertex' },
            fragment: { source: ws, entryPoint: 'mainFragment' },
          }),
          a = dt.from({ vertex: Xu, fragment: Zu, name: 'mask-filter' });
        super({
          ...A,
          gpuProgram: n,
          glProgram: a,
          clipToViewport: !1,
          resources: { filterUniforms: s, uMaskTexture: t.texture.source },
        }),
          (this.sprite = t),
          (this._textureMatrix = r);
      }
      set inverse(e) {
        this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0;
      }
      get inverse() {
        return this.resources.filterUniforms.uniforms.uInverse === 1;
      }
      apply(e, t, A, r) {
        (this._textureMatrix.texture = this.sprite.texture),
          e
            .calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite)
            .prepend(this._textureMatrix.mapCoord),
          (this.resources.uMaskTexture = this.sprite.texture.source),
          e.applyFilter(this, t, A, r);
      }
    }
    class Ut extends HA {
      constructor(e) {
        e instanceof Ce && (e = { context: e });
        const { context: t, roundPixels: A, ...r } = e || {};
        super({ label: 'Graphics', ...r }),
          (this.renderPipeId = 'graphics'),
          t ? (this._context = t) : (this._context = this._ownedContext = new Ce()),
          this._context.on('update', this.onViewUpdate, this),
          (this.didViewUpdate = !0),
          (this.allowChildren = !1),
          (this.roundPixels = A ?? !1);
      }
      set context(e) {
        e !== this._context &&
          (this._context.off('update', this.onViewUpdate, this),
            (this._context = e),
            this._context.on('update', this.onViewUpdate, this),
            this.onViewUpdate());
      }
      get context() {
        return this._context;
      }
      get bounds() {
        return this._context.bounds;
      }
      updateBounds() { }
      containsPoint(e) {
        return this._context.containsPoint(e);
      }
      destroy(e) {
        this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === !0 || e?.context === !0) && this._context.destroy(e),
          (this._ownedContext = null),
          (this._context = null),
          super.destroy(e);
      }
      _callContextMethod(e, t) {
        return this.context[e](...t), this;
      }
      setFillStyle(...e) {
        return this._callContextMethod('setFillStyle', e);
      }
      setStrokeStyle(...e) {
        return this._callContextMethod('setStrokeStyle', e);
      }
      fill(...e) {
        return this._callContextMethod('fill', e);
      }
      stroke(...e) {
        return this._callContextMethod('stroke', e);
      }
      texture(...e) {
        return this._callContextMethod('texture', e);
      }
      beginPath() {
        return this._callContextMethod('beginPath', []);
      }
      cut() {
        return this._callContextMethod('cut', []);
      }
      arc(...e) {
        return this._callContextMethod('arc', e);
      }
      arcTo(...e) {
        return this._callContextMethod('arcTo', e);
      }
      arcToSvg(...e) {
        return this._callContextMethod('arcToSvg', e);
      }
      bezierCurveTo(...e) {
        return this._callContextMethod('bezierCurveTo', e);
      }
      closePath() {
        return this._callContextMethod('closePath', []);
      }
      ellipse(...e) {
        return this._callContextMethod('ellipse', e);
      }
      circle(...e) {
        return this._callContextMethod('circle', e);
      }
      path(...e) {
        return this._callContextMethod('path', e);
      }
      lineTo(...e) {
        return this._callContextMethod('lineTo', e);
      }
      moveTo(...e) {
        return this._callContextMethod('moveTo', e);
      }
      quadraticCurveTo(...e) {
        return this._callContextMethod('quadraticCurveTo', e);
      }
      rect(...e) {
        return this._callContextMethod('rect', e);
      }
      roundRect(...e) {
        return this._callContextMethod('roundRect', e);
      }
      poly(...e) {
        return this._callContextMethod('poly', e);
      }
      regularPoly(...e) {
        return this._callContextMethod('regularPoly', e);
      }
      roundPoly(...e) {
        return this._callContextMethod('roundPoly', e);
      }
      roundShape(...e) {
        return this._callContextMethod('roundShape', e);
      }
      filletRect(...e) {
        return this._callContextMethod('filletRect', e);
      }
      chamferRect(...e) {
        return this._callContextMethod('chamferRect', e);
      }
      star(...e) {
        return this._callContextMethod('star', e);
      }
      svg(...e) {
        return this._callContextMethod('svg', e);
      }
      restore(...e) {
        return this._callContextMethod('restore', e);
      }
      save() {
        return this._callContextMethod('save', []);
      }
      getTransform() {
        return this.context.getTransform();
      }
      resetTransform() {
        return this._callContextMethod('resetTransform', []);
      }
      rotateTransform(...e) {
        return this._callContextMethod('rotate', e);
      }
      scaleTransform(...e) {
        return this._callContextMethod('scale', e);
      }
      setTransform(...e) {
        return this._callContextMethod('setTransform', e);
      }
      transform(...e) {
        return this._callContextMethod('transform', e);
      }
      translateTransform(...e) {
        return this._callContextMethod('translate', e);
      }
      clear() {
        return this._callContextMethod('clear', []);
      }
      get fillStyle() {
        return this._context.fillStyle;
      }
      set fillStyle(e) {
        this._context.fillStyle = e;
      }
      get strokeStyle() {
        return this._context.strokeStyle;
      }
      set strokeStyle(e) {
        this._context.strokeStyle = e;
      }
      clone(e = !1) {
        return e ? new Ut(this._context.clone()) : ((this._ownedContext = null), new Ut(this._context));
      }
      lineStyle(e, t, A) {
        P(W, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');
        const r = {};
        return e && (r.width = e), t && (r.color = t), A && (r.alpha = A), (this.context.strokeStyle = r), this;
      }
      beginFill(e, t) {
        P(W, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');
        const A = {};
        return e !== void 0 && (A.color = e), t !== void 0 && (A.alpha = t), (this.context.fillStyle = A), this;
      }
      endFill() {
        P(W, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.'),
          this.context.fill();
        const e = this.context.strokeStyle;
        return (
          (e.width !== Ce.defaultStrokeStyle.width ||
            e.color !== Ce.defaultStrokeStyle.color ||
            e.alpha !== Ce.defaultStrokeStyle.alpha) &&
          this.context.stroke(),
          this
        );
      }
      drawCircle(...e) {
        return P(W, 'Graphics#drawCircle has been renamed to Graphics#circle'), this._callContextMethod('circle', e);
      }
      drawEllipse(...e) {
        return P(W, 'Graphics#drawEllipse has been renamed to Graphics#ellipse'), this._callContextMethod('ellipse', e);
      }
      drawPolygon(...e) {
        return P(W, 'Graphics#drawPolygon has been renamed to Graphics#poly'), this._callContextMethod('poly', e);
      }
      drawRect(...e) {
        return P(W, 'Graphics#drawRect has been renamed to Graphics#rect'), this._callContextMethod('rect', e);
      }
      drawRoundedRect(...e) {
        return P(W, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect'), this._callContextMethod('roundRect', e);
      }
      drawStar(...e) {
        return P(W, 'Graphics#drawStar has been renamed to Graphics#star'), this._callContextMethod('star', e);
      }
    }
    const zu = class _u extends Bt {
      constructor(...e) {
        let t = e[0] ?? {};
        t instanceof Float32Array &&
          (P(W, 'use new MeshGeometry({ positions, uvs, indices }) instead'), (t = { positions: t, uvs: e[1], indices: e[2] })),
          (t = { ..._u.defaultOptions, ...t });
        const A = t.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        let r = t.uvs;
        r || (t.positions ? (r = new Float32Array(A.length)) : (r = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])));
        const s = t.indices || new Uint32Array([0, 1, 2, 0, 2, 3]),
          n = t.shrinkBuffersToFit,
          a = new be({ data: A, label: 'attribute-mesh-positions', shrinkToFit: n, usage: K.VERTEX | K.COPY_DST }),
          l = new be({ data: r, label: 'attribute-mesh-uvs', shrinkToFit: n, usage: K.VERTEX | K.COPY_DST }),
          h = new be({ data: s, label: 'index-mesh-buffer', shrinkToFit: n, usage: K.INDEX | K.COPY_DST });
        super({
          attributes: {
            aPosition: { buffer: a, format: 'float32x2', stride: 8, offset: 0 },
            aUV: { buffer: l, format: 'float32x2', stride: 8, offset: 0 },
          },
          indexBuffer: h,
          topology: t.topology,
        }),
          (this.batchMode = 'auto');
      }
      get positions() {
        return this.attributes.aPosition.buffer.data;
      }
      set positions(e) {
        this.attributes.aPosition.buffer.data = e;
      }
      get uvs() {
        return this.attributes.aUV.buffer.data;
      }
      set uvs(e) {
        this.attributes.aUV.buffer.data = e;
      }
      get indices() {
        return this.indexBuffer.data;
      }
      set indices(e) {
        this.indexBuffer.data = e;
      }
    };
    zu.defaultOptions = { topology: 'triangle-list', shrinkBuffersToFit: !1 };
    let oA = zu;
    class $u extends HA {
      constructor(...e) {
        let t = e[0];
        t instanceof Bt &&
          (P(W, 'Mesh: use new Mesh({ geometry, shader }) instead'),
            (t = { geometry: t, shader: e[1] }),
            e[3] &&
            (P(W, 'Mesh: drawMode argument has been removed, use geometry.topology instead'), (t.geometry.topology = e[3])));
        const { geometry: A, shader: r, texture: s, roundPixels: n, state: a, ...l } = t;
        super({ label: 'Mesh', ...l }),
          (this.renderPipeId = 'mesh'),
          (this._shader = null),
          (this.allowChildren = !1),
          (this.shader = r ?? null),
          (this.texture = s ?? r?.texture ?? v.WHITE),
          (this.state = a ?? Ue.for2d()),
          (this._geometry = A),
          this._geometry.on('update', this.onViewUpdate, this),
          (this.roundPixels = n ?? !1);
      }
      get material() {
        return P(W, 'mesh.material property has been removed, use mesh.shader instead'), this._shader;
      }
      set shader(e) {
        this._shader !== e && ((this._shader = e), this.onViewUpdate());
      }
      get shader() {
        return this._shader;
      }
      set geometry(e) {
        this._geometry !== e &&
          (this._geometry?.off('update', this.onViewUpdate, this),
            e.on('update', this.onViewUpdate, this),
            (this._geometry = e),
            this.onViewUpdate());
      }
      get geometry() {
        return this._geometry;
      }
      set texture(e) {
        e || (e = v.EMPTY);
        const t = this._texture;
        t !== e &&
          (t && t.dynamic && t.off('update', this.onViewUpdate, this),
            e.dynamic && e.on('update', this.onViewUpdate, this),
            this.shader && (this.shader.texture = e),
            (this._texture = e),
            this.onViewUpdate());
      }
      get texture() {
        return this._texture;
      }
      get batched() {
        return this._shader || (this.state.data & 12) !== 0
          ? !1
          : this._geometry instanceof oA
            ? this._geometry.batchMode === 'auto'
              ? this._geometry.positions.length / 2 <= 100
              : this._geometry.batchMode === 'batch'
            : !1;
      }
      get bounds() {
        return this._geometry.bounds;
      }
      updateBounds() {
        this._bounds = this._geometry.bounds;
      }
      containsPoint(e) {
        const { x: t, y: A } = e;
        if (!this.bounds.containsPoint(t, A)) return !1;
        const r = this.geometry.getBuffer('aPosition').data,
          s = this.geometry.topology === 'triangle-strip' ? 3 : 1;
        if (this.geometry.getIndex()) {
          const n = this.geometry.getIndex().data,
            a = n.length;
          for (let l = 0; l + 2 < a; l += s) {
            const h = n[l] * 2,
              u = n[l + 1] * 2,
              o = n[l + 2] * 2;
            if (Qs(t, A, r[h], r[h + 1], r[u], r[u + 1], r[o], r[o + 1])) return !0;
          }
        } else {
          const n = r.length / 2;
          for (let a = 0; a + 2 < n; a += s) {
            const l = a * 2,
              h = (a + 1) * 2,
              u = (a + 2) * 2;
            if (Qs(t, A, r[l], r[l + 1], r[h], r[h + 1], r[u], r[u + 1])) return !0;
          }
        }
        return !1;
      }
      destroy(e) {
        if ((super.destroy(e), typeof e == 'boolean' ? e : e?.texture)) {
          const A = typeof e == 'boolean' ? e : e?.textureSource;
          this._texture.destroy(A);
        }
        this._geometry?.off('update', this.onViewUpdate, this),
          (this._texture = null),
          (this._geometry = null),
          (this._shader = null),
          (this._gpuData = null);
      }
    }
    class AA extends re {
      constructor(...e) {
        let t = e[0];
        Array.isArray(e[0]) && (t = { textures: e[0], autoUpdate: e[1] });
        const {
          animationSpeed: A = 1,
          autoPlay: r = !1,
          autoUpdate: s = !0,
          loop: n = !0,
          onComplete: a = null,
          onFrameChange: l = null,
          onLoop: h = null,
          textures: u,
          updateAnchor: o = !1,
          ...c
        } = t,
          [d] = u;
        super({ ...c, texture: d instanceof v ? d : d.texture }),
          (this._textures = null),
          (this._durations = null),
          (this._autoUpdate = s),
          (this._isConnectedToTicker = !1),
          (this.animationSpeed = A),
          (this.loop = n),
          (this.updateAnchor = o),
          (this.onComplete = a),
          (this.onFrameChange = l),
          (this.onLoop = h),
          (this._currentTime = 0),
          (this._playing = !1),
          (this._previousFrame = null),
          (this.textures = u),
          r && this.play();
      }
      stop() {
        this._playing &&
          ((this._playing = !1),
            this._autoUpdate &&
            this._isConnectedToTicker &&
            (ue.shared.remove(this.update, this), (this._isConnectedToTicker = !1)));
      }
      play() {
        this._playing ||
          ((this._playing = !0),
            this._autoUpdate &&
            !this._isConnectedToTicker &&
            (ue.shared.add(this.update, this, ut.HIGH), (this._isConnectedToTicker = !0)));
      }
      gotoAndStop(e) {
        this.stop(), (this.currentFrame = e);
      }
      gotoAndPlay(e) {
        (this.currentFrame = e), this.play();
      }
      update(e) {
        if (!this._playing) return;
        const t = e.deltaTime,
          A = this.animationSpeed * t,
          r = this.currentFrame;
        if (this._durations !== null) {
          let s = (this._currentTime % 1) * this._durations[this.currentFrame];
          for (s += (A / 60) * 1e3; s < 0;) this._currentTime--, (s += this._durations[this.currentFrame]);
          const n = Math.sign(this.animationSpeed * t);
          for (this._currentTime = Math.floor(this._currentTime); s >= this._durations[this.currentFrame];)
            (s -= this._durations[this.currentFrame] * n), (this._currentTime += n);
          this._currentTime += s / this._durations[this.currentFrame];
        } else this._currentTime += A;
        this._currentTime < 0 && !this.loop
          ? (this.gotoAndStop(0), this.onComplete && this.onComplete())
          : this._currentTime >= this._textures.length && !this.loop
            ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete())
            : r !== this.currentFrame &&
            (this.loop &&
              this.onLoop &&
              ((this.animationSpeed > 0 && this.currentFrame < r) || (this.animationSpeed < 0 && this.currentFrame > r)) &&
              this.onLoop(),
              this._updateTexture());
      }
      _updateTexture() {
        const e = this.currentFrame;
        this._previousFrame !== e &&
          ((this._previousFrame = e),
            (this.texture = this._textures[e]),
            this.updateAnchor && this.texture.defaultAnchor && this.anchor.copyFrom(this.texture.defaultAnchor),
            this.onFrameChange && this.onFrameChange(this.currentFrame));
      }
      destroy(e = !1) {
        if (typeof e == 'boolean' ? e : e?.texture) {
          const A = typeof e == 'boolean' ? e : e?.textureSource;
          this._textures.forEach((r) => {
            this.texture !== r && r.destroy(A);
          });
        }
        (this._textures = []),
          (this._durations = null),
          this.stop(),
          super.destroy(e),
          (this.onComplete = null),
          (this.onFrameChange = null),
          (this.onLoop = null);
      }
      static fromFrames(e) {
        const t = [];
        for (let A = 0; A < e.length; ++A) t.push(v.from(e[A]));
        return new AA(t);
      }
      static fromImages(e) {
        const t = [];
        for (let A = 0; A < e.length; ++A) t.push(v.from(e[A]));
        return new AA(t);
      }
      get totalFrames() {
        return this._textures.length;
      }
      get textures() {
        return this._textures;
      }
      set textures(e) {
        if (e[0] instanceof v) (this._textures = e), (this._durations = null);
        else {
          (this._textures = []), (this._durations = []);
          for (let t = 0; t < e.length; t++) this._textures.push(e[t].texture), this._durations.push(e[t].time);
        }
        (this._previousFrame = null), this.gotoAndStop(0), this._updateTexture();
      }
      get currentFrame() {
        let e = Math.floor(this._currentTime) % this._textures.length;
        return e < 0 && (e += this._textures.length), e;
      }
      set currentFrame(e) {
        if (e < 0 || e > this.totalFrames - 1)
          throw new Error(
            `[AnimatedSprite]: Invalid frame index value ${e}, expected to be between 0 and totalFrames ${this.totalFrames}.`
          );
        const t = this.currentFrame;
        (this._currentTime = e), t !== this.currentFrame && this._updateTexture();
      }
      get playing() {
        return this._playing;
      }
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(e) {
        e !== this._autoUpdate &&
          ((this._autoUpdate = e),
            !this._autoUpdate && this._isConnectedToTicker
              ? (ue.shared.remove(this.update, this), (this._isConnectedToTicker = !1))
              : this._autoUpdate &&
              !this._isConnectedToTicker &&
              this._playing &&
              (ue.shared.add(this.update, this), (this._isConnectedToTicker = !0)));
      }
    }
    class ed extends HA {
      constructor(e, t) {
        const { text: A, resolution: r, style: s, anchor: n, width: a, height: l, roundPixels: h, ...u } = e;
        super({ ...u }),
          (this.batched = !0),
          (this._resolution = null),
          (this._autoResolution = !0),
          (this._didTextUpdate = !0),
          (this._styleClass = t),
          (this.text = A ?? ''),
          (this.style = s),
          (this.resolution = r ?? null),
          (this.allowChildren = !1),
          (this._anchor = new le({
            _onUpdate: () => {
              this.onViewUpdate();
            },
          })),
          n && (this.anchor = n),
          (this.roundPixels = h ?? !1),
          a !== void 0 && (this.width = a),
          l !== void 0 && (this.height = l);
      }
      get anchor() {
        return this._anchor;
      }
      set anchor(e) {
        typeof e == 'number' ? this._anchor.set(e) : this._anchor.copyFrom(e);
      }
      set text(e) {
        (e = e.toString()), this._text !== e && ((this._text = e), this.onViewUpdate());
      }
      get text() {
        return this._text;
      }
      set resolution(e) {
        (this._autoResolution = e === null), (this._resolution = e), this.onViewUpdate();
      }
      get resolution() {
        return this._resolution;
      }
      get style() {
        return this._style;
      }
      set style(e) {
        e || (e = {}),
          this._style?.off('update', this.onViewUpdate, this),
          e instanceof this._styleClass ? (this._style = e) : (this._style = new this._styleClass(e)),
          this._style.on('update', this.onViewUpdate, this),
          this.onViewUpdate();
      }
      get width() {
        return Math.abs(this.scale.x) * this.bounds.width;
      }
      set width(e) {
        this._setWidth(e, this.bounds.width);
      }
      get height() {
        return Math.abs(this.scale.y) * this.bounds.height;
      }
      set height(e) {
        this._setHeight(e, this.bounds.height);
      }
      getSize(e) {
        return (
          e || (e = {}),
          (e.width = Math.abs(this.scale.x) * this.bounds.width),
          (e.height = Math.abs(this.scale.y) * this.bounds.height),
          e
        );
      }
      setSize(e, t) {
        typeof e == 'object' ? ((t = e.height ?? e.width), (e = e.width)) : t ?? (t = e),
          e !== void 0 && this._setWidth(e, this.bounds.width),
          t !== void 0 && this._setHeight(t, this.bounds.height);
      }
      containsPoint(e) {
        const t = this.bounds.width,
          A = this.bounds.height,
          r = -t * this.anchor.x;
        let s = 0;
        return e.x >= r && e.x <= r + t && ((s = -A * this.anchor.y), e.y >= s && e.y <= s + A);
      }
      onViewUpdate() {
        this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
      }
      destroy(e = !1) {
        super.destroy(e),
          (this.owner = null),
          (this._bounds = null),
          (this._anchor = null),
          (typeof e == 'boolean' ? e : e?.style) && this._style.destroy(e),
          (this._style = null),
          (this._text = null);
      }
      get styleKey() {
        return `${this._text}:${this._style.styleKey}:${this._resolution}`;
      }
    }
    function td(i, e) {
      let t = i[0] ?? {};
      return (
        (typeof t == 'string' || i[1]) &&
        (P(W, `use new ${e}({ text: "hi!", style }) instead`), (t = { text: t, style: i[1] })),
        t
      );
    }
    let qt = null,
      _e = null;
    function iS(i, e) {
      qt ||
        ((qt = J.get().createCanvas(256, 128)),
          (_e = qt.getContext('2d', { willReadFrequently: !0 })),
          (_e.globalCompositeOperation = 'copy'),
          (_e.globalAlpha = 1)),
        (qt.width < i || qt.height < e) && ((qt.width = xt(i)), (qt.height = xt(e)));
    }
    function Tl(i, e, t) {
      for (let A = 0, r = 4 * t * e; A < e; ++A, r += 4) if (i[r + 3] !== 0) return !1;
      return !0;
    }
    function Il(i, e, t, A, r) {
      const s = 4 * e;
      for (let n = A, a = A * s + 4 * t; n <= r; ++n, a += s) if (i[a + 3] !== 0) return !1;
      return !0;
    }
    function Ad(...i) {
      let e = i[0];
      e.canvas || (e = { canvas: i[0], resolution: i[1] });
      const { canvas: t } = e,
        A = Math.min(e.resolution ?? 1, 1),
        r = e.width ?? t.width,
        s = e.height ?? t.height;
      let n = e.output;
      if ((iS(r, s), !_e)) throw new TypeError('Failed to get canvas 2D context');
      _e.drawImage(t, 0, 0, r, s, 0, 0, r * A, s * A);
      const l = _e.getImageData(0, 0, r, s).data;
      let h = 0,
        u = 0,
        o = r - 1,
        c = s - 1;
      for (; u < s && Tl(l, r, u);) ++u;
      if (u === s) return F.EMPTY;
      for (; Tl(l, r, c);) --c;
      for (; Il(l, r, h, u, c);) ++h;
      for (; Il(l, r, o, u, c);) --o;
      return (
        ++o,
        ++c,
        (_e.globalCompositeOperation = 'source-over'),
        _e.strokeRect(h, u, o - h, c - u),
        (_e.globalCompositeOperation = 'copy'),
        n ?? (n = new F()),
        n.set(h / A, u / A, (o - h) / A, (c - u) / A),
        n
      );
    }
    const bl = new F();
    class rS {
      getCanvasAndContext(e) {
        const { text: t, style: A, resolution: r = 1 } = e,
          s = A._getFinalPadding(),
          n = Ne.measureText(t || ' ', A),
          a = Math.ceil(Math.ceil(Math.max(1, n.width) + s * 2) * r),
          l = Math.ceil(Math.ceil(Math.max(1, n.height) + s * 2) * r),
          h = Xe.getOptimalCanvasAndContext(a, l);
        this._renderTextToCanvas(t, A, s, r, h);
        const u = A.trim ? Ad({ canvas: h.canvas, width: a, height: l, resolution: 1, output: bl }) : bl.set(0, 0, a, l);
        return { canvasAndContext: h, frame: u };
      }
      returnCanvasAndContext(e) {
        Xe.returnCanvasAndContext(e);
      }
      _renderTextToCanvas(e, t, A, r, s) {
        const { canvas: n, context: a } = s,
          l = LA(t),
          h = Ne.measureText(e || ' ', t),
          u = h.lines,
          o = h.lineHeight,
          c = h.lineWidths,
          d = h.maxLineWidth,
          f = h.fontProperties,
          g = n.height;
        if ((a.resetTransform(), a.scale(r, r), (a.textBaseline = t.textBaseline), t._stroke?.width)) {
          const q = t._stroke;
          (a.lineWidth = q.width), (a.miterLimit = q.miterLimit), (a.lineJoin = q.join), (a.lineCap = q.cap);
        }
        a.font = l;
        let p, m;
        const S = t.dropShadow ? 2 : 1;
        for (let q = 0; q < S; ++q) {
          const E = t.dropShadow && q === 0,
            b = E ? Math.ceil(Math.max(1, g) + A * 2) : 0,
            T = b * r;
          if (E) {
            (a.fillStyle = 'black'), (a.strokeStyle = 'black');
            const y = t.dropShadow,
              x = y.color,
              C = y.alpha;
            a.shadowColor = $.shared.setValue(x).setAlpha(C).toRgbaString();
            const X = y.blur * r,
              L = y.distance * r;
            (a.shadowBlur = X), (a.shadowOffsetX = Math.cos(y.angle) * L), (a.shadowOffsetY = Math.sin(y.angle) * L + T);
          } else {
            if (((a.fillStyle = t._fill ? ZA(t._fill, a, h, A * 2) : null), t._stroke?.width)) {
              const y = t._stroke.width * 0.5 + A * 2;
              a.strokeStyle = ZA(t._stroke, a, h, y);
            }
            a.shadowColor = 'black';
          }
          let I = (o - f.fontSize) / 2;
          o - f.fontSize < 0 && (I = 0);
          const B = t._stroke?.width ?? 0;
          for (let y = 0; y < u.length; y++)
            (p = B / 2),
              (m = B / 2 + y * o + f.ascent + I),
              t.align === 'right' ? (p += d - c[y]) : t.align === 'center' && (p += (d - c[y]) / 2),
              t._stroke?.width && this._drawLetterSpacing(u[y], t, s, p + A, m + A - b, !0),
              t._fill !== void 0 && this._drawLetterSpacing(u[y], t, s, p + A, m + A - b);
        }
      }
      _drawLetterSpacing(e, t, A, r, s, n = !1) {
        const { context: a } = A,
          l = t.letterSpacing;
        let h = !1;
        if (
          (Ne.experimentalLetterSpacingSupported &&
            (Ne.experimentalLetterSpacing
              ? ((a.letterSpacing = `${l}px`), (a.textLetterSpacing = `${l}px`), (h = !0))
              : ((a.letterSpacing = '0px'), (a.textLetterSpacing = '0px'))),
            l === 0 || h)
        ) {
          n ? a.strokeText(e, r, s) : a.fillText(e, r, s);
          return;
        }
        let u = r;
        const o = Ne.graphemeSegmenter(e);
        let c = a.measureText(e).width,
          d = 0;
        for (let f = 0; f < o.length; ++f) {
          const g = o[f];
          n ? a.strokeText(g, u, s) : a.fillText(g, u, s);
          let p = '';
          for (let m = f + 1; m < o.length; ++m) p += o[m];
          (d = a.measureText(p).width), (u += c - d + l), (c = d);
        }
      }
    }
    const Xt = new rS();
    class id extends ed {
      constructor(...e) {
        const t = td(e, 'Text');
        super(t, tt),
          (this.renderPipeId = 'text'),
          t.textureStyle && (this.textureStyle = t.textureStyle instanceof Je ? t.textureStyle : new Je(t.textureStyle));
      }
      updateBounds() {
        const e = this._bounds,
          t = this._anchor;
        let A = 0,
          r = 0;
        if (this._style.trim) {
          const { frame: s, canvasAndContext: n } = Xt.getCanvasAndContext({
            text: this.text,
            style: this._style,
            resolution: 1,
          });
          Xt.returnCanvasAndContext(n), (A = s.width), (r = s.height);
        } else {
          const s = Ne.measureText(this._text, this._style);
          (A = s.width), (r = s.height);
        }
        (e.minX = -t._x * A), (e.maxX = e.minX + A), (e.minY = -t._y * r), (e.maxY = e.minY + r);
      }
    }
    const yl = 'http://www.w3.org/2000/svg',
      xl = 'http://www.w3.org/1999/xhtml';
    class Gn {
      constructor() {
        (this.svgRoot = document.createElementNS(yl, 'svg')),
          (this.foreignObject = document.createElementNS(yl, 'foreignObject')),
          (this.domElement = document.createElementNS(xl, 'div')),
          (this.styleElement = document.createElementNS(xl, 'style'));
        const { foreignObject: e, svgRoot: t, styleElement: A, domElement: r } = this;
        e.setAttribute('width', '10000'),
          e.setAttribute('height', '10000'),
          (e.style.overflow = 'hidden'),
          t.appendChild(e),
          e.appendChild(A),
          e.appendChild(r),
          (this.image = J.get().createImage());
      }
      destroy() {
        this.svgRoot.remove(),
          this.foreignObject.remove(),
          this.styleElement.remove(),
          this.domElement.remove(),
          (this.image.src = ''),
          this.image.remove(),
          (this.svgRoot = null),
          (this.foreignObject = null),
          (this.styleElement = null),
          (this.domElement = null),
          (this.image = null),
          (this.canvasAndContext = null);
      }
    }
    let vl;
    function rd(i, e, t, A) {
      A || (A = vl || (vl = new Gn()));
      const { domElement: r, styleElement: s, svgRoot: n } = A;
      (r.innerHTML = `<style>${e.cssStyle};</style><div style='padding:0'>${i}</div>`),
        r.setAttribute('style', 'transform-origin: top left; display: inline-block'),
        t && (s.textContent = t),
        document.body.appendChild(n);
      const a = r.getBoundingClientRect();
      n.remove();
      const l = e.padding * 2;
      return { width: a.width - l, height: a.height - l };
    }
    class Wn {
      constructor() {
        (this._tempState = Ue.for2d()), (this._didUploadHash = {});
      }
      init(e) {
        e.renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._didUploadHash = {};
      }
      start(e, t, A) {
        const r = e.renderer,
          s = this._didUploadHash[A.uid];
        r.shader.bind(A, s),
          s || (this._didUploadHash[A.uid] = !0),
          r.shader.updateUniformGroup(r.globalUniforms.uniformGroup),
          r.geometry.bind(t, A.glProgram);
      }
      execute(e, t) {
        const A = e.renderer;
        (this._tempState.blendMode = t.blendMode), A.state.set(this._tempState);
        const r = t.textures.textures;
        for (let s = 0; s < t.textures.count; s++) A.texture.bind(r[s], s);
        A.geometry.draw(t.topology, t.size, t.start);
      }
    }
    Wn.extension = { type: [M.WebGLPipesAdaptor], name: 'batch' };
    const Mi = Ue.for2d();
    class Kn {
      start(e, t, A) {
        const r = e.renderer,
          s = r.encoder,
          n = A.gpuProgram;
        (this._shader = A),
          (this._geometry = t),
          s.setGeometry(t, n),
          (Mi.blendMode = 'normal'),
          r.pipeline.getPipeline(t, n, Mi);
        const a = r.globalUniforms.bindGroup;
        s.resetBindGroup(1), s.setBindGroup(0, a, n);
      }
      execute(e, t) {
        const A = this._shader.gpuProgram,
          r = e.renderer,
          s = r.encoder;
        if (!t.bindGroup) {
          const l = t.textures;
          t.bindGroup = $i(l.textures, l.count, r.limits.maxBatchableTextures);
        }
        Mi.blendMode = t.blendMode;
        const n = r.bindGroup.getBindGroup(t.bindGroup, A, 1),
          a = r.pipeline.getPipeline(this._geometry, A, Mi, t.topology);
        t.bindGroup._touch(r.textureGC.count),
          s.setPipeline(a),
          s.renderPassEncoder.setBindGroup(1, n),
          s.renderPassEncoder.drawIndexed(t.size, 1, t.start);
      }
    }
    Kn.extension = { type: [M.WebGPUPipesAdaptor], name: 'batch' };
    const Fn = class sd {
      constructor(e, t) {
        (this.state = Ue.for2d()),
          (this._batchersByInstructionSet = Object.create(null)),
          (this._activeBatches = Object.create(null)),
          (this.renderer = e),
          (this._adaptor = t),
          this._adaptor.init?.(this);
      }
      static getBatcher(e) {
        return new this._availableBatchers[e]();
      }
      buildStart(e) {
        let t = this._batchersByInstructionSet[e.uid];
        t ||
          ((t = this._batchersByInstructionSet[e.uid] = Object.create(null)),
            t.default || (t.default = new sr({ maxTextures: this.renderer.limits.maxBatchableTextures }))),
          (this._activeBatches = t),
          (this._activeBatch = this._activeBatches.default);
        for (const A in this._activeBatches) this._activeBatches[A].begin();
      }
      addToBatch(e, t) {
        if (this._activeBatch.name !== e.batcherName) {
          this._activeBatch.break(t);
          let A = this._activeBatches[e.batcherName];
          A || ((A = this._activeBatches[e.batcherName] = sd.getBatcher(e.batcherName)), A.begin()), (this._activeBatch = A);
        }
        this._activeBatch.add(e);
      }
      break(e) {
        this._activeBatch.break(e);
      }
      buildEnd(e) {
        this._activeBatch.break(e);
        const t = this._activeBatches;
        for (const A in t) {
          const r = t[A],
            s = r.geometry;
          s.indexBuffer.setDataWithSize(r.indexBuffer, r.indexSize, !0),
            s.buffers[0].setDataWithSize(r.attributeBuffer.float32View, r.attributeSize, !1);
        }
      }
      upload(e) {
        const t = this._batchersByInstructionSet[e.uid];
        for (const A in t) {
          const r = t[A],
            s = r.geometry;
          r.dirty && ((r.dirty = !1), s.buffers[0].update(r.attributeSize * 4));
        }
      }
      execute(e) {
        if (e.action === 'startBatch') {
          const t = e.batcher,
            A = t.geometry,
            r = t.shader;
          this._adaptor.start(this, A, r);
        }
        this._adaptor.execute(this, e);
      }
      destroy() {
        (this.state = null), (this.renderer = null), (this._adaptor = null);
        for (const e in this._activeBatches) this._activeBatches[e].destroy();
        this._activeBatches = null;
      }
    };
    Fn.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'batch' };
    Fn._availableBatchers = Object.create(null);
    let Yn = Fn;
    Q.handleByMap(M.Batcher, Yn._availableBatchers);
    Q.add(sr);
    const Ht = {
      name: 'local-uniform-bit',
      vertex: {
        header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
        main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
        end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `,
      },
    },
      nd = { ...Ht, vertex: { ...Ht.vertex, header: Ht.vertex.header.replace('group(1)', 'group(2)') } },
      hr = {
        name: 'local-uniform-bit',
        vertex: {
          header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
          main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
          end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `,
        },
      },
      ad = {
        name: 'texture-bit',
        vertex: {
          header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
          main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `,
        },
        fragment: {
          header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,
          main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `,
        },
      },
      od = {
        name: 'texture-bit',
        vertex: {
          header: `
            uniform mat3 uTextureMatrix;
        `,
          main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `,
        },
        fragment: {
          header: `
        uniform sampler2D uTexture;


        `,
          main: `
            outColor = texture(uTexture, vUV);
        `,
        },
      },
      sS = new de();
    class nS extends PA {
      constructor() {
        super(),
          (this.filters = [new Hu({ sprite: new re(v.EMPTY), inverse: !1, resolution: 'inherit', antialias: 'inherit' })]);
      }
      get sprite() {
        return this.filters[0].sprite;
      }
      set sprite(e) {
        this.filters[0].sprite = e;
      }
      get inverse() {
        return this.filters[0].inverse;
      }
      set inverse(e) {
        this.filters[0].inverse = e;
      }
    }
    class Dn {
      constructor(e) {
        (this._activeMaskStage = []), (this._renderer = e);
      }
      push(e, t, A) {
        const r = this._renderer;
        if (
          (r.renderPipes.batch.break(A),
            A.add({
              renderPipeId: 'alphaMask',
              action: 'pushMaskBegin',
              mask: e,
              inverse: t._maskOptions.inverse,
              canBundle: !1,
              maskedContainer: t,
            }),
            (e.inverse = t._maskOptions.inverse),
            e.renderMaskToTexture)
        ) {
          const s = e.mask;
          (s.includeInBuild = !0), s.collectRenderables(A, r, null), (s.includeInBuild = !1);
        }
        r.renderPipes.batch.break(A),
          A.add({
            renderPipeId: 'alphaMask',
            action: 'pushMaskEnd',
            mask: e,
            maskedContainer: t,
            inverse: t._maskOptions.inverse,
            canBundle: !1,
          });
      }
      pop(e, t, A) {
        this._renderer.renderPipes.batch.break(A),
          A.add({ renderPipeId: 'alphaMask', action: 'popMaskEnd', mask: e, inverse: t._maskOptions.inverse, canBundle: !1 });
      }
      execute(e) {
        const t = this._renderer,
          A = e.mask.renderMaskToTexture;
        if (e.action === 'pushMaskBegin') {
          const r = se.get(nS);
          if (((r.inverse = e.inverse), A)) {
            e.mask.mask.measurable = !0;
            const s = Oi(e.mask.mask, !0, sS);
            (e.mask.mask.measurable = !1), s.ceil();
            const n = t.renderTarget.renderTarget.colorTexture.source,
              a = ce.getOptimalTexture(s.width, s.height, n._resolution, n.antialias);
            t.renderTarget.push(a, !0), t.globalUniforms.push({ offset: s, worldColor: 4294967295 });
            const l = r.sprite;
            (l.texture = a),
              (l.worldTransform.tx = s.minX),
              (l.worldTransform.ty = s.minY),
              this._activeMaskStage.push({ filterEffect: r, maskedContainer: e.maskedContainer, filterTexture: a });
          } else (r.sprite = e.mask.mask), this._activeMaskStage.push({ filterEffect: r, maskedContainer: e.maskedContainer });
        } else if (e.action === 'pushMaskEnd') {
          const r = this._activeMaskStage[this._activeMaskStage.length - 1];
          A && (t.type === we.WEBGL && t.renderTarget.finishRenderPass(), t.renderTarget.pop(), t.globalUniforms.pop()),
            t.filter.push({
              renderPipeId: 'filter',
              action: 'pushFilter',
              container: r.maskedContainer,
              filterEffect: r.filterEffect,
              canBundle: !1,
            });
        } else if (e.action === 'popMaskEnd') {
          t.filter.pop();
          const r = this._activeMaskStage.pop();
          A && ce.returnTexture(r.filterTexture), se.return(r.filterEffect);
        }
      }
      destroy() {
        (this._renderer = null), (this._activeMaskStage = null);
      }
    }
    Dn.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'alphaMask' };
    class On {
      constructor(e) {
        (this._colorStack = []), (this._colorStackIndex = 0), (this._currentColor = 0), (this._renderer = e);
      }
      buildStart() {
        (this._colorStack[0] = 15), (this._colorStackIndex = 1), (this._currentColor = 15);
      }
      push(e, t, A) {
        this._renderer.renderPipes.batch.break(A);
        const s = this._colorStack;
        s[this._colorStackIndex] = s[this._colorStackIndex - 1] & e.mask;
        const n = this._colorStack[this._colorStackIndex];
        n !== this._currentColor &&
          ((this._currentColor = n), A.add({ renderPipeId: 'colorMask', colorMask: n, canBundle: !1 })),
          this._colorStackIndex++;
      }
      pop(e, t, A) {
        this._renderer.renderPipes.batch.break(A);
        const s = this._colorStack;
        this._colorStackIndex--;
        const n = s[this._colorStackIndex - 1];
        n !== this._currentColor &&
          ((this._currentColor = n), A.add({ renderPipeId: 'colorMask', colorMask: n, canBundle: !1 }));
      }
      execute(e) {
        this._renderer.colorMask.setMask(e.colorMask);
      }
      destroy() {
        (this._renderer = null), (this._colorStack = null);
      }
    }
    On.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'colorMask' };
    class Ln {
      constructor(e) {
        (this._maskStackHash = {}), (this._maskHash = new WeakMap()), (this._renderer = e);
      }
      push(e, t, A) {
        var r;
        const s = e,
          n = this._renderer;
        n.renderPipes.batch.break(A),
          n.renderPipes.blendMode.setBlendMode(s.mask, 'none', A),
          A.add({
            renderPipeId: 'stencilMask',
            action: 'pushMaskBegin',
            mask: e,
            inverse: t._maskOptions.inverse,
            canBundle: !1,
          });
        const a = s.mask;
        (a.includeInBuild = !0),
          this._maskHash.has(s) || this._maskHash.set(s, { instructionsStart: 0, instructionsLength: 0 });
        const l = this._maskHash.get(s);
        (l.instructionsStart = A.instructionSize),
          a.collectRenderables(A, n, null),
          (a.includeInBuild = !1),
          n.renderPipes.batch.break(A),
          A.add({
            renderPipeId: 'stencilMask',
            action: 'pushMaskEnd',
            mask: e,
            inverse: t._maskOptions.inverse,
            canBundle: !1,
          });
        const h = A.instructionSize - l.instructionsStart - 1;
        l.instructionsLength = h;
        const u = n.renderTarget.renderTarget.uid;
        (r = this._maskStackHash)[u] ?? (r[u] = 0);
      }
      pop(e, t, A) {
        const r = e,
          s = this._renderer;
        s.renderPipes.batch.break(A),
          s.renderPipes.blendMode.setBlendMode(r.mask, 'none', A),
          A.add({ renderPipeId: 'stencilMask', action: 'popMaskBegin', inverse: t._maskOptions.inverse, canBundle: !1 });
        const n = this._maskHash.get(e);
        for (let a = 0; a < n.instructionsLength; a++)
          A.instructions[A.instructionSize++] = A.instructions[n.instructionsStart++];
        A.add({ renderPipeId: 'stencilMask', action: 'popMaskEnd', canBundle: !1 });
      }
      execute(e) {
        var t;
        const A = this._renderer,
          r = A.renderTarget.renderTarget.uid;
        let s = (t = this._maskStackHash)[r] ?? (t[r] = 0);
        e.action === 'pushMaskBegin'
          ? (A.renderTarget.ensureDepthStencil(),
            A.stencil.setStencilMode(ie.RENDERING_MASK_ADD, s),
            s++,
            A.colorMask.setMask(0))
          : e.action === 'pushMaskEnd'
            ? (e.inverse ? A.stencil.setStencilMode(ie.INVERSE_MASK_ACTIVE, s) : A.stencil.setStencilMode(ie.MASK_ACTIVE, s),
              A.colorMask.setMask(15))
            : e.action === 'popMaskBegin'
              ? (A.colorMask.setMask(0),
                s !== 0
                  ? A.stencil.setStencilMode(ie.RENDERING_MASK_REMOVE, s)
                  : (A.renderTarget.clear(null, Ve.STENCIL), A.stencil.setStencilMode(ie.DISABLED, s)),
                s--)
              : e.action === 'popMaskEnd' &&
              (e.inverse ? A.stencil.setStencilMode(ie.INVERSE_MASK_ACTIVE, s) : A.stencil.setStencilMode(ie.MASK_ACTIVE, s),
                A.colorMask.setMask(15)),
          (this._maskStackHash[r] = s);
      }
      destroy() {
        (this._renderer = null), (this._maskStackHash = null), (this._maskHash = null);
      }
    }
    Ln.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'stencilMask' };
    var RA = ((i) => (
      (i[(i.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
      (i[(i.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
      (i[(i.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER'),
      i
    ))(RA || {});
    class ld {
      constructor(e, t) {
        (this._lastBindBaseLocation = -1),
          (this._lastBindCallId = -1),
          (this.buffer = e || null),
          (this.updateID = -1),
          (this.byteLength = -1),
          (this.type = t);
      }
    }
    class jn {
      constructor(e) {
        (this._gpuBuffers = Object.create(null)),
          (this._boundBufferBases = Object.create(null)),
          (this._minBaseLocation = 0),
          (this._nextBindBaseIndex = this._minBaseLocation),
          (this._bindCallId = 0),
          (this._renderer = e),
          this._renderer.renderableGC.addManagedHash(this, '_gpuBuffers');
      }
      destroy() {
        this.destroyAll(), (this._renderer = null), (this._gl = null), (this._gpuBuffers = {}), (this._boundBufferBases = {});
      }
      contextChange() {
        (this._gl = this._renderer.gl),
          (this._gpuBuffers = Object.create(null)),
          (this._maxBindings = this._renderer.limits.maxUniformBindings);
      }
      getGlBuffer(e) {
        return this._gpuBuffers[e.uid] || this.createGLBuffer(e);
      }
      bind(e) {
        const { _gl: t } = this,
          A = this.getGlBuffer(e);
        t.bindBuffer(A.type, A.buffer);
      }
      bindBufferBase(e, t) {
        const { _gl: A } = this;
        this._boundBufferBases[t] !== e &&
          ((this._boundBufferBases[t] = e), (e._lastBindBaseLocation = t), A.bindBufferBase(A.UNIFORM_BUFFER, t, e.buffer));
      }
      nextBindBase(e) {
        this._bindCallId++,
          (this._minBaseLocation = 0),
          e &&
          ((this._boundBufferBases[0] = null),
            (this._minBaseLocation = 1),
            this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1));
      }
      freeLocationForBufferBase(e) {
        let t = this.getLastBindBaseLocation(e);
        if (t >= this._minBaseLocation) return (e._lastBindCallId = this._bindCallId), t;
        let A = 0,
          r = this._nextBindBaseIndex;
        for (; A < 2;) {
          r >= this._maxBindings && ((r = this._minBaseLocation), A++);
          const s = this._boundBufferBases[r];
          if (s && s._lastBindCallId === this._bindCallId) {
            r++;
            continue;
          }
          break;
        }
        return (
          (t = r),
          (this._nextBindBaseIndex = r + 1),
          A >= 2 ? -1 : ((e._lastBindCallId = this._bindCallId), (this._boundBufferBases[t] = null), t)
        );
      }
      getLastBindBaseLocation(e) {
        const t = e._lastBindBaseLocation;
        return this._boundBufferBases[t] === e ? t : -1;
      }
      bindBufferRange(e, t, A, r) {
        const { _gl: s } = this;
        A || (A = 0),
          t || (t = 0),
          (this._boundBufferBases[t] = null),
          s.bindBufferRange(s.UNIFORM_BUFFER, t || 0, e.buffer, A * 256, r || 256);
      }
      updateBuffer(e) {
        const { _gl: t } = this,
          A = this.getGlBuffer(e);
        if (e._updateID === A.updateID) return A;
        (A.updateID = e._updateID), t.bindBuffer(A.type, A.buffer);
        const r = e.data,
          s = e.descriptor.usage & K.STATIC ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
        return (
          r
            ? A.byteLength >= r.byteLength
              ? t.bufferSubData(A.type, 0, r, 0, e._updateSize / r.BYTES_PER_ELEMENT)
              : ((A.byteLength = r.byteLength), t.bufferData(A.type, r, s))
            : ((A.byteLength = e.descriptor.size), t.bufferData(A.type, A.byteLength, s)),
          A
        );
      }
      destroyAll() {
        const e = this._gl;
        for (const t in this._gpuBuffers) this._gpuBuffers[t] && e.deleteBuffer(this._gpuBuffers[t].buffer);
        this._gpuBuffers = Object.create(null);
      }
      onBufferDestroy(e, t) {
        if (!this._gpuBuffers[e.uid]) return;
        const A = this._gpuBuffers[e.uid],
          r = this._gl;
        t || r.deleteBuffer(A.buffer), e.off('destroy', this.onBufferDestroy, this), (this._gpuBuffers[e.uid] = null);
      }
      createGLBuffer(e) {
        const { _gl: t } = this;
        let A = RA.ARRAY_BUFFER;
        e.descriptor.usage & K.INDEX
          ? (A = RA.ELEMENT_ARRAY_BUFFER)
          : e.descriptor.usage & K.UNIFORM && (A = RA.UNIFORM_BUFFER);
        const r = new ld(t.createBuffer(), A);
        return (this._gpuBuffers[e.uid] = r), e.on('destroy', this.onBufferDestroy, this), r;
      }
      resetState() {
        this._boundBufferBases = Object.create(null);
      }
    }
    jn.extension = { type: [M.WebGLSystem], name: 'buffer' };
    const Zn = class hd {
      constructor(e) {
        (this.supports = {
          uint32Indices: !0,
          uniformBufferObject: !0,
          vertexArrayObject: !0,
          srgbTextures: !0,
          nonPowOf2wrapping: !0,
          msaa: !0,
          nonPowOf2mipmaps: !0,
        }),
          (this._renderer = e),
          (this.extensions = Object.create(null)),
          (this.handleContextLost = this.handleContextLost.bind(this)),
          (this.handleContextRestored = this.handleContextRestored.bind(this));
      }
      get isLost() {
        return !this.gl || this.gl.isContextLost();
      }
      contextChange(e) {
        (this.gl = e), (this._renderer.gl = e);
      }
      init(e) {
        e = { ...hd.defaultOptions, ...e };
        let t = (this.multiView = e.multiView);
        if (
          (e.context &&
            t &&
            (N('Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.'),
              (t = !1)),
            t
              ? (this.canvas = J.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height))
              : (this.canvas = this._renderer.view.canvas),
            e.context)
        )
          this.initFromContext(e.context);
        else {
          const A = this._renderer.background.alpha < 1,
            r = e.premultipliedAlpha ?? !0,
            s = e.antialias && !this._renderer.backBuffer.useBackBuffer;
          this.createContext(e.preferWebGLVersion, {
            alpha: A,
            premultipliedAlpha: r,
            antialias: s,
            stencil: !0,
            preserveDrawingBuffer: e.preserveDrawingBuffer,
            powerPreference: e.powerPreference ?? 'default',
          });
        }
      }
      ensureCanvasSize(e) {
        if (!this.multiView) {
          e !== this.canvas && N('multiView is disabled, but targetCanvas is not the main canvas');
          return;
        }
        const { canvas: t } = this;
        (t.width < e.width || t.height < e.height) &&
          ((t.width = Math.max(e.width, e.width)), (t.height = Math.max(e.height, e.height)));
      }
      initFromContext(e) {
        (this.gl = e),
          (this.webGLVersion = e instanceof J.get().getWebGLRenderingContext() ? 1 : 2),
          this.getExtensions(),
          this.validateContext(e),
          this._renderer.runners.contextChange.emit(e);
        const t = this._renderer.view.canvas;
        t.addEventListener('webglcontextlost', this.handleContextLost, !1),
          t.addEventListener('webglcontextrestored', this.handleContextRestored, !1);
      }
      createContext(e, t) {
        let A;
        const r = this.canvas;
        if ((e === 2 && (A = r.getContext('webgl2', t)), !A && ((A = r.getContext('webgl', t)), !A)))
          throw new Error('This browser does not support WebGL. Try using the canvas renderer');
        (this.gl = A), this.initFromContext(this.gl);
      }
      getExtensions() {
        const { gl: e } = this,
          t = {
            anisotropicFiltering: e.getExtension('EXT_texture_filter_anisotropic'),
            floatTextureLinear: e.getExtension('OES_texture_float_linear'),
            s3tc: e.getExtension('WEBGL_compressed_texture_s3tc'),
            s3tc_sRGB: e.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
            etc: e.getExtension('WEBGL_compressed_texture_etc'),
            etc1: e.getExtension('WEBGL_compressed_texture_etc1'),
            pvrtc: e.getExtension('WEBGL_compressed_texture_pvrtc') || e.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
            atc: e.getExtension('WEBGL_compressed_texture_atc'),
            astc: e.getExtension('WEBGL_compressed_texture_astc'),
            bptc: e.getExtension('EXT_texture_compression_bptc'),
            rgtc: e.getExtension('EXT_texture_compression_rgtc'),
            loseContext: e.getExtension('WEBGL_lose_context'),
          };
        if (this.webGLVersion === 1)
          this.extensions = {
            ...t,
            drawBuffers: e.getExtension('WEBGL_draw_buffers'),
            depthTexture: e.getExtension('WEBGL_depth_texture'),
            vertexArrayObject:
              e.getExtension('OES_vertex_array_object') ||
              e.getExtension('MOZ_OES_vertex_array_object') ||
              e.getExtension('WEBKIT_OES_vertex_array_object'),
            uint32ElementIndex: e.getExtension('OES_element_index_uint'),
            floatTexture: e.getExtension('OES_texture_float'),
            floatTextureLinear: e.getExtension('OES_texture_float_linear'),
            textureHalfFloat: e.getExtension('OES_texture_half_float'),
            textureHalfFloatLinear: e.getExtension('OES_texture_half_float_linear'),
            vertexAttribDivisorANGLE: e.getExtension('ANGLE_instanced_arrays'),
            srgb: e.getExtension('EXT_sRGB'),
          };
        else {
          this.extensions = { ...t, colorBufferFloat: e.getExtension('EXT_color_buffer_float') };
          const A = e.getExtension('WEBGL_provoking_vertex');
          A && A.provokingVertexWEBGL(A.FIRST_VERTEX_CONVENTION_WEBGL);
        }
      }
      handleContextLost(e) {
        e.preventDefault(),
          this._contextLossForced &&
          ((this._contextLossForced = !1),
            setTimeout(() => {
              this.gl.isContextLost() && this.extensions.loseContext?.restoreContext();
            }, 0));
      }
      handleContextRestored() {
        this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl);
      }
      destroy() {
        const e = this._renderer.view.canvas;
        (this._renderer = null),
          e.removeEventListener('webglcontextlost', this.handleContextLost),
          e.removeEventListener('webglcontextrestored', this.handleContextRestored),
          this.gl.useProgram(null),
          this.extensions.loseContext?.loseContext();
      }
      forceContextLoss() {
        this.extensions.loseContext?.loseContext(), (this._contextLossForced = !0);
      }
      validateContext(e) {
        const t = e.getContextAttributes();
        t && !t.stencil && N('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
        const A = this.supports,
          r = this.webGLVersion === 2,
          s = this.extensions;
        (A.uint32Indices = r || !!s.uint32ElementIndex),
          (A.uniformBufferObject = r),
          (A.vertexArrayObject = r || !!s.vertexArrayObject),
          (A.srgbTextures = r || !!s.srgb),
          (A.nonPowOf2wrapping = r),
          (A.nonPowOf2mipmaps = r),
          (A.msaa = r),
          A.uint32Indices ||
          N('Provided WebGL context does not support 32 index buffer, large scenes may not render correctly');
      }
    };
    Zn.extension = { type: [M.WebGLSystem], name: 'context' };
    Zn.defaultOptions = {
      context: null,
      premultipliedAlpha: !0,
      preserveDrawingBuffer: !1,
      powerPreference: void 0,
      preferWebGLVersion: 2,
      multiView: !1,
    };
    let cd = Zn;
    function Xn(i, e) {
      for (const t in i.attributes) {
        const A = i.attributes[t],
          r = e[t];
        r
          ? (A.format ?? (A.format = r.format), A.offset ?? (A.offset = r.offset), A.instance ?? (A.instance = r.instance))
          : N(
            `Attribute ${t} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`
          );
      }
      aS(i);
    }
    function aS(i) {
      const { buffers: e, attributes: t } = i,
        A = {},
        r = {};
      for (const s in e) {
        const n = e[s];
        (A[n.uid] = 0), (r[n.uid] = 0);
      }
      for (const s in t) {
        const n = t[s];
        A[n.buffer.uid] += et(n.format).stride;
      }
      for (const s in t) {
        const n = t[s];
        n.stride ?? (n.stride = A[n.buffer.uid]),
          n.start ?? (n.start = r[n.buffer.uid]),
          (r[n.buffer.uid] += et(n.format).stride);
      }
    }
    var Ji = ((i) => (
      (i[(i.RGBA = 6408)] = 'RGBA'),
      (i[(i.RGB = 6407)] = 'RGB'),
      (i[(i.RG = 33319)] = 'RG'),
      (i[(i.RED = 6403)] = 'RED'),
      (i[(i.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
      (i[(i.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
      (i[(i.RG_INTEGER = 33320)] = 'RG_INTEGER'),
      (i[(i.RED_INTEGER = 36244)] = 'RED_INTEGER'),
      (i[(i.ALPHA = 6406)] = 'ALPHA'),
      (i[(i.LUMINANCE = 6409)] = 'LUMINANCE'),
      (i[(i.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
      (i[(i.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
      (i[(i.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL'),
      i
    ))(Ji || {}),
      Hn = ((i) => (
        (i[(i.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
        (i[(i.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
        (i[(i.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
        (i[(i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] = 'TEXTURE_CUBE_MAP_POSITIVE_X'),
        (i[(i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] = 'TEXTURE_CUBE_MAP_NEGATIVE_X'),
        (i[(i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] = 'TEXTURE_CUBE_MAP_POSITIVE_Y'),
        (i[(i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] = 'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
        (i[(i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] = 'TEXTURE_CUBE_MAP_POSITIVE_Z'),
        (i[(i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] = 'TEXTURE_CUBE_MAP_NEGATIVE_Z'),
        i
      ))(Hn || {}),
      Y = ((i) => (
        (i[(i.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
        (i[(i.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
        (i[(i.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
        (i[(i.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
        (i[(i.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
        (i[(i.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
        (i[(i.UNSIGNED_INT_10F_11F_11F_REV = 35899)] = 'UNSIGNED_INT_10F_11F_11F_REV'),
        (i[(i.UNSIGNED_INT_2_10_10_10_REV = 33640)] = 'UNSIGNED_INT_2_10_10_10_REV'),
        (i[(i.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
        (i[(i.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
        (i[(i.BYTE = 5120)] = 'BYTE'),
        (i[(i.SHORT = 5122)] = 'SHORT'),
        (i[(i.INT = 5124)] = 'INT'),
        (i[(i.FLOAT = 5126)] = 'FLOAT'),
        (i[(i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] = 'FLOAT_32_UNSIGNED_INT_24_8_REV'),
        (i[(i.HALF_FLOAT = 36193)] = 'HALF_FLOAT'),
        i
      ))(Y || {});
    const Cl = {
      uint8x2: Y.UNSIGNED_BYTE,
      uint8x4: Y.UNSIGNED_BYTE,
      sint8x2: Y.BYTE,
      sint8x4: Y.BYTE,
      unorm8x2: Y.UNSIGNED_BYTE,
      unorm8x4: Y.UNSIGNED_BYTE,
      snorm8x2: Y.BYTE,
      snorm8x4: Y.BYTE,
      uint16x2: Y.UNSIGNED_SHORT,
      uint16x4: Y.UNSIGNED_SHORT,
      sint16x2: Y.SHORT,
      sint16x4: Y.SHORT,
      unorm16x2: Y.UNSIGNED_SHORT,
      unorm16x4: Y.UNSIGNED_SHORT,
      snorm16x2: Y.SHORT,
      snorm16x4: Y.SHORT,
      float16x2: Y.HALF_FLOAT,
      float16x4: Y.HALF_FLOAT,
      float32: Y.FLOAT,
      float32x2: Y.FLOAT,
      float32x3: Y.FLOAT,
      float32x4: Y.FLOAT,
      uint32: Y.UNSIGNED_INT,
      uint32x2: Y.UNSIGNED_INT,
      uint32x3: Y.UNSIGNED_INT,
      uint32x4: Y.UNSIGNED_INT,
      sint32: Y.INT,
      sint32x2: Y.INT,
      sint32x3: Y.INT,
      sint32x4: Y.INT,
    };
    function ud(i) {
      return Cl[i] ?? Cl.float32;
    }
    const oS = { 'point-list': 0, 'line-list': 1, 'line-strip': 3, 'triangle-list': 4, 'triangle-strip': 5 };
    class zn {
      constructor(e) {
        (this._geometryVaoHash = Object.create(null)),
          (this._renderer = e),
          (this._activeGeometry = null),
          (this._activeVao = null),
          (this.hasVao = !0),
          (this.hasInstance = !0),
          this._renderer.renderableGC.addManagedHash(this, '_geometryVaoHash');
      }
      contextChange() {
        const e = (this.gl = this._renderer.gl);
        if (!this._renderer.context.supports.vertexArrayObject)
          throw new Error('[PixiJS] Vertex Array Objects are not supported on this device');
        const t = this._renderer.context.extensions.vertexArrayObject;
        t &&
          ((e.createVertexArray = () => t.createVertexArrayOES()),
            (e.bindVertexArray = (r) => t.bindVertexArrayOES(r)),
            (e.deleteVertexArray = (r) => t.deleteVertexArrayOES(r)));
        const A = this._renderer.context.extensions.vertexAttribDivisorANGLE;
        A &&
          ((e.drawArraysInstanced = (r, s, n, a) => {
            A.drawArraysInstancedANGLE(r, s, n, a);
          }),
            (e.drawElementsInstanced = (r, s, n, a, l) => {
              A.drawElementsInstancedANGLE(r, s, n, a, l);
            }),
            (e.vertexAttribDivisor = (r, s) => A.vertexAttribDivisorANGLE(r, s))),
          (this._activeGeometry = null),
          (this._activeVao = null),
          (this._geometryVaoHash = Object.create(null));
      }
      bind(e, t) {
        const A = this.gl;
        this._activeGeometry = e;
        const r = this.getVao(e, t);
        this._activeVao !== r && ((this._activeVao = r), A.bindVertexArray(r)), this.updateBuffers();
      }
      resetState() {
        this.unbind();
      }
      updateBuffers() {
        const e = this._activeGeometry,
          t = this._renderer.buffer;
        for (let A = 0; A < e.buffers.length; A++) {
          const r = e.buffers[A];
          t.updateBuffer(r);
        }
      }
      checkCompatibility(e, t) {
        const A = e.attributes,
          r = t._attributeData;
        for (const s in r)
          if (!A[s]) throw new Error(`shader and geometry incompatible, geometry missing the "${s}" attribute`);
      }
      getSignature(e, t) {
        const A = e.attributes,
          r = t._attributeData,
          s = ['g', e.uid];
        for (const n in A) r[n] && s.push(n, r[n].location);
        return s.join('-');
      }
      getVao(e, t) {
        return this._geometryVaoHash[e.uid]?.[t._key] || this.initGeometryVao(e, t);
      }
      initGeometryVao(e, t, A = !0) {
        const r = this._renderer.gl,
          s = this._renderer.buffer;
        this._renderer.shader._getProgramData(t), this.checkCompatibility(e, t);
        const n = this.getSignature(e, t);
        this._geometryVaoHash[e.uid] ||
          ((this._geometryVaoHash[e.uid] = Object.create(null)), e.on('destroy', this.onGeometryDestroy, this));
        const a = this._geometryVaoHash[e.uid];
        let l = a[n];
        if (l) return (a[t._key] = l), l;
        Xn(e, t._attributeData);
        const h = e.buffers;
        (l = r.createVertexArray()), r.bindVertexArray(l);
        for (let u = 0; u < h.length; u++) {
          const o = h[u];
          s.bind(o);
        }
        return this.activateVao(e, t), (a[t._key] = l), (a[n] = l), r.bindVertexArray(null), l;
      }
      onGeometryDestroy(e, t) {
        const A = this._geometryVaoHash[e.uid],
          r = this.gl;
        if (A) {
          if (t) for (const s in A) this._activeVao !== A[s] && this.unbind(), r.deleteVertexArray(A[s]);
          this._geometryVaoHash[e.uid] = null;
        }
      }
      destroyAll(e = !1) {
        const t = this.gl;
        for (const A in this._geometryVaoHash) {
          if (e)
            for (const r in this._geometryVaoHash[A]) {
              const s = this._geometryVaoHash[A];
              this._activeVao !== s && this.unbind(), t.deleteVertexArray(s[r]);
            }
          this._geometryVaoHash[A] = null;
        }
      }
      activateVao(e, t) {
        const A = this._renderer.gl,
          r = this._renderer.buffer,
          s = e.attributes;
        e.indexBuffer && r.bind(e.indexBuffer);
        let n = null;
        for (const a in s) {
          const l = s[a],
            h = l.buffer,
            u = r.getGlBuffer(h),
            o = t._attributeData[a];
          if (o) {
            n !== u && (r.bind(h), (n = u));
            const c = o.location;
            A.enableVertexAttribArray(c);
            const d = et(l.format),
              f = ud(l.format);
            if (
              (o.format?.substring(1, 4) === 'int'
                ? A.vertexAttribIPointer(c, d.size, f, l.stride, l.offset)
                : A.vertexAttribPointer(c, d.size, f, d.normalised, l.stride, l.offset),
                l.instance)
            )
              if (this.hasInstance) {
                const g = l.divisor ?? 1;
                A.vertexAttribDivisor(c, g);
              } else throw new Error('geometry error, GPU Instancing is not supported on this device');
          }
        }
      }
      draw(e, t, A, r) {
        const { gl: s } = this._renderer,
          n = this._activeGeometry,
          a = oS[e || n.topology];
        if ((r ?? (r = n.instanceCount), n.indexBuffer)) {
          const l = n.indexBuffer.data.BYTES_PER_ELEMENT,
            h = l === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
          r !== 1
            ? s.drawElementsInstanced(a, t || n.indexBuffer.data.length, h, (A || 0) * l, r)
            : s.drawElements(a, t || n.indexBuffer.data.length, h, (A || 0) * l);
        } else r !== 1 ? s.drawArraysInstanced(a, A || 0, t || n.getSize(), r) : s.drawArrays(a, A || 0, t || n.getSize());
        return this;
      }
      unbind() {
        this.gl.bindVertexArray(null), (this._activeVao = null), (this._activeGeometry = null);
      }
      destroy() {
        (this._renderer = null),
          (this.gl = null),
          (this._activeVao = null),
          (this._activeGeometry = null),
          (this._geometryVaoHash = {});
      }
    }
    zn.extension = { type: [M.WebGLSystem], name: 'geometry' };
    const lS = new Bt({ attributes: { aPosition: [-1, -1, 3, -1, -1, 3] } }),
      _n = class dd {
        constructor(e) {
          (this.useBackBuffer = !1), (this._useBackBufferThisRender = !1), (this._renderer = e);
        }
        init(e = {}) {
          const { useBackBuffer: t, antialias: A } = { ...dd.defaultOptions, ...e };
          (this.useBackBuffer = t),
            (this._antialias = A),
            this._renderer.context.supports.msaa ||
            (N('antialiasing, is not supported on when using the back buffer'), (this._antialias = !1)),
            (this._state = Ue.for2d());
          const r = new dt({
            vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
            fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
            name: 'big-triangle',
          });
          this._bigTriangleShader = new ke({ glProgram: r, resources: { uTexture: v.WHITE.source } });
        }
        renderStart(e) {
          const t = this._renderer.renderTarget.getRenderTarget(e.target);
          if (((this._useBackBufferThisRender = this.useBackBuffer && !!t.isRoot), this._useBackBufferThisRender)) {
            const A = this._renderer.renderTarget.getRenderTarget(e.target);
            (this._targetTexture = A.colorTexture), (e.target = this._getBackBufferTexture(A.colorTexture));
          }
        }
        renderEnd() {
          this._presentBackBuffer();
        }
        _presentBackBuffer() {
          const e = this._renderer;
          e.renderTarget.finishRenderPass(),
            this._useBackBufferThisRender &&
            (e.renderTarget.bind(this._targetTexture, !1),
              (this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source),
              e.encoder.draw({ geometry: lS, shader: this._bigTriangleShader, state: this._state }));
        }
        _getBackBufferTexture(e) {
          return (
            (this._backBufferTexture =
              this._backBufferTexture ||
              new v({
                source: new ne({ width: e.width, height: e.height, resolution: e._resolution, antialias: this._antialias }),
              })),
            this._backBufferTexture.source.resize(e.width, e.height, e._resolution),
            this._backBufferTexture
          );
        }
        destroy() {
          this._backBufferTexture && (this._backBufferTexture.destroy(), (this._backBufferTexture = null));
        }
      };
    _n.extension = { type: [M.WebGLSystem], name: 'backBuffer', priority: 1 };
    _n.defaultOptions = { useBackBuffer: !1 };
    let fd = _n;
    class $n {
      constructor(e) {
        (this._colorMaskCache = 15), (this._renderer = e);
      }
      setMask(e) {
        this._colorMaskCache !== e &&
          ((this._colorMaskCache = e), this._renderer.gl.colorMask(!!(e & 8), !!(e & 4), !!(e & 2), !!(e & 1)));
      }
    }
    $n.extension = { type: [M.WebGLSystem], name: 'colorMask' };
    class ea {
      constructor(e) {
        (this.commandFinished = Promise.resolve()), (this._renderer = e);
      }
      setGeometry(e, t) {
        this._renderer.geometry.bind(e, t.glProgram);
      }
      finishRenderPass() { }
      draw(e) {
        const t = this._renderer,
          { geometry: A, shader: r, state: s, skipSync: n, topology: a, size: l, start: h, instanceCount: u } = e;
        t.shader.bind(r, n),
          t.geometry.bind(A, t.shader._activeProgram),
          s && t.state.set(s),
          t.geometry.draw(a, l, h, u ?? A.instanceCount);
      }
      destroy() {
        this._renderer = null;
      }
    }
    ea.extension = { type: [M.WebGLSystem], name: 'encoder' };
    class ta {
      constructor(e) {
        this._renderer = e;
      }
      contextChange() {
        const e = this._renderer.gl;
        (this.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)), (this.maxBatchableTextures = Sn(this.maxTextures, e));
        const t = this._renderer.context.webGLVersion === 2;
        this.maxUniformBindings = t ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
      }
      destroy() { }
    }
    ta.extension = { type: [M.WebGLSystem], name: 'limits' };
    class pd {
      constructor() {
        (this.width = -1), (this.height = -1), (this.msaa = !1), (this.msaaRenderBuffer = []);
      }
    }
    const rt = [];
    rt[ie.NONE] = void 0;
    rt[ie.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 };
    rt[ie.RENDERING_MASK_ADD] = {
      stencilFront: { compare: 'equal', passOp: 'increment-clamp' },
      stencilBack: { compare: 'equal', passOp: 'increment-clamp' },
    };
    rt[ie.RENDERING_MASK_REMOVE] = {
      stencilFront: { compare: 'equal', passOp: 'decrement-clamp' },
      stencilBack: { compare: 'equal', passOp: 'decrement-clamp' },
    };
    rt[ie.MASK_ACTIVE] = {
      stencilWriteMask: 0,
      stencilFront: { compare: 'equal', passOp: 'keep' },
      stencilBack: { compare: 'equal', passOp: 'keep' },
    };
    rt[ie.INVERSE_MASK_ACTIVE] = {
      stencilWriteMask: 0,
      stencilFront: { compare: 'not-equal', passOp: 'keep' },
      stencilBack: { compare: 'not-equal', passOp: 'keep' },
    };
    class Aa {
      constructor(e) {
        (this._stencilCache = { enabled: !1, stencilReference: 0, stencilMode: ie.NONE }),
          (this._renderTargetStencilState = Object.create(null)),
          e.renderTarget.onRenderTargetChange.add(this);
      }
      contextChange(e) {
        (this._gl = e),
          (this._comparisonFuncMapping = {
            always: e.ALWAYS,
            never: e.NEVER,
            equal: e.EQUAL,
            'not-equal': e.NOTEQUAL,
            less: e.LESS,
            'less-equal': e.LEQUAL,
            greater: e.GREATER,
            'greater-equal': e.GEQUAL,
          }),
          (this._stencilOpsMapping = {
            keep: e.KEEP,
            zero: e.ZERO,
            replace: e.REPLACE,
            invert: e.INVERT,
            'increment-clamp': e.INCR,
            'decrement-clamp': e.DECR,
            'increment-wrap': e.INCR_WRAP,
            'decrement-wrap': e.DECR_WRAP,
          }),
          this.resetState();
      }
      onRenderTargetChange(e) {
        if (this._activeRenderTarget === e) return;
        this._activeRenderTarget = e;
        let t = this._renderTargetStencilState[e.uid];
        t || (t = this._renderTargetStencilState[e.uid] = { stencilMode: ie.DISABLED, stencilReference: 0 }),
          this.setStencilMode(t.stencilMode, t.stencilReference);
      }
      resetState() {
        (this._stencilCache.enabled = !1),
          (this._stencilCache.stencilMode = ie.NONE),
          (this._stencilCache.stencilReference = 0);
      }
      setStencilMode(e, t) {
        const A = this._renderTargetStencilState[this._activeRenderTarget.uid],
          r = this._gl,
          s = rt[e],
          n = this._stencilCache;
        if (((A.stencilMode = e), (A.stencilReference = t), e === ie.DISABLED)) {
          this._stencilCache.enabled && ((this._stencilCache.enabled = !1), r.disable(r.STENCIL_TEST));
          return;
        }
        this._stencilCache.enabled || ((this._stencilCache.enabled = !0), r.enable(r.STENCIL_TEST)),
          (e !== n.stencilMode || n.stencilReference !== t) &&
          ((n.stencilMode = e),
            (n.stencilReference = t),
            r.stencilFunc(this._comparisonFuncMapping[s.stencilBack.compare], t, 255),
            r.stencilOp(r.KEEP, r.KEEP, this._stencilOpsMapping[s.stencilBack.passOp]));
      }
    }
    Aa.extension = { type: [M.WebGLSystem], name: 'stencil' };
    class ia {
      constructor(e) {
        (this._syncFunctionHash = Object.create(null)), (this._adaptor = e), this._systemCheck();
      }
      _systemCheck() {
        if (!ln())
          throw new Error(
            'Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.'
          );
      }
      ensureUniformGroup(e) {
        const t = this.getUniformGroupData(e);
        e.buffer || (e.buffer = new be({ data: new Float32Array(t.layout.size / 4), usage: K.UNIFORM | K.COPY_DST }));
      }
      getUniformGroupData(e) {
        return this._syncFunctionHash[e._signature] || this._initUniformGroup(e);
      }
      _initUniformGroup(e) {
        const t = e._signature;
        let A = this._syncFunctionHash[t];
        if (!A) {
          const r = Object.keys(e.uniformStructures).map((a) => e.uniformStructures[a]),
            s = this._adaptor.createUboElements(r),
            n = this._generateUboSync(s.uboElements);
          A = this._syncFunctionHash[t] = { layout: s, syncFunction: n };
        }
        return this._syncFunctionHash[t];
      }
      _generateUboSync(e) {
        return this._adaptor.generateUboSync(e);
      }
      syncUniformGroup(e, t, A) {
        const r = this.getUniformGroupData(e);
        e.buffer || (e.buffer = new be({ data: new Float32Array(r.layout.size / 4), usage: K.UNIFORM | K.COPY_DST }));
        let s = null;
        return t || ((t = e.buffer.data), (s = e.buffer.dataInt32)), A || (A = 0), r.syncFunction(e.uniforms, t, s, A), !0;
      }
      updateUniformGroup(e) {
        if (e.isStatic && !e._dirtyId) return !1;
        e._dirtyId = 0;
        const t = this.syncUniformGroup(e);
        return e.buffer.update(), t;
      }
      destroy() {
        this._syncFunctionHash = null;
      }
    }
    const ra = {
      f32: 4,
      i32: 4,
      'vec2<f32>': 8,
      'vec3<f32>': 12,
      'vec4<f32>': 16,
      'vec2<i32>': 8,
      'vec3<i32>': 12,
      'vec4<i32>': 16,
      'mat2x2<f32>': 32,
      'mat3x3<f32>': 48,
      'mat4x4<f32>': 64,
    };
    function gd(i) {
      const e = i.map((s) => ({ data: s, offset: 0, size: 0 })),
        t = 16;
      let A = 0,
        r = 0;
      for (let s = 0; s < e.length; s++) {
        const n = e[s];
        if (((A = ra[n.data.type]), !A)) throw new Error(`Unknown type ${n.data.type}`);
        n.data.size > 1 && (A = Math.max(A, t) * n.data.size);
        const a = A === 12 ? 16 : A;
        n.size = A;
        const l = r % t;
        l > 0 && t - l < a ? (r += (t - l) % 16) : (r += (A - (l % A)) % A), (n.offset = r), (r += A);
      }
      return (r = Math.ceil(r / 16) * 16), { uboElements: e, size: r };
    }
    const ht = [
      {
        type: 'mat3x3<f32>',
        test: (i) => i.value.a !== void 0,
        ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
        uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `,
      },
      {
        type: 'vec4<f32>',
        test: (i) => i.type === 'vec4<f32>' && i.size === 1 && i.value.width !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `,
      },
      {
        type: 'vec2<f32>',
        test: (i) => i.type === 'vec2<f32>' && i.size === 1 && i.value.x !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `,
      },
      {
        type: 'vec4<f32>',
        test: (i) => i.type === 'vec4<f32>' && i.size === 1 && i.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `,
      },
      {
        type: 'vec3<f32>',
        test: (i) => i.type === 'vec3<f32>' && i.size === 1 && i.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `,
      },
    ];
    function sa(i, e, t, A) {
      const r = [
        `
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `,
      ];
      let s = 0;
      for (let a = 0; a < i.length; a++) {
        const l = i[a],
          h = l.data.name;
        let u = !1,
          o = 0;
        for (let c = 0; c < ht.length; c++)
          if (ht[c].test(l.data)) {
            (o = l.offset / 4), r.push(`name = "${h}";`, `offset += ${o - s};`, ht[c][e] || ht[c].ubo), (u = !0);
            break;
          }
        if (!u)
          if (l.data.size > 1) (o = l.offset / 4), r.push(t(l, o - s));
          else {
            const c = A[l.data.type];
            (o = l.offset / 4),
              r.push(`
                    v = uv.${h};
                    offset += ${o - s};
                    ${c};
                `);
          }
        s = o;
      }
      const n = r.join(`
`);
      return new Function('uv', 'data', 'dataInt32', 'offset', n);
    }
    function Jt(i, e) {
      return `
        for (let i = 0; i < ${i * e}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `;
    }
    const na = {
      f32: `
        data[offset] = v;`,
      i32: `
        dataInt32[offset] = v;`,
      'vec2<f32>': `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
      'vec3<f32>': `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
      'vec4<f32>': `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
      'vec2<i32>': `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
      'vec3<i32>': `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
      'vec4<i32>': `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
      'mat2x2<f32>': `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
      'mat3x3<f32>': `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
      'mat4x4<f32>': `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
      'mat3x2<f32>': Jt(3, 2),
      'mat4x2<f32>': Jt(4, 2),
      'mat2x3<f32>': Jt(2, 3),
      'mat4x3<f32>': Jt(4, 3),
      'mat2x4<f32>': Jt(2, 4),
      'mat3x4<f32>': Jt(3, 4),
    },
      md = {
        ...na,
        'mat2x2<f32>': `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `,
      };
    function Sd(i, e) {
      const t = Math.max(ra[i.data.type] / 16, 1),
        A = i.data.value.length / i.data.size,
        r = (4 - (A % 4)) % 4,
        s = i.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';
      return `
        v = uv.${i.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i.data.size * t}; i++)
        {
            for(var j = 0; j < ${A}; j++)
            {
                ${s}[arrayOffset++] = v[t++];
            }
            ${r !== 0 ? `arrayOffset += ${r};` : ''}
        }
    `;
    }
    function qd(i) {
      return sa(i, 'uboStd40', Sd, na);
    }
    class aa extends ia {
      constructor() {
        super({ createUboElements: gd, generateUboSync: qd });
      }
    }
    aa.extension = { type: [M.WebGLSystem], name: 'ubo' };
    class Md {
      constructor() {
        (this._clearColorCache = [0, 0, 0, 0]), (this._viewPortCache = new F());
      }
      init(e, t) {
        (this._renderer = e), (this._renderTargetSystem = t), e.runners.contextChange.add(this);
      }
      contextChange() {
        (this._clearColorCache = [0, 0, 0, 0]), (this._viewPortCache = new F());
      }
      copyToTexture(e, t, A, r, s) {
        const n = this._renderTargetSystem,
          a = this._renderer,
          l = n.getGpuRenderTarget(e),
          h = a.gl;
        return (
          this.finishRenderPass(e),
          h.bindFramebuffer(h.FRAMEBUFFER, l.resolveTargetFramebuffer),
          a.texture.bind(t, 0),
          h.copyTexSubImage2D(h.TEXTURE_2D, 0, s.x, s.y, A.x, A.y, r.width, r.height),
          t
        );
      }
      startRenderPass(e, t = !0, A, r) {
        const s = this._renderTargetSystem,
          n = e.colorTexture,
          a = s.getGpuRenderTarget(e);
        let l = r.y;
        e.isRoot && (l = n.pixelHeight - r.height),
          e.colorTextures.forEach((o) => {
            this._renderer.texture.unbind(o);
          });
        const h = this._renderer.gl;
        h.bindFramebuffer(h.FRAMEBUFFER, a.framebuffer);
        const u = this._viewPortCache;
        (u.x !== r.x || u.y !== l || u.width !== r.width || u.height !== r.height) &&
          ((u.x = r.x), (u.y = l), (u.width = r.width), (u.height = r.height), h.viewport(r.x, l, r.width, r.height)),
          !a.depthStencilRenderBuffer && (e.stencil || e.depth) && this._initStencil(a),
          this.clear(e, t, A);
      }
      finishRenderPass(e) {
        const A = this._renderTargetSystem.getGpuRenderTarget(e);
        if (!A.msaa) return;
        const r = this._renderer.gl;
        r.bindFramebuffer(r.FRAMEBUFFER, A.resolveTargetFramebuffer),
          r.bindFramebuffer(r.READ_FRAMEBUFFER, A.framebuffer),
          r.blitFramebuffer(0, 0, A.width, A.height, 0, 0, A.width, A.height, r.COLOR_BUFFER_BIT, r.NEAREST),
          r.bindFramebuffer(r.FRAMEBUFFER, A.framebuffer);
      }
      initGpuRenderTarget(e) {
        const A = this._renderer.gl,
          r = new pd();
        return e.colorTexture instanceof Oe
          ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource), (r.framebuffer = null), r)
          : (this._initColor(e, r), A.bindFramebuffer(A.FRAMEBUFFER, null), r);
      }
      destroyGpuRenderTarget(e) {
        const t = this._renderer.gl;
        e.framebuffer && (t.deleteFramebuffer(e.framebuffer), (e.framebuffer = null)),
          e.resolveTargetFramebuffer && (t.deleteFramebuffer(e.resolveTargetFramebuffer), (e.resolveTargetFramebuffer = null)),
          e.depthStencilRenderBuffer && (t.deleteRenderbuffer(e.depthStencilRenderBuffer), (e.depthStencilRenderBuffer = null)),
          e.msaaRenderBuffer.forEach((A) => {
            t.deleteRenderbuffer(A);
          }),
          (e.msaaRenderBuffer = null);
      }
      clear(e, t, A) {
        if (!t) return;
        const r = this._renderTargetSystem;
        typeof t == 'boolean' && (t = t ? Ve.ALL : Ve.NONE);
        const s = this._renderer.gl;
        if (t & Ve.COLOR) {
          A ?? (A = r.defaultClearColor);
          const n = this._clearColorCache,
            a = A;
          (n[0] !== a[0] || n[1] !== a[1] || n[2] !== a[2] || n[3] !== a[3]) &&
            ((n[0] = a[0]), (n[1] = a[1]), (n[2] = a[2]), (n[3] = a[3]), s.clearColor(a[0], a[1], a[2], a[3]));
        }
        s.clear(t);
      }
      resizeGpuRenderTarget(e) {
        if (e.isRoot) return;
        const A = this._renderTargetSystem.getGpuRenderTarget(e);
        this._resizeColor(e, A), (e.stencil || e.depth) && this._resizeStencil(A);
      }
      _initColor(e, t) {
        const A = this._renderer,
          r = A.gl,
          s = r.createFramebuffer();
        if (
          ((t.resolveTargetFramebuffer = s),
            r.bindFramebuffer(r.FRAMEBUFFER, s),
            (t.width = e.colorTexture.source.pixelWidth),
            (t.height = e.colorTexture.source.pixelHeight),
            e.colorTextures.forEach((n, a) => {
              const l = n.source;
              l.antialias &&
                (A.context.supports.msaa
                  ? (t.msaa = !0)
                  : N('[RenderTexture] Antialiasing on textures is not supported in WebGL1')),
                A.texture.bindSource(l, 0);
              const u = A.texture.getGlSource(l).texture;
              r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + a, 3553, u, 0);
            }),
            t.msaa)
        ) {
          const n = r.createFramebuffer();
          (t.framebuffer = n),
            r.bindFramebuffer(r.FRAMEBUFFER, n),
            e.colorTextures.forEach((a, l) => {
              const h = r.createRenderbuffer();
              t.msaaRenderBuffer[l] = h;
            });
        } else t.framebuffer = s;
        this._resizeColor(e, t);
      }
      _resizeColor(e, t) {
        const A = e.colorTexture.source;
        if (
          ((t.width = A.pixelWidth),
            (t.height = A.pixelHeight),
            e.colorTextures.forEach((r, s) => {
              s !== 0 && r.source.resize(A.width, A.height, A._resolution);
            }),
            t.msaa)
        ) {
          const r = this._renderer,
            s = r.gl,
            n = t.framebuffer;
          s.bindFramebuffer(s.FRAMEBUFFER, n),
            e.colorTextures.forEach((a, l) => {
              const h = a.source;
              r.texture.bindSource(h, 0);
              const o = r.texture.getGlSource(h).internalFormat,
                c = t.msaaRenderBuffer[l];
              s.bindRenderbuffer(s.RENDERBUFFER, c),
                s.renderbufferStorageMultisample(s.RENDERBUFFER, 4, o, h.pixelWidth, h.pixelHeight),
                s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + l, s.RENDERBUFFER, c);
            });
        }
      }
      _initStencil(e) {
        if (e.framebuffer === null) return;
        const t = this._renderer.gl,
          A = t.createRenderbuffer();
        (e.depthStencilRenderBuffer = A),
          t.bindRenderbuffer(t.RENDERBUFFER, A),
          t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, A),
          this._resizeStencil(e);
      }
      _resizeStencil(e) {
        const t = this._renderer.gl;
        t.bindRenderbuffer(t.RENDERBUFFER, e.depthStencilRenderBuffer),
          e.msaa
            ? t.renderbufferStorageMultisample(t.RENDERBUFFER, 4, t.DEPTH24_STENCIL8, e.width, e.height)
            : t.renderbufferStorage(
              t.RENDERBUFFER,
              this._renderer.context.webGLVersion === 2 ? t.DEPTH24_STENCIL8 : t.DEPTH_STENCIL,
              e.width,
              e.height
            );
      }
      prerender(e) {
        const t = e.colorTexture.resource;
        this._renderer.context.multiView && Oe.test(t) && this._renderer.context.ensureCanvasSize(t);
      }
      postrender(e) {
        if (this._renderer.context.multiView && Oe.test(e.colorTexture.resource)) {
          const t = this._renderer.context.canvas,
            A = e.colorTexture;
          A.context2D.drawImage(t, 0, A.pixelHeight - t.height);
        }
      }
    }
    function Ed(i, e, t, A, r, s) {
      const n = s ? 1 : -1;
      return i.identity(), (i.a = (1 / A) * 2), (i.d = n * ((1 / r) * 2)), (i.tx = -1 - e * i.a), (i.ty = -n - t * i.d), i;
    }
    const Kt = new Map();
    kt.register(Kt);
    function oa(i, e) {
      if (!Kt.has(i)) {
        const t = new v({ source: new Oe({ resource: i, ...e }) }),
          A = () => {
            Kt.get(i) === t && Kt.delete(i);
          };
        t.once('destroy', A), t.source.once('destroy', A), Kt.set(i, t);
      }
      return Kt.get(i);
    }
    function Vd(i) {
      const e = i.colorTexture.source.resource;
      return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement && document.body.contains(e);
    }
    const Td = class Id {
      constructor(e = {}) {
        if (
          ((this.uid = z('renderTarget')),
            (this.colorTextures = []),
            (this.dirtyId = 0),
            (this.isRoot = !1),
            (this._size = new Float32Array(2)),
            (this._managedColorTextures = !1),
            (e = { ...Id.defaultOptions, ...e }),
            (this.stencil = e.stencil),
            (this.depth = e.depth),
            (this.isRoot = e.isRoot),
            typeof e.colorTextures == 'number')
        ) {
          this._managedColorTextures = !0;
          for (let t = 0; t < e.colorTextures; t++)
            this.colorTextures.push(
              new ne({ width: e.width, height: e.height, resolution: e.resolution, antialias: e.antialias })
            );
        } else {
          this.colorTextures = [...e.colorTextures.map((A) => A.source)];
          const t = this.colorTexture.source;
          this.resize(t.width, t.height, t._resolution);
        }
        this.colorTexture.source.on('resize', this.onSourceResize, this),
          (e.depthStencilTexture || this.stencil) &&
          (e.depthStencilTexture instanceof v || e.depthStencilTexture instanceof ne
            ? (this.depthStencilTexture = e.depthStencilTexture.source)
            : this.ensureDepthStencilTexture());
      }
      get size() {
        const e = this._size;
        return (e[0] = this.pixelWidth), (e[1] = this.pixelHeight), e;
      }
      get width() {
        return this.colorTexture.source.width;
      }
      get height() {
        return this.colorTexture.source.height;
      }
      get pixelWidth() {
        return this.colorTexture.source.pixelWidth;
      }
      get pixelHeight() {
        return this.colorTexture.source.pixelHeight;
      }
      get resolution() {
        return this.colorTexture.source._resolution;
      }
      get colorTexture() {
        return this.colorTextures[0];
      }
      onSourceResize(e) {
        this.resize(e.width, e.height, e._resolution, !0);
      }
      ensureDepthStencilTexture() {
        this.depthStencilTexture ||
          (this.depthStencilTexture = new ne({
            width: this.width,
            height: this.height,
            resolution: this.resolution,
            format: 'depth24plus-stencil8',
            autoGenerateMipmaps: !1,
            antialias: !1,
            mipLevelCount: 1,
          }));
      }
      resize(e, t, A = this.resolution, r = !1) {
        this.dirtyId++,
          this.colorTextures.forEach((s, n) => {
            (r && n === 0) || s.source.resize(e, t, A);
          }),
          this.depthStencilTexture && this.depthStencilTexture.source.resize(e, t, A);
      }
      destroy() {
        this.colorTexture.source.off('resize', this.onSourceResize, this),
          this._managedColorTextures &&
          this.colorTextures.forEach((e) => {
            e.destroy();
          }),
          this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
      }
    };
    Td.defaultOptions = {
      width: 0,
      height: 0,
      resolution: 1,
      colorTextures: 1,
      stencil: !1,
      depth: !1,
      antialias: !1,
      isRoot: !1,
    };
    let Gi = Td;
    class la {
      constructor(e) {
        (this.rootViewPort = new F()),
          (this.viewport = new F()),
          (this.onRenderTargetChange = new hn('onRenderTargetChange')),
          (this.projectionMatrix = new R()),
          (this.defaultClearColor = [0, 0, 0, 0]),
          (this._renderSurfaceToRenderTargetHash = new Map()),
          (this._gpuRenderTargetHash = Object.create(null)),
          (this._renderTargetStack = []),
          (this._renderer = e),
          e.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');
      }
      finishRenderPass() {
        this.adaptor.finishRenderPass(this.renderTarget);
      }
      renderStart({ target: e, clear: t, clearColor: A, frame: r }) {
        (this._renderTargetStack.length = 0),
          this.push(e, t, A, r),
          this.rootViewPort.copyFrom(this.viewport),
          (this.rootRenderTarget = this.renderTarget),
          (this.renderingToScreen = Vd(this.rootRenderTarget)),
          this.adaptor.prerender?.(this.rootRenderTarget);
      }
      postrender() {
        this.adaptor.postrender?.(this.rootRenderTarget);
      }
      bind(e, t = !0, A, r) {
        const s = this.getRenderTarget(e),
          n = this.renderTarget !== s;
        (this.renderTarget = s), (this.renderSurface = e);
        const a = this.getGpuRenderTarget(s);
        (s.pixelWidth !== a.width || s.pixelHeight !== a.height) &&
          (this.adaptor.resizeGpuRenderTarget(s), (a.width = s.pixelWidth), (a.height = s.pixelHeight));
        const l = s.colorTexture,
          h = this.viewport,
          u = l.pixelWidth,
          o = l.pixelHeight;
        if ((!r && e instanceof v && (r = e.frame), r)) {
          const c = l._resolution;
          (h.x = (r.x * c + 0.5) | 0),
            (h.y = (r.y * c + 0.5) | 0),
            (h.width = (r.width * c + 0.5) | 0),
            (h.height = (r.height * c + 0.5) | 0);
        } else (h.x = 0), (h.y = 0), (h.width = u), (h.height = o);
        return (
          Ed(this.projectionMatrix, 0, 0, h.width / l.resolution, h.height / l.resolution, !s.isRoot),
          this.adaptor.startRenderPass(s, t, A, h),
          n && this.onRenderTargetChange.emit(s),
          s
        );
      }
      clear(e, t = Ve.ALL, A) {
        t && (e && (e = this.getRenderTarget(e)), this.adaptor.clear(e || this.renderTarget, t, A, this.viewport));
      }
      contextChange() {
        this._gpuRenderTargetHash = Object.create(null);
      }
      push(e, t = Ve.ALL, A, r) {
        const s = this.bind(e, t, A, r);
        return this._renderTargetStack.push({ renderTarget: s, frame: r }), s;
      }
      pop() {
        this._renderTargetStack.pop();
        const e = this._renderTargetStack[this._renderTargetStack.length - 1];
        this.bind(e.renderTarget, !1, null, e.frame);
      }
      getRenderTarget(e) {
        return e.isTexture && (e = e.source), this._renderSurfaceToRenderTargetHash.get(e) ?? this._initRenderTarget(e);
      }
      copyToTexture(e, t, A, r, s) {
        A.x < 0 && ((r.width += A.x), (s.x -= A.x), (A.x = 0)), A.y < 0 && ((r.height += A.y), (s.y -= A.y), (A.y = 0));
        const { pixelWidth: n, pixelHeight: a } = e;
        return (
          (r.width = Math.min(r.width, n - A.x)),
          (r.height = Math.min(r.height, a - A.y)),
          this.adaptor.copyToTexture(e, t, A, r, s)
        );
      }
      ensureDepthStencil() {
        this.renderTarget.stencil ||
          ((this.renderTarget.stencil = !0), this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport));
      }
      destroy() {
        (this._renderer = null),
          this._renderSurfaceToRenderTargetHash.forEach((e, t) => {
            e !== t && e.destroy();
          }),
          this._renderSurfaceToRenderTargetHash.clear(),
          (this._gpuRenderTargetHash = Object.create(null));
      }
      _initRenderTarget(e) {
        let t = null;
        return (
          Oe.test(e) && (e = oa(e).source),
          e instanceof Gi
            ? (t = e)
            : e instanceof ne &&
            ((t = new Gi({ colorTextures: [e] })),
              e.source instanceof Oe && (t.isRoot = !0),
              e.once('destroy', () => {
                t.destroy(), this._renderSurfaceToRenderTargetHash.delete(e);
                const A = this._gpuRenderTargetHash[t.uid];
                A && ((this._gpuRenderTargetHash[t.uid] = null), this.adaptor.destroyGpuRenderTarget(A));
              })),
          this._renderSurfaceToRenderTargetHash.set(e, t),
          t
        );
      }
      getGpuRenderTarget(e) {
        return this._gpuRenderTargetHash[e.uid] || (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e));
      }
      resetState() {
        (this.renderTarget = null), (this.renderSurface = null);
      }
    }
    class ha extends la {
      constructor(e) {
        super(e), (this.adaptor = new Md()), this.adaptor.init(e, this);
      }
    }
    ha.extension = { type: [M.WebGLSystem], name: 'renderTarget' };
    class cr extends ye {
      constructor({ buffer: e, offset: t, size: A }) {
        super(),
          (this.uid = z('buffer')),
          (this._resourceType = 'bufferResource'),
          (this._touched = 0),
          (this._resourceId = z('resource')),
          (this._bufferResource = !0),
          (this.destroyed = !1),
          (this.buffer = e),
          (this.offset = t | 0),
          (this.size = A),
          this.buffer.on('change', this.onBufferChange, this);
      }
      onBufferChange() {
        (this._resourceId = z('resource')), this.emit('change', this);
      }
      destroy(e = !1) {
        (this.destroyed = !0),
          e && this.buffer.destroy(),
          this.emit('change', this),
          (this.buffer = null),
          this.removeAllListeners();
      }
    }
    function bd(i, e) {
      const t = [],
        A = [
          `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `,
        ];
      let r = !1,
        s = 0;
      const n = e._getProgramData(i.glProgram);
      for (const l in i.groups) {
        const h = i.groups[l];
        t.push(`
            resources = g[${l}].resources;
        `);
        for (const u in h.resources) {
          const o = h.resources[u];
          if (o instanceof qe)
            if (o.ubo) {
              const c = i._uniformBindMap[l][Number(u)];
              t.push(`
                        sS.bindUniformBlock(
                            resources[${u}],
                            '${c}',
                            ${i.glProgram._uniformBlockData[c].index}
                        );
                    `);
            } else
              t.push(`
                        ugS.updateUniformGroup(resources[${u}], p, sD);
                    `);
          else if (o instanceof cr) {
            const c = i._uniformBindMap[l][Number(u)];
            t.push(`
                    sS.bindUniformBlock(
                        resources[${u}],
                        '${c}',
                        ${i.glProgram._uniformBlockData[c].index}
                    );
                `);
          } else if (o instanceof ne) {
            const c = i._uniformBindMap[l][u],
              d = n.uniformData[c];
            d &&
              (r ||
                ((r = !0),
                  A.push(`
                        var tS = r.texture;
                        `)),
                e._gl.uniform1i(d.location, s),
                t.push(`
                        tS.bind(resources[${u}], ${s});
                    `),
                s++);
          }
        }
      }
      const a = [...A, ...t].join(`
`);
      return new Function('r', 's', 'sD', a);
    }
    class yd {
      constructor(e, t) {
        (this.program = e),
          (this.uniformData = t),
          (this.uniformGroups = {}),
          (this.uniformDirtyGroups = {}),
          (this.uniformBlockBindings = {});
      }
      destroy() {
        (this.uniformData = null),
          (this.uniformGroups = null),
          (this.uniformDirtyGroups = null),
          (this.uniformBlockBindings = null),
          (this.program = null);
      }
    }
    function Ps(i, e, t) {
      const A = i.createShader(e);
      return i.shaderSource(A, t), i.compileShader(A), A;
    }
    function Zr(i) {
      const e = new Array(i);
      for (let t = 0; t < e.length; t++) e[t] = !1;
      return e;
    }
    function ca(i, e) {
      switch (i) {
        case 'float':
          return 0;
        case 'vec2':
          return new Float32Array(2 * e);
        case 'vec3':
          return new Float32Array(3 * e);
        case 'vec4':
          return new Float32Array(4 * e);
        case 'int':
        case 'uint':
        case 'sampler2D':
        case 'sampler2DArray':
          return 0;
        case 'ivec2':
          return new Int32Array(2 * e);
        case 'ivec3':
          return new Int32Array(3 * e);
        case 'ivec4':
          return new Int32Array(4 * e);
        case 'uvec2':
          return new Uint32Array(2 * e);
        case 'uvec3':
          return new Uint32Array(3 * e);
        case 'uvec4':
          return new Uint32Array(4 * e);
        case 'bool':
          return !1;
        case 'bvec2':
          return Zr(2 * e);
        case 'bvec3':
          return Zr(3 * e);
        case 'bvec4':
          return Zr(4 * e);
        case 'mat2':
          return new Float32Array([1, 0, 0, 1]);
        case 'mat3':
          return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case 'mat4':
          return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      return null;
    }
    let Ei = null;
    const Ul = {
      FLOAT: 'float',
      FLOAT_VEC2: 'vec2',
      FLOAT_VEC3: 'vec3',
      FLOAT_VEC4: 'vec4',
      INT: 'int',
      INT_VEC2: 'ivec2',
      INT_VEC3: 'ivec3',
      INT_VEC4: 'ivec4',
      UNSIGNED_INT: 'uint',
      UNSIGNED_INT_VEC2: 'uvec2',
      UNSIGNED_INT_VEC3: 'uvec3',
      UNSIGNED_INT_VEC4: 'uvec4',
      BOOL: 'bool',
      BOOL_VEC2: 'bvec2',
      BOOL_VEC3: 'bvec3',
      BOOL_VEC4: 'bvec4',
      FLOAT_MAT2: 'mat2',
      FLOAT_MAT3: 'mat3',
      FLOAT_MAT4: 'mat4',
      SAMPLER_2D: 'sampler2D',
      INT_SAMPLER_2D: 'sampler2D',
      UNSIGNED_INT_SAMPLER_2D: 'sampler2D',
      SAMPLER_CUBE: 'samplerCube',
      INT_SAMPLER_CUBE: 'samplerCube',
      UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',
      SAMPLER_2D_ARRAY: 'sampler2DArray',
      INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
      UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
    },
      hS = {
        float: 'float32',
        vec2: 'float32x2',
        vec3: 'float32x3',
        vec4: 'float32x4',
        int: 'sint32',
        ivec2: 'sint32x2',
        ivec3: 'sint32x3',
        ivec4: 'sint32x4',
        uint: 'uint32',
        uvec2: 'uint32x2',
        uvec3: 'uint32x3',
        uvec4: 'uint32x4',
        bool: 'uint32',
        bvec2: 'uint32x2',
        bvec3: 'uint32x3',
        bvec4: 'uint32x4',
      };
    function ua(i, e) {
      if (!Ei) {
        const t = Object.keys(Ul);
        Ei = {};
        for (let A = 0; A < t.length; ++A) {
          const r = t[A];
          Ei[i[r]] = Ul[r];
        }
      }
      return Ei[e];
    }
    function xd(i, e) {
      const t = ua(i, e);
      return hS[t] || 'float32';
    }
    function vd(i, e, t = !1) {
      const A = {},
        r = e.getProgramParameter(i, e.ACTIVE_ATTRIBUTES);
      for (let n = 0; n < r; n++) {
        const a = e.getActiveAttrib(i, n);
        if (a.name.startsWith('gl_')) continue;
        const l = xd(e, a.type);
        A[a.name] = { location: 0, format: l, stride: et(l).stride, offset: 0, instance: !1, start: 0 };
      }
      const s = Object.keys(A);
      if (t) {
        s.sort((n, a) => (n > a ? 1 : -1));
        for (let n = 0; n < s.length; n++) (A[s[n]].location = n), e.bindAttribLocation(i, n, s[n]);
        e.linkProgram(i);
      } else for (let n = 0; n < s.length; n++) A[s[n]].location = e.getAttribLocation(i, s[n]);
      return A;
    }
    function Cd(i, e) {
      if (!e.ACTIVE_UNIFORM_BLOCKS) return {};
      const t = {},
        A = e.getProgramParameter(i, e.ACTIVE_UNIFORM_BLOCKS);
      for (let r = 0; r < A; r++) {
        const s = e.getActiveUniformBlockName(i, r),
          n = e.getUniformBlockIndex(i, s),
          a = e.getActiveUniformBlockParameter(i, r, e.UNIFORM_BLOCK_DATA_SIZE);
        t[s] = { name: s, index: n, size: a };
      }
      return t;
    }
    function Ud(i, e) {
      const t = {},
        A = e.getProgramParameter(i, e.ACTIVE_UNIFORMS);
      for (let r = 0; r < A; r++) {
        const s = e.getActiveUniform(i, r),
          n = s.name.replace(/\[.*?\]$/, ''),
          a = !!s.name.match(/\[.*?\]$/),
          l = ua(e, s.type);
        t[n] = { name: n, index: r, type: l, size: s.size, isArray: a, value: ca(l, s.size) };
      }
      return t;
    }
    function kl(i, e) {
      const t = i
        .getShaderSource(e)
        .split(
          `
`
        )
        .map((h, u) => `${u}: ${h}`),
        r = i.getShaderInfoLog(e).split(`
`),
        s = {},
        n = r
          .map((h) => parseFloat(h.replace(/^ERROR\: 0\:([\d]+)\:.*$/, '$1')))
          .filter((h) => (h && !s[h] ? ((s[h] = !0), !0) : !1)),
        a = [''];
      n.forEach((h) => {
        (t[h - 1] = `%c${t[h - 1]}%c`), a.push('background: #FF0000; color:#FFFFFF; font-size: 10px', 'font-size: 10px');
      });
      const l = t.join(`
`);
      a[0] = l;
    }
    function kd(i, e, t, A) {
      i.getProgramParameter(e, i.LINK_STATUS) ||
        (i.getShaderParameter(t, i.COMPILE_STATUS) || kl(i, t),
          i.getShaderParameter(A, i.COMPILE_STATUS) || kl(i, A),
          i.getProgramInfoLog(e));
    }
    function Rd(i, e) {
      const t = Ps(i, i.VERTEX_SHADER, e.vertex),
        A = Ps(i, i.FRAGMENT_SHADER, e.fragment),
        r = i.createProgram();
      i.attachShader(r, t), i.attachShader(r, A);
      const s = e.transformFeedbackVaryings;
      s &&
        (typeof i.transformFeedbackVaryings != 'function'
          ? N('TransformFeedback is not supported but TransformFeedbackVaryings are given.')
          : i.transformFeedbackVaryings(r, s.names, s.bufferMode === 'separate' ? i.SEPARATE_ATTRIBS : i.INTERLEAVED_ATTRIBS)),
        i.linkProgram(r),
        i.getProgramParameter(r, i.LINK_STATUS) || kd(i, r, t, A),
        (e._attributeData = vd(r, i, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex))),
        (e._uniformData = Ud(r, i)),
        (e._uniformBlockData = Cd(r, i)),
        i.deleteShader(t),
        i.deleteShader(A);
      const n = {};
      for (const l in e._uniformData) {
        const h = e._uniformData[l];
        n[l] = { location: i.getUniformLocation(r, l), value: ca(h.type, h.size) };
      }
      return new yd(r, n);
    }
    const Vi = { textureCount: 0, blockIndex: 0 };
    class da {
      constructor(e) {
        (this._activeProgram = null),
          (this._programDataHash = Object.create(null)),
          (this._shaderSyncFunctions = Object.create(null)),
          (this._renderer = e),
          this._renderer.renderableGC.addManagedHash(this, '_programDataHash');
      }
      contextChange(e) {
        (this._gl = e),
          (this._programDataHash = Object.create(null)),
          (this._shaderSyncFunctions = Object.create(null)),
          (this._activeProgram = null);
      }
      bind(e, t) {
        if ((this._setProgram(e.glProgram), t)) return;
        (Vi.textureCount = 0), (Vi.blockIndex = 0);
        let A = this._shaderSyncFunctions[e.glProgram._key];
        A || (A = this._shaderSyncFunctions[e.glProgram._key] = this._generateShaderSync(e, this)),
          this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings),
          A(this._renderer, e, Vi);
      }
      updateUniformGroup(e) {
        this._renderer.uniformGroup.updateUniformGroup(e, this._activeProgram, Vi);
      }
      bindUniformBlock(e, t, A = 0) {
        const r = this._renderer.buffer,
          s = this._getProgramData(this._activeProgram),
          n = e._bufferResource;
        n || this._renderer.ubo.updateUniformGroup(e);
        const a = e.buffer,
          l = r.updateBuffer(a),
          h = r.freeLocationForBufferBase(l);
        if (n) {
          const { offset: o, size: c } = e;
          o === 0 && c === a.data.byteLength ? r.bindBufferBase(l, h) : r.bindBufferRange(l, h, o);
        } else r.getLastBindBaseLocation(l) !== h && r.bindBufferBase(l, h);
        const u = this._activeProgram._uniformBlockData[t].index;
        s.uniformBlockBindings[A] !== h &&
          ((s.uniformBlockBindings[A] = h), this._renderer.gl.uniformBlockBinding(s.program, u, h));
      }
      _setProgram(e) {
        if (this._activeProgram === e) return;
        this._activeProgram = e;
        const t = this._getProgramData(e);
        this._gl.useProgram(t.program);
      }
      _getProgramData(e) {
        return this._programDataHash[e._key] || this._createProgramData(e);
      }
      _createProgramData(e) {
        const t = e._key;
        return (this._programDataHash[t] = Rd(this._gl, e)), this._programDataHash[t];
      }
      destroy() {
        for (const e of Object.keys(this._programDataHash))
          this._programDataHash[e].destroy(), (this._programDataHash[e] = null);
        (this._programDataHash = null),
          (this._shaderSyncFunctions = null),
          (this._activeProgram = null),
          (this._renderer = null),
          (this._gl = null);
      }
      _generateShaderSync(e, t) {
        return bd(e, t);
      }
      resetState() {
        this._activeProgram = null;
      }
    }
    da.extension = { type: [M.WebGLSystem], name: 'shader' };
    const Bd = {
      f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
      'vec2<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
      'vec3<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
      'vec4<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
      i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
      'vec2<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
      'vec3<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
      'vec4<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
      u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
      'vec2<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
      'vec3<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
      'vec4<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
      bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
      'vec2<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
      'vec3<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
      'vec4<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
      'mat2x2<f32>': 'gl.uniformMatrix2fv(location, false, v);',
      'mat3x3<f32>': 'gl.uniformMatrix3fv(location, false, v);',
      'mat4x4<f32>': 'gl.uniformMatrix4fv(location, false, v);',
    },
      Nd = {
        f32: 'gl.uniform1fv(location, v);',
        'vec2<f32>': 'gl.uniform2fv(location, v);',
        'vec3<f32>': 'gl.uniform3fv(location, v);',
        'vec4<f32>': 'gl.uniform4fv(location, v);',
        'mat2x2<f32>': 'gl.uniformMatrix2fv(location, false, v);',
        'mat3x3<f32>': 'gl.uniformMatrix3fv(location, false, v);',
        'mat4x4<f32>': 'gl.uniformMatrix4fv(location, false, v);',
        i32: 'gl.uniform1iv(location, v);',
        'vec2<i32>': 'gl.uniform2iv(location, v);',
        'vec3<i32>': 'gl.uniform3iv(location, v);',
        'vec4<i32>': 'gl.uniform4iv(location, v);',
        u32: 'gl.uniform1iv(location, v);',
        'vec2<u32>': 'gl.uniform2iv(location, v);',
        'vec3<u32>': 'gl.uniform3iv(location, v);',
        'vec4<u32>': 'gl.uniform4iv(location, v);',
        bool: 'gl.uniform1iv(location, v);',
        'vec2<bool>': 'gl.uniform2iv(location, v);',
        'vec3<bool>': 'gl.uniform3iv(location, v);',
        'vec4<bool>': 'gl.uniform4iv(location, v);',
      };
    function Qd(i, e) {
      const t = [
        `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `,
      ];
      for (const A in i.uniforms) {
        if (!e[A]) {
          i.uniforms[A] instanceof qe
            ? i.uniforms[A].ubo
              ? t.push(`
                        renderer.shader.bindUniformBlock(uv.${A}, "${A}");
                    `)
              : t.push(`
                        renderer.shader.updateUniformGroup(uv.${A});
                    `)
            : i.uniforms[A] instanceof cr &&
            t.push(`
                        renderer.shader.bindBufferResource(uv.${A}, "${A}");
                    `);
          continue;
        }
        const r = i.uniformStructures[A];
        let s = !1;
        for (let n = 0; n < ht.length; n++) {
          const a = ht[n];
          if (r.type === a.type && a.test(r)) {
            t.push(`name = "${A}";`, ht[n].uniform), (s = !0);
            break;
          }
        }
        if (!s) {
          const a = (r.size === 1 ? Bd : Nd)[r.type].replace('location', `ud["${A}"].location`);
          t.push(`
            cu = ud["${A}"];
            cv = cu.value;
            v = uv["${A}"];
            ${a};`);
        }
      }
      return new Function(
        'ud',
        'uv',
        'renderer',
        'syncData',
        t.join(`
`)
      );
    }
    class fa {
      constructor(e) {
        (this._cache = {}), (this._uniformGroupSyncHash = {}), (this._renderer = e), (this.gl = null), (this._cache = {});
      }
      contextChange(e) {
        this.gl = e;
      }
      updateUniformGroup(e, t, A) {
        const r = this._renderer.shader._getProgramData(t);
        (!e.isStatic || e._dirtyId !== r.uniformDirtyGroups[e.uid]) &&
          ((r.uniformDirtyGroups[e.uid] = e._dirtyId),
            this._getUniformSyncFunction(e, t)(r.uniformData, e.uniforms, this._renderer, A));
      }
      _getUniformSyncFunction(e, t) {
        return this._uniformGroupSyncHash[e._signature]?.[t._key] || this._createUniformSyncFunction(e, t);
      }
      _createUniformSyncFunction(e, t) {
        const A = this._uniformGroupSyncHash[e._signature] || (this._uniformGroupSyncHash[e._signature] = {}),
          r = this._getSignature(e, t._uniformData, 'u');
        return (
          this._cache[r] || (this._cache[r] = this._generateUniformsSync(e, t._uniformData)),
          (A[t._key] = this._cache[r]),
          A[t._key]
        );
      }
      _generateUniformsSync(e, t) {
        return Qd(e, t);
      }
      _getSignature(e, t, A) {
        const r = e.uniforms,
          s = [`${A}-`];
        for (const n in r) s.push(n), t[n] && s.push(t[n].type);
        return s.join('-');
      }
      destroy() {
        (this._renderer = null), (this._cache = null);
      }
    }
    fa.extension = { type: [M.WebGLSystem], name: 'uniformGroup' };
    function wd(i) {
      const e = {};
      if (
        ((e.normal = [i.ONE, i.ONE_MINUS_SRC_ALPHA]),
          (e.add = [i.ONE, i.ONE]),
          (e.multiply = [i.DST_COLOR, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA]),
          (e.screen = [i.ONE, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA]),
          (e.none = [0, 0]),
          (e['normal-npm'] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA]),
          (e['add-npm'] = [i.SRC_ALPHA, i.ONE, i.ONE, i.ONE]),
          (e['screen-npm'] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA]),
          (e.erase = [i.ZERO, i.ONE_MINUS_SRC_ALPHA]),
          !(i instanceof J.get().getWebGLRenderingContext()))
      )
        (e.min = [i.ONE, i.ONE, i.ONE, i.ONE, i.MIN, i.MIN]), (e.max = [i.ONE, i.ONE, i.ONE, i.ONE, i.MAX, i.MAX]);
      else {
        const A = i.getExtension('EXT_blend_minmax');
        A &&
          ((e.min = [i.ONE, i.ONE, i.ONE, i.ONE, A.MIN_EXT, A.MIN_EXT]),
            (e.max = [i.ONE, i.ONE, i.ONE, i.ONE, A.MAX_EXT, A.MAX_EXT]));
      }
      return e;
    }
    const cS = 0,
      uS = 1,
      dS = 2,
      fS = 3,
      pS = 4,
      gS = 5,
      Pd = class Js {
        constructor(e) {
          (this._invertFrontFace = !1),
            (this.gl = null),
            (this.stateId = 0),
            (this.polygonOffset = 0),
            (this.blendMode = 'none'),
            (this._blendEq = !1),
            (this.map = []),
            (this.map[cS] = this.setBlend),
            (this.map[uS] = this.setOffset),
            (this.map[dS] = this.setCullFace),
            (this.map[fS] = this.setDepthTest),
            (this.map[pS] = this.setFrontFace),
            (this.map[gS] = this.setDepthMask),
            (this.checks = []),
            (this.defaultState = Ue.for2d()),
            e.renderTarget.onRenderTargetChange.add(this);
        }
        onRenderTargetChange(e) {
          (this._invertFrontFace = !e.isRoot),
            this._cullFace ? this.setFrontFace(this._frontFace) : (this._frontFaceDirty = !0);
        }
        contextChange(e) {
          (this.gl = e), (this.blendModesMap = wd(e)), this.resetState();
        }
        set(e) {
          if ((e || (e = this.defaultState), this.stateId !== e.data)) {
            let t = this.stateId ^ e.data,
              A = 0;
            for (; t;) t & 1 && this.map[A].call(this, !!(e.data & (1 << A))), (t >>= 1), A++;
            this.stateId = e.data;
          }
          for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
        }
        forceState(e) {
          e || (e = this.defaultState);
          for (let t = 0; t < this.map.length; t++) this.map[t].call(this, !!(e.data & (1 << t)));
          for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
          this.stateId = e.data;
        }
        setBlend(e) {
          this._updateCheck(Js._checkBlendMode, e), this.gl[e ? 'enable' : 'disable'](this.gl.BLEND);
        }
        setOffset(e) {
          this._updateCheck(Js._checkPolygonOffset, e), this.gl[e ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
        }
        setDepthTest(e) {
          this.gl[e ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
        }
        setDepthMask(e) {
          this.gl.depthMask(e);
        }
        setCullFace(e) {
          (this._cullFace = e),
            this.gl[e ? 'enable' : 'disable'](this.gl.CULL_FACE),
            this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace);
        }
        setFrontFace(e) {
          (this._frontFace = e), (this._frontFaceDirty = !1);
          const t = this._invertFrontFace ? !e : e;
          this._glFrontFace !== t && ((this._glFrontFace = t), this.gl.frontFace(this.gl[t ? 'CW' : 'CCW']));
        }
        setBlendMode(e) {
          if ((this.blendModesMap[e] || (e = 'normal'), e === this.blendMode)) return;
          this.blendMode = e;
          const t = this.blendModesMap[e],
            A = this.gl;
          t.length === 2 ? A.blendFunc(t[0], t[1]) : A.blendFuncSeparate(t[0], t[1], t[2], t[3]),
            t.length === 6
              ? ((this._blendEq = !0), A.blendEquationSeparate(t[4], t[5]))
              : this._blendEq && ((this._blendEq = !1), A.blendEquationSeparate(A.FUNC_ADD, A.FUNC_ADD));
        }
        setPolygonOffset(e, t) {
          this.gl.polygonOffset(e, t);
        }
        resetState() {
          (this._glFrontFace = !1),
            (this._frontFace = !1),
            (this._cullFace = !1),
            (this._frontFaceDirty = !1),
            (this._invertFrontFace = !1),
            this.gl.frontFace(this.gl.CCW),
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
            this.forceState(this.defaultState),
            (this._blendEq = !0),
            (this.blendMode = ''),
            this.setBlendMode('normal');
        }
        _updateCheck(e, t) {
          const A = this.checks.indexOf(e);
          t && A === -1 ? this.checks.push(e) : !t && A !== -1 && this.checks.splice(A, 1);
        }
        static _checkBlendMode(e, t) {
          e.setBlendMode(t.blendMode);
        }
        static _checkPolygonOffset(e, t) {
          e.setPolygonOffset(1, t.polygonOffset);
        }
        destroy() {
          (this.gl = null), (this.checks.length = 0);
        }
      };
    Pd.extension = { type: [M.WebGLSystem], name: 'state' };
    let Jd = Pd;
    class Gd {
      constructor(e) {
        (this.target = Hn.TEXTURE_2D),
          (this.texture = e),
          (this.width = -1),
          (this.height = -1),
          (this.type = Y.UNSIGNED_BYTE),
          (this.internalFormat = Ji.RGBA),
          (this.format = Ji.RGBA),
          (this.samplerType = 0);
      }
    }
    const Wd = {
      id: 'buffer',
      upload(i, e, t) {
        e.width === i.width || e.height === i.height
          ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, i.width, i.height, e.format, e.type, i.resource)
          : t.texImage2D(e.target, 0, e.internalFormat, i.width, i.height, 0, e.format, e.type, i.resource),
          (e.width = i.width),
          (e.height = i.height);
      },
    },
      mS = {
        'bc1-rgba-unorm': !0,
        'bc1-rgba-unorm-srgb': !0,
        'bc2-rgba-unorm': !0,
        'bc2-rgba-unorm-srgb': !0,
        'bc3-rgba-unorm': !0,
        'bc3-rgba-unorm-srgb': !0,
        'bc4-r-unorm': !0,
        'bc4-r-snorm': !0,
        'bc5-rg-unorm': !0,
        'bc5-rg-snorm': !0,
        'bc6h-rgb-ufloat': !0,
        'bc6h-rgb-float': !0,
        'bc7-rgba-unorm': !0,
        'bc7-rgba-unorm-srgb': !0,
        'etc2-rgb8unorm': !0,
        'etc2-rgb8unorm-srgb': !0,
        'etc2-rgb8a1unorm': !0,
        'etc2-rgb8a1unorm-srgb': !0,
        'etc2-rgba8unorm': !0,
        'etc2-rgba8unorm-srgb': !0,
        'eac-r11unorm': !0,
        'eac-r11snorm': !0,
        'eac-rg11unorm': !0,
        'eac-rg11snorm': !0,
        'astc-4x4-unorm': !0,
        'astc-4x4-unorm-srgb': !0,
        'astc-5x4-unorm': !0,
        'astc-5x4-unorm-srgb': !0,
        'astc-5x5-unorm': !0,
        'astc-5x5-unorm-srgb': !0,
        'astc-6x5-unorm': !0,
        'astc-6x5-unorm-srgb': !0,
        'astc-6x6-unorm': !0,
        'astc-6x6-unorm-srgb': !0,
        'astc-8x5-unorm': !0,
        'astc-8x5-unorm-srgb': !0,
        'astc-8x6-unorm': !0,
        'astc-8x6-unorm-srgb': !0,
        'astc-8x8-unorm': !0,
        'astc-8x8-unorm-srgb': !0,
        'astc-10x5-unorm': !0,
        'astc-10x5-unorm-srgb': !0,
        'astc-10x6-unorm': !0,
        'astc-10x6-unorm-srgb': !0,
        'astc-10x8-unorm': !0,
        'astc-10x8-unorm-srgb': !0,
        'astc-10x10-unorm': !0,
        'astc-10x10-unorm-srgb': !0,
        'astc-12x10-unorm': !0,
        'astc-12x10-unorm-srgb': !0,
        'astc-12x12-unorm': !0,
        'astc-12x12-unorm-srgb': !0,
      },
      Kd = {
        id: 'compressed',
        upload(i, e, t) {
          t.pixelStorei(t.UNPACK_ALIGNMENT, 4);
          let A = i.pixelWidth,
            r = i.pixelHeight;
          const s = !!mS[i.format];
          for (let n = 0; n < i.resource.length; n++) {
            const a = i.resource[n];
            s
              ? t.compressedTexImage2D(t.TEXTURE_2D, n, e.internalFormat, A, r, 0, a)
              : t.texImage2D(t.TEXTURE_2D, n, e.internalFormat, A, r, 0, e.format, e.type, a),
              (A = Math.max(A >> 1, 1)),
              (r = Math.max(r >> 1, 1));
          }
        },
      },
      pa = {
        id: 'image',
        upload(i, e, t, A) {
          const r = e.width,
            s = e.height,
            n = i.pixelWidth,
            a = i.pixelHeight,
            l = i.resourceWidth,
            h = i.resourceHeight;
          l < n || h < a
            ? ((r !== n || s !== a) && t.texImage2D(e.target, 0, e.internalFormat, n, a, 0, e.format, e.type, null),
              A === 2
                ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, l, h, e.format, e.type, i.resource)
                : t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource))
            : r === n && s === a
              ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, i.resource)
              : A === 2
                ? t.texImage2D(e.target, 0, e.internalFormat, n, a, 0, e.format, e.type, i.resource)
                : t.texImage2D(e.target, 0, e.internalFormat, e.format, e.type, i.resource),
            (e.width = n),
            (e.height = a);
        },
      },
      Fd = {
        id: 'video',
        upload(i, e, t, A) {
          if (!i.isValid) {
            t.texImage2D(e.target, 0, e.internalFormat, 1, 1, 0, e.format, e.type, null);
            return;
          }
          pa.upload(i, e, t, A);
        },
      },
      Gs = { linear: 9729, nearest: 9728 },
      Yd = { linear: { linear: 9987, nearest: 9985 }, nearest: { linear: 9986, nearest: 9984 } },
      Ci = { 'clamp-to-edge': 33071, repeat: 10497, 'mirror-repeat': 33648 },
      Dd = {
        never: 512,
        less: 513,
        equal: 514,
        'less-equal': 515,
        greater: 516,
        'not-equal': 517,
        'greater-equal': 518,
        always: 519,
      };
    function Ws(i, e, t, A, r, s, n, a) {
      const l = s;
      if (!a || i.addressModeU !== 'repeat' || i.addressModeV !== 'repeat' || i.addressModeW !== 'repeat') {
        const h = Ci[n ? 'clamp-to-edge' : i.addressModeU],
          u = Ci[n ? 'clamp-to-edge' : i.addressModeV],
          o = Ci[n ? 'clamp-to-edge' : i.addressModeW];
        e[r](l, e.TEXTURE_WRAP_S, h), e[r](l, e.TEXTURE_WRAP_T, u), e.TEXTURE_WRAP_R && e[r](l, e.TEXTURE_WRAP_R, o);
      }
      if (((!a || i.magFilter !== 'linear') && e[r](l, e.TEXTURE_MAG_FILTER, Gs[i.magFilter]), t)) {
        if (!a || i.mipmapFilter !== 'linear') {
          const h = Yd[i.minFilter][i.mipmapFilter];
          e[r](l, e.TEXTURE_MIN_FILTER, h);
        }
      } else e[r](l, e.TEXTURE_MIN_FILTER, Gs[i.minFilter]);
      if (A && i.maxAnisotropy > 1) {
        const h = Math.min(i.maxAnisotropy, e.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        e[r](l, A.TEXTURE_MAX_ANISOTROPY_EXT, h);
      }
      i.compare && e[r](l, e.TEXTURE_COMPARE_FUNC, Dd[i.compare]);
    }
    function Od(i) {
      return {
        r8unorm: i.RED,
        r8snorm: i.RED,
        r8uint: i.RED,
        r8sint: i.RED,
        r16uint: i.RED,
        r16sint: i.RED,
        r16float: i.RED,
        rg8unorm: i.RG,
        rg8snorm: i.RG,
        rg8uint: i.RG,
        rg8sint: i.RG,
        r32uint: i.RED,
        r32sint: i.RED,
        r32float: i.RED,
        rg16uint: i.RG,
        rg16sint: i.RG,
        rg16float: i.RG,
        rgba8unorm: i.RGBA,
        'rgba8unorm-srgb': i.RGBA,
        rgba8snorm: i.RGBA,
        rgba8uint: i.RGBA,
        rgba8sint: i.RGBA,
        bgra8unorm: i.RGBA,
        'bgra8unorm-srgb': i.RGBA,
        rgb9e5ufloat: i.RGB,
        rgb10a2unorm: i.RGBA,
        rg11b10ufloat: i.RGB,
        rg32uint: i.RG,
        rg32sint: i.RG,
        rg32float: i.RG,
        rgba16uint: i.RGBA,
        rgba16sint: i.RGBA,
        rgba16float: i.RGBA,
        rgba32uint: i.RGBA,
        rgba32sint: i.RGBA,
        rgba32float: i.RGBA,
        stencil8: i.STENCIL_INDEX8,
        depth16unorm: i.DEPTH_COMPONENT,
        depth24plus: i.DEPTH_COMPONENT,
        'depth24plus-stencil8': i.DEPTH_STENCIL,
        depth32float: i.DEPTH_COMPONENT,
        'depth32float-stencil8': i.DEPTH_STENCIL,
      };
    }
    function Ld(i, e) {
      let t = {},
        A = i.RGBA;
      return (
        i instanceof J.get().getWebGLRenderingContext()
          ? e.srgb && (t = { 'rgba8unorm-srgb': e.srgb.SRGB8_ALPHA8_EXT, 'bgra8unorm-srgb': e.srgb.SRGB8_ALPHA8_EXT })
          : ((t = { 'rgba8unorm-srgb': i.SRGB8_ALPHA8, 'bgra8unorm-srgb': i.SRGB8_ALPHA8 }), (A = i.RGBA8)),
        {
          r8unorm: i.R8,
          r8snorm: i.R8_SNORM,
          r8uint: i.R8UI,
          r8sint: i.R8I,
          r16uint: i.R16UI,
          r16sint: i.R16I,
          r16float: i.R16F,
          rg8unorm: i.RG8,
          rg8snorm: i.RG8_SNORM,
          rg8uint: i.RG8UI,
          rg8sint: i.RG8I,
          r32uint: i.R32UI,
          r32sint: i.R32I,
          r32float: i.R32F,
          rg16uint: i.RG16UI,
          rg16sint: i.RG16I,
          rg16float: i.RG16F,
          rgba8unorm: i.RGBA,
          ...t,
          rgba8snorm: i.RGBA8_SNORM,
          rgba8uint: i.RGBA8UI,
          rgba8sint: i.RGBA8I,
          bgra8unorm: A,
          rgb9e5ufloat: i.RGB9_E5,
          rgb10a2unorm: i.RGB10_A2,
          rg11b10ufloat: i.R11F_G11F_B10F,
          rg32uint: i.RG32UI,
          rg32sint: i.RG32I,
          rg32float: i.RG32F,
          rgba16uint: i.RGBA16UI,
          rgba16sint: i.RGBA16I,
          rgba16float: i.RGBA16F,
          rgba32uint: i.RGBA32UI,
          rgba32sint: i.RGBA32I,
          rgba32float: i.RGBA32F,
          stencil8: i.STENCIL_INDEX8,
          depth16unorm: i.DEPTH_COMPONENT16,
          depth24plus: i.DEPTH_COMPONENT24,
          'depth24plus-stencil8': i.DEPTH24_STENCIL8,
          depth32float: i.DEPTH_COMPONENT32F,
          'depth32float-stencil8': i.DEPTH32F_STENCIL8,
          ...(e.s3tc
            ? {
              'bc1-rgba-unorm': e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
              'bc2-rgba-unorm': e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
              'bc3-rgba-unorm': e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,
            }
            : {}),
          ...(e.s3tc_sRGB
            ? {
              'bc1-rgba-unorm-srgb': e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
              'bc2-rgba-unorm-srgb': e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
              'bc3-rgba-unorm-srgb': e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
            }
            : {}),
          ...(e.rgtc
            ? {
              'bc4-r-unorm': e.rgtc.COMPRESSED_RED_RGTC1_EXT,
              'bc4-r-snorm': e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
              'bc5-rg-unorm': e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
              'bc5-rg-snorm': e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
            }
            : {}),
          ...(e.bptc
            ? {
              'bc6h-rgb-float': e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
              'bc6h-rgb-ufloat': e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
              'bc7-rgba-unorm': e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
              'bc7-rgba-unorm-srgb': e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,
            }
            : {}),
          ...(e.etc
            ? {
              'etc2-rgb8unorm': e.etc.COMPRESSED_RGB8_ETC2,
              'etc2-rgb8unorm-srgb': e.etc.COMPRESSED_SRGB8_ETC2,
              'etc2-rgb8a1unorm': e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
              'etc2-rgb8a1unorm-srgb': e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
              'etc2-rgba8unorm': e.etc.COMPRESSED_RGBA8_ETC2_EAC,
              'etc2-rgba8unorm-srgb': e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
              'eac-r11unorm': e.etc.COMPRESSED_R11_EAC,
              'eac-rg11unorm': e.etc.COMPRESSED_SIGNED_RG11_EAC,
            }
            : {}),
          ...(e.astc
            ? {
              'astc-4x4-unorm': e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
              'astc-4x4-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
              'astc-5x4-unorm': e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
              'astc-5x4-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
              'astc-5x5-unorm': e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
              'astc-5x5-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
              'astc-6x5-unorm': e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
              'astc-6x5-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
              'astc-6x6-unorm': e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
              'astc-6x6-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
              'astc-8x5-unorm': e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
              'astc-8x5-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
              'astc-8x6-unorm': e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
              'astc-8x6-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
              'astc-8x8-unorm': e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
              'astc-8x8-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
              'astc-10x5-unorm': e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
              'astc-10x5-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
              'astc-10x6-unorm': e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
              'astc-10x6-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
              'astc-10x8-unorm': e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
              'astc-10x8-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
              'astc-10x10-unorm': e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
              'astc-10x10-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
              'astc-12x10-unorm': e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
              'astc-12x10-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
              'astc-12x12-unorm': e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
              'astc-12x12-unorm-srgb': e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
            }
            : {}),
        }
      );
    }
    function jd(i) {
      return {
        r8unorm: i.UNSIGNED_BYTE,
        r8snorm: i.BYTE,
        r8uint: i.UNSIGNED_BYTE,
        r8sint: i.BYTE,
        r16uint: i.UNSIGNED_SHORT,
        r16sint: i.SHORT,
        r16float: i.HALF_FLOAT,
        rg8unorm: i.UNSIGNED_BYTE,
        rg8snorm: i.BYTE,
        rg8uint: i.UNSIGNED_BYTE,
        rg8sint: i.BYTE,
        r32uint: i.UNSIGNED_INT,
        r32sint: i.INT,
        r32float: i.FLOAT,
        rg16uint: i.UNSIGNED_SHORT,
        rg16sint: i.SHORT,
        rg16float: i.HALF_FLOAT,
        rgba8unorm: i.UNSIGNED_BYTE,
        'rgba8unorm-srgb': i.UNSIGNED_BYTE,
        rgba8snorm: i.BYTE,
        rgba8uint: i.UNSIGNED_BYTE,
        rgba8sint: i.BYTE,
        bgra8unorm: i.UNSIGNED_BYTE,
        'bgra8unorm-srgb': i.UNSIGNED_BYTE,
        rgb9e5ufloat: i.UNSIGNED_INT_5_9_9_9_REV,
        rgb10a2unorm: i.UNSIGNED_INT_2_10_10_10_REV,
        rg11b10ufloat: i.UNSIGNED_INT_10F_11F_11F_REV,
        rg32uint: i.UNSIGNED_INT,
        rg32sint: i.INT,
        rg32float: i.FLOAT,
        rgba16uint: i.UNSIGNED_SHORT,
        rgba16sint: i.SHORT,
        rgba16float: i.HALF_FLOAT,
        rgba32uint: i.UNSIGNED_INT,
        rgba32sint: i.INT,
        rgba32float: i.FLOAT,
        stencil8: i.UNSIGNED_BYTE,
        depth16unorm: i.UNSIGNED_SHORT,
        depth24plus: i.UNSIGNED_INT,
        'depth24plus-stencil8': i.UNSIGNED_INT_24_8,
        depth32float: i.FLOAT,
        'depth32float-stencil8': i.FLOAT_32_UNSIGNED_INT_24_8_REV,
      };
    }
    const SS = 4;
    class ga {
      constructor(e) {
        (this.managedTextures = []),
          (this._glTextures = Object.create(null)),
          (this._glSamplers = Object.create(null)),
          (this._boundTextures = []),
          (this._activeTextureLocation = -1),
          (this._boundSamplers = Object.create(null)),
          (this._uploads = { image: pa, buffer: Wd, video: Fd, compressed: Kd }),
          (this._premultiplyAlpha = !1),
          (this._useSeparateSamplers = !1),
          (this._renderer = e),
          this._renderer.renderableGC.addManagedHash(this, '_glTextures'),
          this._renderer.renderableGC.addManagedHash(this, '_glSamplers');
      }
      contextChange(e) {
        (this._gl = e),
          this._mapFormatToInternalFormat ||
          ((this._mapFormatToInternalFormat = Ld(e, this._renderer.context.extensions)),
            (this._mapFormatToType = jd(e)),
            (this._mapFormatToFormat = Od(e))),
          (this._glTextures = Object.create(null)),
          (this._glSamplers = Object.create(null)),
          (this._boundSamplers = Object.create(null)),
          (this._premultiplyAlpha = !1);
        for (let t = 0; t < 16; t++) this.bind(v.EMPTY, t);
      }
      initSource(e) {
        this.bind(e);
      }
      bind(e, t = 0) {
        const A = e.source;
        e
          ? (this.bindSource(A, t), this._useSeparateSamplers && this._bindSampler(A.style, t))
          : (this.bindSource(null, t), this._useSeparateSamplers && this._bindSampler(null, t));
      }
      bindSource(e, t = 0) {
        const A = this._gl;
        if (((e._touched = this._renderer.textureGC.count), this._boundTextures[t] !== e)) {
          (this._boundTextures[t] = e), this._activateLocation(t), e || (e = v.EMPTY.source);
          const r = this.getGlSource(e);
          A.bindTexture(r.target, r.texture);
        }
      }
      _bindSampler(e, t = 0) {
        const A = this._gl;
        if (!e) {
          (this._boundSamplers[t] = null), A.bindSampler(t, null);
          return;
        }
        const r = this._getGlSampler(e);
        this._boundSamplers[t] !== r && ((this._boundSamplers[t] = r), A.bindSampler(t, r));
      }
      unbind(e) {
        const t = e.source,
          A = this._boundTextures,
          r = this._gl;
        for (let s = 0; s < A.length; s++)
          if (A[s] === t) {
            this._activateLocation(s);
            const n = this.getGlSource(t);
            r.bindTexture(n.target, null), (A[s] = null);
          }
      }
      _activateLocation(e) {
        this._activeTextureLocation !== e && ((this._activeTextureLocation = e), this._gl.activeTexture(this._gl.TEXTURE0 + e));
      }
      _initSource(e) {
        const t = this._gl,
          A = new Gd(t.createTexture());
        if (
          ((A.type = this._mapFormatToType[e.format]),
            (A.internalFormat = this._mapFormatToInternalFormat[e.format]),
            (A.format = this._mapFormatToFormat[e.format]),
            e.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo))
        ) {
          const r = Math.max(e.width, e.height);
          e.mipLevelCount = Math.floor(Math.log2(r)) + 1;
        }
        return (
          (this._glTextures[e.uid] = A),
          this.managedTextures.includes(e) ||
          (e.on('update', this.onSourceUpdate, this),
            e.on('resize', this.onSourceUpdate, this),
            e.on('styleChange', this.onStyleChange, this),
            e.on('destroy', this.onSourceDestroy, this),
            e.on('unload', this.onSourceUnload, this),
            e.on('updateMipmaps', this.onUpdateMipmaps, this),
            this.managedTextures.push(e)),
          this.onSourceUpdate(e),
          this.updateStyle(e, !1),
          A
        );
      }
      onStyleChange(e) {
        this.updateStyle(e, !1);
      }
      updateStyle(e, t) {
        const A = this._gl,
          r = this.getGlSource(e);
        A.bindTexture(A.TEXTURE_2D, r.texture),
          (this._boundTextures[this._activeTextureLocation] = e),
          Ws(
            e.style,
            A,
            e.mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            'texParameteri',
            A.TEXTURE_2D,
            !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo,
            t
          );
      }
      onSourceUnload(e) {
        const t = this._glTextures[e.uid];
        t && (this.unbind(e), (this._glTextures[e.uid] = null), this._gl.deleteTexture(t.texture));
      }
      onSourceUpdate(e) {
        const t = this._gl,
          A = this.getGlSource(e);
        t.bindTexture(t.TEXTURE_2D, A.texture), (this._boundTextures[this._activeTextureLocation] = e);
        const r = e.alphaMode === 'premultiply-alpha-on-upload';
        this._premultiplyAlpha !== r && ((this._premultiplyAlpha = r), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r)),
          this._uploads[e.uploadMethodId]
            ? this._uploads[e.uploadMethodId].upload(e, A, t, this._renderer.context.webGLVersion)
            : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.pixelWidth, e.pixelHeight, 0, t.RGBA, t.UNSIGNED_BYTE, null),
          e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e, !1);
      }
      onUpdateMipmaps(e, t = !0) {
        t && this.bindSource(e, 0);
        const A = this.getGlSource(e);
        this._gl.generateMipmap(A.target);
      }
      onSourceDestroy(e) {
        e.off('destroy', this.onSourceDestroy, this),
          e.off('update', this.onSourceUpdate, this),
          e.off('resize', this.onSourceUpdate, this),
          e.off('unload', this.onSourceUnload, this),
          e.off('styleChange', this.onStyleChange, this),
          e.off('updateMipmaps', this.onUpdateMipmaps, this),
          this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
          this.onSourceUnload(e);
      }
      _initSampler(e) {
        const t = this._gl,
          A = this._gl.createSampler();
        return (
          (this._glSamplers[e._resourceId] = A),
          Ws(
            e,
            t,
            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
            this._renderer.context.extensions.anisotropicFiltering,
            'samplerParameteri',
            A,
            !1,
            !0
          ),
          this._glSamplers[e._resourceId]
        );
      }
      _getGlSampler(e) {
        return this._glSamplers[e._resourceId] || this._initSampler(e);
      }
      getGlSource(e) {
        return this._glTextures[e.uid] || this._initSource(e);
      }
      generateCanvas(e) {
        const { pixels: t, width: A, height: r } = this.getPixels(e),
          s = J.get().createCanvas();
        (s.width = A), (s.height = r);
        const n = s.getContext('2d');
        if (n) {
          const a = n.createImageData(A, r);
          a.data.set(t), n.putImageData(a, 0, 0);
        }
        return s;
      }
      getPixels(e) {
        const t = e.source.resolution,
          A = e.frame,
          r = Math.max(Math.round(A.width * t), 1),
          s = Math.max(Math.round(A.height * t), 1),
          n = new Uint8Array(SS * r * s),
          a = this._renderer,
          l = a.renderTarget.getRenderTarget(e),
          h = a.renderTarget.getGpuRenderTarget(l),
          u = a.gl;
        return (
          u.bindFramebuffer(u.FRAMEBUFFER, h.resolveTargetFramebuffer),
          u.readPixels(Math.round(A.x * t), Math.round(A.y * t), r, s, u.RGBA, u.UNSIGNED_BYTE, n),
          { pixels: new Uint8ClampedArray(n.buffer), width: r, height: s }
        );
      }
      destroy() {
        this.managedTextures.slice().forEach((e) => this.onSourceDestroy(e)),
          (this.managedTextures = null),
          (this._glTextures = null),
          (this._glSamplers = null),
          (this._boundTextures = null),
          (this._boundSamplers = null),
          (this._mapFormatToInternalFormat = null),
          (this._mapFormatToType = null),
          (this._mapFormatToFormat = null),
          (this._uploads = null),
          (this._renderer = null);
      }
      resetState() {
        (this._activeTextureLocation = -1),
          this._boundTextures.fill(v.EMPTY.source),
          (this._boundSamplers = Object.create(null));
        const e = this._gl;
        (this._premultiplyAlpha = !1), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
      }
    }
    ga.extension = { type: [M.WebGLSystem], name: 'texture' };
    class ma {
      contextChange(e) {
        const t = new qe({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },
          uTransformMatrix: { value: new R(), type: 'mat3x3<f32>' },
          uRound: { value: 0, type: 'f32' },
        }),
          A = e.limits.maxBatchableTextures,
          r = sA({ name: 'graphics', bits: [tr, ir(A), hr, aA] });
        this.shader = new ke({ glProgram: r, resources: { localUniforms: t, batchSamplers: rr(A) } });
      }
      execute(e, t) {
        const A = t.context,
          r = A.customShader || this.shader,
          s = e.renderer,
          n = s.graphicsContext,
          { batcher: a, instructions: l } = n.getContextRenderData(A);
        (r.groups[0] = s.globalUniforms.bindGroup),
          s.state.set(e.state),
          s.shader.bind(r),
          s.geometry.bind(a.geometry, r.glProgram);
        const h = l.instructions;
        for (let u = 0; u < l.instructionSize; u++) {
          const o = h[u];
          if (o.size) {
            for (let c = 0; c < o.textures.count; c++) s.texture.bind(o.textures.textures[c], c);
            s.geometry.draw(o.topology, o.size, o.start);
          }
        }
      }
      destroy() {
        this.shader.destroy(!0), (this.shader = null);
      }
    }
    ma.extension = { type: [M.WebGLPipesAdaptor], name: 'graphics' };
    class Sa {
      init() {
        const e = sA({ name: 'mesh', bits: [hr, od, aA] });
        this._shader = new ke({
          glProgram: e,
          resources: { uTexture: v.EMPTY.source, textureUniforms: { uTextureMatrix: { type: 'mat3x3<f32>', value: new R() } } },
        });
      }
      execute(e, t) {
        const A = e.renderer;
        let r = t._shader;
        if (r) {
          if (!r.glProgram) {
            N('Mesh shader has no glProgram', t.shader);
            return;
          }
        } else {
          r = this._shader;
          const s = t.texture,
            n = s.source;
          (r.resources.uTexture = n),
            (r.resources.uSampler = n.style),
            (r.resources.textureUniforms.uniforms.uTextureMatrix = s.textureMatrix.mapCoord);
        }
        (r.groups[100] = A.globalUniforms.bindGroup),
          (r.groups[101] = e.localUniformsBindGroup),
          A.encoder.draw({ geometry: t._geometry, shader: r, state: t.state });
      }
      destroy() {
        this._shader.destroy(!0), (this._shader = null);
      }
    }
    Sa.extension = { type: [M.WebGLPipesAdaptor], name: 'mesh' };
    class qa {
      constructor(e) {
        this._renderer = e;
      }
      updateRenderable() { }
      destroyRenderable() { }
      validateRenderable() {
        return !1;
      }
      addRenderable(e, t) {
        this._renderer.renderPipes.batch.break(t), t.add(e);
      }
      execute(e) {
        e.isRenderable && e.render(this._renderer);
      }
      destroy() {
        this._renderer = null;
      }
    }
    qa.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'customRender' };
    class ti {
      constructor() {
        (this.batcherName = 'default'),
          (this.topology = 'triangle-list'),
          (this.attributeSize = 4),
          (this.indexSize = 6),
          (this.packAsQuad = !0),
          (this.roundPixels = 0),
          (this._attributeStart = 0),
          (this._batcher = null),
          (this._batch = null);
      }
      get blendMode() {
        return this.renderable.groupBlendMode;
      }
      get color() {
        return this.renderable.groupColorAlpha;
      }
      reset() {
        (this.renderable = null), (this.texture = null), (this._batcher = null), (this._batch = null), (this.bounds = null);
      }
      destroy() { }
    }
    function Wi(i, e) {
      const t = i.instructionSet,
        A = t.instructions;
      for (let r = 0; r < t.instructionSize; r++) {
        const s = A[r];
        e[s.renderPipeId].execute(s);
      }
    }
    const qS = new R();
    class Ma {
      constructor(e) {
        this._renderer = e;
      }
      addRenderGroup(e, t) {
        e.isCachedAsTexture ? this._addRenderableCacheAsTexture(e, t) : this._addRenderableDirect(e, t);
      }
      execute(e) {
        e.isRenderable && (e.isCachedAsTexture ? this._executeCacheAsTexture(e) : this._executeDirect(e));
      }
      destroy() {
        this._renderer = null;
      }
      _addRenderableDirect(e, t) {
        this._renderer.renderPipes.batch.break(t),
          e._batchableRenderGroup && (se.return(e._batchableRenderGroup), (e._batchableRenderGroup = null)),
          t.add(e);
      }
      _addRenderableCacheAsTexture(e, t) {
        const A = e._batchableRenderGroup ?? (e._batchableRenderGroup = se.get(ti));
        (A.renderable = e.root),
          (A.transform = e.root.relativeGroupTransform),
          (A.texture = e.texture),
          (A.bounds = e._textureBounds),
          t.add(e),
          this._renderer.renderPipes.blendMode.pushBlendMode(e, e.root.groupBlendMode, t),
          this._renderer.renderPipes.batch.addToBatch(A, t),
          this._renderer.renderPipes.blendMode.popBlendMode(t);
      }
      _executeCacheAsTexture(e) {
        if (e.textureNeedsUpdate) {
          e.textureNeedsUpdate = !1;
          const t = qS.identity().translate(-e._textureBounds.x, -e._textureBounds.y);
          this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame),
            this._renderer.globalUniforms.push({ worldTransformMatrix: t, worldColor: 4294967295, offset: { x: 0, y: 0 } }),
            Wi(e, this._renderer.renderPipes),
            this._renderer.renderTarget.finishRenderPass(),
            this._renderer.renderTarget.pop(),
            this._renderer.globalUniforms.pop();
        }
        e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup),
          e._batchableRenderGroup._batcher.geometry.buffers[0].update();
      }
      _executeDirect(e) {
        this._renderer.globalUniforms.push({
          worldTransformMatrix: e.inverseParentTextureTransform,
          worldColor: e.worldColorAlpha,
        }),
          Wi(e, this._renderer.renderPipes),
          this._renderer.globalUniforms.pop();
      }
    }
    Ma.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'renderGroup' };
    function Ki(i, e) {
      e || (e = 0);
      for (let t = e; t < i.length && i[t]; t++) i[t] = null;
    }
    const MS = new _(),
      Rl = Dt | GA | Zi;
    function Ea(i, e = !1) {
      Zd(i);
      const t = i.childrenToUpdate,
        A = i.updateTick++;
      for (const r in t) {
        const s = Number(r),
          n = t[r],
          a = n.list,
          l = n.index;
        for (let h = 0; h < l; h++) {
          const u = a[h];
          u.parentRenderGroup === i && u.relativeRenderGroupDepth === s && Va(u, A, 0);
        }
        Ki(a, l), (n.index = 0);
      }
      if (e) for (let r = 0; r < i.renderGroupChildren.length; r++) Ea(i.renderGroupChildren[r], e);
    }
    function Zd(i) {
      const e = i.root;
      let t;
      if (i.renderGroupParent) {
        const A = i.renderGroupParent;
        i.worldTransform.appendFrom(e.relativeGroupTransform, A.worldTransform),
          (i.worldColor = JA(e.groupColor, A.worldColor)),
          (t = e.groupAlpha * A.worldAlpha);
      } else i.worldTransform.copyFrom(e.localTransform), (i.worldColor = e.localColor), (t = e.localAlpha);
      (t = t < 0 ? 0 : t > 1 ? 1 : t), (i.worldAlpha = t), (i.worldColorAlpha = i.worldColor + (((t * 255) | 0) << 24));
    }
    function Va(i, e, t) {
      if (e === i.updateTick) return;
      (i.updateTick = e), (i.didChange = !1);
      const A = i.localTransform;
      i.updateLocalTransform();
      const r = i.parent;
      if (
        (r && !r.renderGroup
          ? ((t |= i._updateFlags), i.relativeGroupTransform.appendFrom(A, r.relativeGroupTransform), t & Rl && Bl(i, r, t))
          : ((t = i._updateFlags), i.relativeGroupTransform.copyFrom(A), t & Rl && Bl(i, MS, t)),
          !i.renderGroup)
      ) {
        const s = i.children,
          n = s.length;
        for (let h = 0; h < n; h++) Va(s[h], e, t);
        const a = i.parentRenderGroup,
          l = i;
        l.renderPipeId && !a.structureDidChange && a.updateRenderable(l);
      }
    }
    function Bl(i, e, t) {
      if (t & GA) {
        i.groupColor = JA(i.localColor, e.groupColor);
        let A = i.localAlpha * e.groupAlpha;
        (A = A < 0 ? 0 : A > 1 ? 1 : A), (i.groupAlpha = A), (i.groupColorAlpha = i.groupColor + (((A * 255) | 0) << 24));
      }
      t & Zi && (i.groupBlendMode = i.localBlendMode === 'inherit' ? e.groupBlendMode : i.localBlendMode),
        t & Dt && (i.globalDisplayStatus = i.localDisplayStatus & e.globalDisplayStatus),
        (i._updateFlags = 0);
    }
    function Xd(i, e) {
      const { list: t } = i.childrenRenderablesToUpdate;
      let A = !1;
      for (let r = 0; r < i.childrenRenderablesToUpdate.index; r++) {
        const s = t[r];
        if (((A = e[s.renderPipeId].validateRenderable(s)), A)) break;
      }
      return (i.structureDidChange = A), A;
    }
    const ES = new R();
    class Ta {
      constructor(e) {
        this._renderer = e;
      }
      render({ container: e, transform: t }) {
        const A = e.parent,
          r = e.renderGroup.renderGroupParent;
        (e.parent = null), (e.renderGroup.renderGroupParent = null);
        const s = this._renderer,
          n = ES;
        t && (n.copyFrom(e.renderGroup.localTransform), e.renderGroup.localTransform.copyFrom(t));
        const a = s.renderPipes;
        this._updateCachedRenderGroups(e.renderGroup, null),
          this._updateRenderGroups(e.renderGroup),
          s.globalUniforms.start({
            worldTransformMatrix: t ? e.renderGroup.localTransform : e.renderGroup.worldTransform,
            worldColor: e.renderGroup.worldColorAlpha,
          }),
          Wi(e.renderGroup, a),
          a.uniformBatch && a.uniformBatch.renderEnd(),
          t && e.renderGroup.localTransform.copyFrom(n),
          (e.parent = A),
          (e.renderGroup.renderGroupParent = r);
      }
      destroy() {
        this._renderer = null;
      }
      _updateCachedRenderGroups(e, t) {
        if (((e._parentCacheAsTextureRenderGroup = t), e.isCachedAsTexture)) {
          if (!e.textureNeedsUpdate) return;
          t = e;
        }
        for (let A = e.renderGroupChildren.length - 1; A >= 0; A--) this._updateCachedRenderGroups(e.renderGroupChildren[A], t);
        if ((e.invalidateMatrices(), e.isCachedAsTexture)) {
          if (e.textureNeedsUpdate) {
            const A = e.root.getLocalBounds();
            A.ceil();
            const r = e.texture;
            e.texture && ce.returnTexture(e.texture, !0);
            const s = this._renderer,
              n = e.textureOptions.resolution || s.view.resolution,
              a = e.textureOptions.antialias ?? s.view.antialias,
              l = e.textureOptions.scaleMode ?? 'linear',
              h = ce.getOptimalTexture(A.width, A.height, n, a);
            (h._source.style = new Je({ scaleMode: l })),
              (e.texture = h),
              e._textureBounds || (e._textureBounds = new de()),
              e._textureBounds.copyFrom(A),
              r !== e.texture && e.renderGroupParent && (e.renderGroupParent.structureDidChange = !0);
          }
        } else e.texture && (ce.returnTexture(e.texture, !0), (e.texture = null));
      }
      _updateRenderGroups(e) {
        const t = this._renderer,
          A = t.renderPipes;
        if (
          (e.runOnRender(t),
            (e.instructionSet.renderPipes = A),
            e.structureDidChange ? Ki(e.childrenRenderablesToUpdate.list, 0) : Xd(e, A),
            Ea(e),
            e.structureDidChange ? ((e.structureDidChange = !1), this._buildInstructions(e, t)) : this._updateRenderables(e),
            (e.childrenRenderablesToUpdate.index = 0),
            t.renderPipes.batch.upload(e.instructionSet),
            !(e.isCachedAsTexture && !e.textureNeedsUpdate))
        )
          for (let r = 0; r < e.renderGroupChildren.length; r++) this._updateRenderGroups(e.renderGroupChildren[r]);
      }
      _updateRenderables(e) {
        const { list: t, index: A } = e.childrenRenderablesToUpdate;
        for (let r = 0; r < A; r++) {
          const s = t[r];
          s.didViewUpdate && e.updateRenderable(s);
        }
        Ki(t, A);
      }
      _buildInstructions(e, t) {
        const A = e.root,
          r = e.instructionSet;
        r.reset();
        const s = t.renderPipes ? t : t.batch.renderer,
          n = s.renderPipes;
        n.batch.buildStart(r),
          n.blendMode.buildStart(),
          n.colorMask.buildStart(),
          A.sortableChildren && A.sortChildren(),
          A.collectRenderablesWithEffects(r, s, null),
          n.batch.buildEnd(r),
          n.blendMode.buildEnd(r);
      }
    }
    Ta.extension = { type: [M.WebGLSystem, M.WebGPUSystem, M.CanvasSystem], name: 'renderGroup' };
    class Ia {
      constructor(e) {
        this._renderer = e;
      }
      addRenderable(e, t) {
        const A = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, A), this._renderer.renderPipes.batch.addToBatch(A, t);
      }
      updateRenderable(e) {
        const t = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, t), t._batcher.updateElement(t);
      }
      validateRenderable(e) {
        const t = this._getGpuSprite(e);
        return !t._batcher.checkAndUpdateTexture(t, e._texture);
      }
      _updateBatchableSprite(e, t) {
        (t.bounds = e.visualBounds), (t.texture = e._texture);
      }
      _getGpuSprite(e) {
        return e._gpuData[this._renderer.uid] || this._initGPUSprite(e);
      }
      _initGPUSprite(e) {
        const t = new ti();
        return (
          (t.renderable = e),
          (t.transform = e.groupTransform),
          (t.texture = e._texture),
          (t.bounds = e.visualBounds),
          (t.roundPixels = this._renderer._roundPixels | e._roundPixels),
          (e._gpuData[this._renderer.uid] = t),
          t
        );
      }
      destroy() {
        this._renderer = null;
      }
    }
    Ia.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'sprite' };
    const ba = class Hd {
      constructor() {
        (this.clearBeforeRender = !0),
          (this._backgroundColor = new $(0)),
          (this.color = this._backgroundColor),
          (this.alpha = 1);
      }
      init(e) {
        (e = { ...Hd.defaultOptions, ...e }),
          (this.clearBeforeRender = e.clearBeforeRender),
          (this.color = e.background || e.backgroundColor || this._backgroundColor),
          (this.alpha = e.backgroundAlpha),
          this._backgroundColor.setAlpha(e.backgroundAlpha);
      }
      get color() {
        return this._backgroundColor;
      }
      set color(e) {
        $.shared.setValue(e).alpha < 1 &&
          this._backgroundColor.alpha === 1 &&
          N(
            'Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application.'
          ),
          this._backgroundColor.setValue(e);
      }
      get alpha() {
        return this._backgroundColor.alpha;
      }
      set alpha(e) {
        this._backgroundColor.setAlpha(e);
      }
      get colorRgba() {
        return this._backgroundColor.toArray();
      }
      destroy() { }
    };
    ba.extension = { type: [M.WebGLSystem, M.WebGPUSystem, M.CanvasSystem], name: 'background', priority: 0 };
    ba.defaultOptions = { backgroundAlpha: 1, backgroundColor: 0, clearBeforeRender: !0 };
    let zd = ba;
    const BA = {};
    Q.handle(
      M.BlendMode,
      (i) => {
        if (!i.name) throw new Error('BlendMode extension must have a name property');
        BA[i.name] = i.ref;
      },
      (i) => {
        delete BA[i.name];
      }
    );
    class ya {
      constructor(e) {
        (this._blendModeStack = []),
          (this._isAdvanced = !1),
          (this._filterHash = Object.create(null)),
          (this._renderer = e),
          this._renderer.runners.prerender.add(this);
      }
      prerender() {
        (this._activeBlendMode = 'normal'), (this._isAdvanced = !1);
      }
      pushBlendMode(e, t, A) {
        this._blendModeStack.push(t), this.setBlendMode(e, t, A);
      }
      popBlendMode(e) {
        this._blendModeStack.pop();
        const t = this._blendModeStack[this._activeBlendMode.length - 1] ?? 'normal';
        this.setBlendMode(null, t, e);
      }
      setBlendMode(e, t, A) {
        const r = e instanceof Bi;
        if (this._activeBlendMode === t) {
          this._isAdvanced && e && !r && this._renderableList?.push(e);
          return;
        }
        this._isAdvanced && this._endAdvancedBlendMode(A),
          (this._activeBlendMode = t),
          e && ((this._isAdvanced = !!BA[t]), this._isAdvanced && this._beginAdvancedBlendMode(e, A));
      }
      _beginAdvancedBlendMode(e, t) {
        this._renderer.renderPipes.batch.break(t);
        const A = this._activeBlendMode;
        if (!BA[A]) {
          N(`Unable to assign BlendMode: '${A}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
          return;
        }
        const r = this._ensureFilterEffect(A),
          s = e instanceof Bi,
          n = {
            renderPipeId: 'filter',
            action: 'pushFilter',
            filterEffect: r,
            renderables: s ? null : [e],
            container: s ? e.root : null,
            canBundle: !1,
          };
        (this._renderableList = n.renderables), t.add(n);
      }
      _ensureFilterEffect(e) {
        let t = this._filterHash[e];
        return t || ((t = this._filterHash[e] = new PA()), (t.filters = [new BA[e]()])), t;
      }
      _endAdvancedBlendMode(e) {
        (this._isAdvanced = !1),
          (this._renderableList = null),
          this._renderer.renderPipes.batch.break(e),
          e.add({ renderPipeId: 'filter', action: 'popFilter', canBundle: !1 });
      }
      buildStart() {
        this._isAdvanced = !1;
      }
      buildEnd(e) {
        this._isAdvanced && this._endAdvancedBlendMode(e);
      }
      destroy() {
        (this._renderer = null), (this._renderableList = null);
        for (const e in this._filterHash) this._filterHash[e].destroy();
        this._filterHash = null;
      }
    }
    ya.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'blendMode' };
    const Xr = { png: 'image/png', jpg: 'image/jpeg', webp: 'image/webp' },
      xa = class _d {
        constructor(e) {
          this._renderer = e;
        }
        _normalizeOptions(e, t = {}) {
          return e instanceof _ || e instanceof v ? { target: e, ...t } : { ...t, ...e };
        }
        async image(e) {
          const t = J.get().createImage();
          return (t.src = await this.base64(e)), t;
        }
        async base64(e) {
          e = this._normalizeOptions(e, _d.defaultImageOptions);
          const { format: t, quality: A } = e,
            r = this.canvas(e);
          if (r.toBlob !== void 0)
            return new Promise((s, n) => {
              r.toBlob(
                (a) => {
                  if (!a) {
                    n(new Error('ICanvas.toBlob failed!'));
                    return;
                  }
                  const l = new FileReader();
                  (l.onload = () => s(l.result)), (l.onerror = n), l.readAsDataURL(a);
                },
                Xr[t],
                A
              );
            });
          if (r.toDataURL !== void 0) return r.toDataURL(Xr[t], A);
          if (r.convertToBlob !== void 0) {
            const s = await r.convertToBlob({ type: Xr[t], quality: A });
            return new Promise((n, a) => {
              const l = new FileReader();
              (l.onload = () => n(l.result)), (l.onerror = a), l.readAsDataURL(s);
            });
          }
          throw new Error(
            'Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented'
          );
        }
        canvas(e) {
          e = this._normalizeOptions(e);
          const t = e.target,
            A = this._renderer;
          if (t instanceof v) return A.texture.generateCanvas(t);
          const r = A.textureGenerator.generateTexture(e),
            s = A.texture.generateCanvas(r);
          return r.destroy(!0), s;
        }
        pixels(e) {
          e = this._normalizeOptions(e);
          const t = e.target,
            A = this._renderer,
            r = t instanceof v ? t : A.textureGenerator.generateTexture(e),
            s = A.texture.getPixels(r);
          return t instanceof _ && r.destroy(!0), s;
        }
        texture(e) {
          return (
            (e = this._normalizeOptions(e)),
            e.target instanceof v ? e.target : this._renderer.textureGenerator.generateTexture(e)
          );
        }
        download(e) {
          e = this._normalizeOptions(e);
          const t = this.canvas(e),
            A = document.createElement('a');
          (A.download = e.filename ?? 'image.png'),
            (A.href = t.toDataURL('image/png')),
            document.body.appendChild(A),
            A.click(),
            document.body.removeChild(A);
        }
        log(e) {
          const t = e.width ?? 200;
          e = this._normalizeOptions(e);
          const r = this.canvas(e).toDataURL(),
            s = [
              'font-size: 1px;',
              `padding: ${t}px 300px;`,
              `background: url(${r}) no-repeat;`,
              'background-size: contain;',
            ].join(' ');
        }
        destroy() {
          this._renderer = null;
        }
      };
    xa.extension = { type: [M.WebGLSystem, M.WebGPUSystem], name: 'extract' };
    xa.defaultImageOptions = { format: 'png', quality: 1 };
    let $d = xa;
    class ur extends v {
      static create(e) {
        return new ur({ source: new ne(e) });
      }
      resize(e, t, A) {
        return this.source.resize(e, t, A), this;
      }
    }
    const VS = new F(),
      TS = new de(),
      IS = [0, 0, 0, 0];
    class va {
      constructor(e) {
        this._renderer = e;
      }
      generateTexture(e) {
        e instanceof _ && (e = { target: e, frame: void 0, textureSourceOptions: {}, resolution: void 0 });
        const t = e.resolution || this._renderer.resolution,
          A = e.antialias || this._renderer.view.antialias,
          r = e.target;
        let s = e.clearColor;
        s ? (s = Array.isArray(s) && s.length === 4 ? s : $.shared.setValue(s).toArray()) : (s = IS);
        const n = e.frame?.copyTo(VS) || ji(r, TS).rectangle;
        (n.width = Math.max(n.width, 1 / t) | 0), (n.height = Math.max(n.height, 1 / t) | 0);
        const a = ur.create({ ...e.textureSourceOptions, width: n.width, height: n.height, resolution: t, antialias: A }),
          l = R.shared.translate(-n.x, -n.y);
        return this._renderer.render({ container: r, transform: l, target: a, clearColor: s }), a.source.updateMipmaps(), a;
      }
      destroy() {
        this._renderer = null;
      }
    }
    va.extension = { type: [M.WebGLSystem, M.WebGPUSystem], name: 'textureGenerator' };
    function lA(i, e, t) {
      const A = ((i >> 24) & 255) / 255;
      (e[t++] = ((i & 255) / 255) * A),
        (e[t++] = (((i >> 8) & 255) / 255) * A),
        (e[t++] = (((i >> 16) & 255) / 255) * A),
        (e[t++] = A);
    }
    class Ca {
      constructor(e) {
        (this._stackIndex = 0),
          (this._globalUniformDataStack = []),
          (this._uniformsPool = []),
          (this._activeUniforms = []),
          (this._bindGroupPool = []),
          (this._activeBindGroups = []),
          (this._renderer = e);
      }
      reset() {
        this._stackIndex = 0;
        for (let e = 0; e < this._activeUniforms.length; e++) this._uniformsPool.push(this._activeUniforms[e]);
        for (let e = 0; e < this._activeBindGroups.length; e++) this._bindGroupPool.push(this._activeBindGroups[e]);
        (this._activeUniforms.length = 0), (this._activeBindGroups.length = 0);
      }
      start(e) {
        this.reset(), this.push(e);
      }
      bind({ size: e, projectionMatrix: t, worldTransformMatrix: A, worldColor: r, offset: s }) {
        const n = this._renderer.renderTarget.renderTarget,
          a = this._stackIndex
            ? this._globalUniformDataStack[this._stackIndex - 1]
            : { worldTransformMatrix: new R(), worldColor: 4294967295, offset: new H() },
          l = {
            projectionMatrix: t || this._renderer.renderTarget.projectionMatrix,
            resolution: e || n.size,
            worldTransformMatrix: A || a.worldTransformMatrix,
            worldColor: r || a.worldColor,
            offset: s || a.offset,
            bindGroup: null,
          },
          h = this._uniformsPool.pop() || this._createUniforms();
        this._activeUniforms.push(h);
        const u = h.uniforms;
        (u.uProjectionMatrix = l.projectionMatrix),
          (u.uResolution = l.resolution),
          u.uWorldTransformMatrix.copyFrom(l.worldTransformMatrix),
          (u.uWorldTransformMatrix.tx -= l.offset.x),
          (u.uWorldTransformMatrix.ty -= l.offset.y),
          lA(l.worldColor, u.uWorldColorAlpha, 0),
          h.update();
        let o;
        this._renderer.renderPipes.uniformBatch
          ? (o = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(h, !1))
          : ((o = this._bindGroupPool.pop() || new Le()), this._activeBindGroups.push(o), o.setResource(h, 0)),
          (l.bindGroup = o),
          (this._currentGlobalUniformData = l);
      }
      push(e) {
        this.bind(e), (this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData);
      }
      pop() {
        (this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1]),
          this._renderer.type === we.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update();
      }
      get bindGroup() {
        return this._currentGlobalUniformData.bindGroup;
      }
      get globalUniformData() {
        return this._currentGlobalUniformData;
      }
      get uniformGroup() {
        return this._currentGlobalUniformData.bindGroup.resources[0];
      }
      _createUniforms() {
        return new qe(
          {
            uProjectionMatrix: { value: new R(), type: 'mat3x3<f32>' },
            uWorldTransformMatrix: { value: new R(), type: 'mat3x3<f32>' },
            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },
            uResolution: { value: [0, 0], type: 'vec2<f32>' },
          },
          { isStatic: !0 }
        );
      }
      destroy() {
        (this._renderer = null),
          (this._globalUniformDataStack.length = 0),
          (this._uniformsPool.length = 0),
          (this._activeUniforms.length = 0),
          (this._bindGroupPool.length = 0),
          (this._activeBindGroups.length = 0),
          (this._currentGlobalUniformData = null);
      }
    }
    Ca.extension = { type: [M.WebGLSystem, M.WebGPUSystem, M.CanvasSystem], name: 'globalUniforms' };
    let bS = 1;
    class Ua {
      constructor() {
        (this._tasks = []), (this._offset = 0);
      }
      init() {
        ue.system.add(this._update, this);
      }
      repeat(e, t, A = !0) {
        const r = bS++;
        let s = 0;
        return (
          A && ((this._offset += 1e3), (s = this._offset)),
          this._tasks.push({
            func: e,
            duration: t,
            start: performance.now(),
            offset: s,
            last: performance.now(),
            repeat: !0,
            id: r,
          }),
          r
        );
      }
      cancel(e) {
        for (let t = 0; t < this._tasks.length; t++)
          if (this._tasks[t].id === e) {
            this._tasks.splice(t, 1);
            return;
          }
      }
      _update() {
        const e = performance.now();
        for (let t = 0; t < this._tasks.length; t++) {
          const A = this._tasks[t];
          if (e - A.offset - A.last >= A.duration) {
            const r = e - A.start;
            A.func(r), (A.last = e);
          }
        }
      }
      destroy() {
        ue.system.remove(this._update, this), (this._tasks.length = 0);
      }
    }
    Ua.extension = { type: [M.WebGLSystem, M.WebGPUSystem, M.CanvasSystem], name: 'scheduler', priority: 0 };
    let Nl = !1;
    function ef(i) {
      if (!Nl) {
        if (J.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1) {
          const e = [
            `%c  %c  %c  %c  %c PixiJS %c v${OA} (${i}) http://www.pixijs.com/

`,
            'background: #E72264; padding:5px 0;',
            'background: #6CA2EA; padding:5px 0;',
            'background: #B5D33D; padding:5px 0;',
            'background: #FED23F; padding:5px 0;',
            'color: #FFFFFF; background: #E72264; padding:5px 0;',
            'color: #E72264; background: #FFFFFF; padding:5px 0;',
          ];
          globalThis.console.log(...e);
        } else globalThis.console && globalThis.console.log(`PixiJS ${OA} - ${i} - http://www.pixijs.com/`);
        Nl = !0;
      }
    }
    class dr {
      constructor(e) {
        this._renderer = e;
      }
      init(e) {
        if (e.hello) {
          let t = this._renderer.name;
          this._renderer.type === we.WEBGL && (t += ` ${this._renderer.context.webGLVersion}`), ef(t);
        }
      }
    }
    dr.extension = { type: [M.WebGLSystem, M.WebGPUSystem, M.CanvasSystem], name: 'hello', priority: -2 };
    dr.defaultOptions = { hello: !1 };
    function tf(i) {
      let e = !1;
      for (const A in i)
        if (i[A] == null) {
          e = !0;
          break;
        }
      if (!e) return i;
      const t = Object.create(null);
      for (const A in i) {
        const r = i[A];
        r && (t[A] = r);
      }
      return t;
    }
    function Af(i) {
      let e = 0;
      for (let t = 0; t < i.length; t++) i[t] == null ? e++ : (i[t - e] = i[t]);
      return (i.length -= e), i;
    }
    let yS = 0;
    const ka = class rf {
      constructor(e) {
        (this._managedRenderables = []), (this._managedHashes = []), (this._managedArrays = []), (this._renderer = e);
      }
      init(e) {
        (e = { ...rf.defaultOptions, ...e }),
          (this.maxUnusedTime = e.renderableGCMaxUnusedTime),
          (this._frequency = e.renderableGCFrequency),
          (this.enabled = e.renderableGCActive);
      }
      get enabled() {
        return !!this._handler;
      }
      set enabled(e) {
        this.enabled !== e &&
          (e
            ? ((this._handler = this._renderer.scheduler.repeat(() => this.run(), this._frequency, !1)),
              (this._hashHandler = this._renderer.scheduler.repeat(() => {
                for (const t of this._managedHashes) t.context[t.hash] = tf(t.context[t.hash]);
              }, this._frequency)),
              (this._arrayHandler = this._renderer.scheduler.repeat(() => {
                for (const t of this._managedArrays) Af(t.context[t.hash]);
              }, this._frequency)))
            : (this._renderer.scheduler.cancel(this._handler),
              this._renderer.scheduler.cancel(this._hashHandler),
              this._renderer.scheduler.cancel(this._arrayHandler)));
      }
      addManagedHash(e, t) {
        this._managedHashes.push({ context: e, hash: t });
      }
      addManagedArray(e, t) {
        this._managedArrays.push({ context: e, hash: t });
      }
      prerender({ container: e }) {
        (this._now = performance.now()),
          (e.renderGroup.gcTick = yS++),
          this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick);
      }
      addRenderable(e) {
        this.enabled &&
          (e._lastUsed === -1 && (this._managedRenderables.push(e), e.once('destroyed', this._removeRenderable, this)),
            (e._lastUsed = this._now));
      }
      run() {
        const e = this._now,
          t = this._managedRenderables,
          A = this._renderer.renderPipes;
        let r = 0;
        for (let s = 0; s < t.length; s++) {
          const n = t[s];
          if (n === null) {
            r++;
            continue;
          }
          const a = n.renderGroup ?? n.parentRenderGroup,
            l = a?.instructionSet?.gcTick ?? -1;
          if (((a?.gcTick ?? 0) === l && (n._lastUsed = e), e - n._lastUsed > this.maxUnusedTime)) {
            if (!n.destroyed) {
              const h = A;
              a && (a.structureDidChange = !0), h[n.renderPipeId].destroyRenderable(n);
            }
            (n._lastUsed = -1), r++, n.off('destroyed', this._removeRenderable, this);
          } else t[s - r] = n;
        }
        t.length -= r;
      }
      destroy() {
        (this.enabled = !1),
          (this._renderer = null),
          (this._managedRenderables.length = 0),
          (this._managedHashes.length = 0),
          (this._managedArrays.length = 0);
      }
      _removeRenderable(e) {
        const t = this._managedRenderables.indexOf(e);
        t >= 0 && (e.off('destroyed', this._removeRenderable, this), (this._managedRenderables[t] = null));
      }
      _updateInstructionGCTick(e, t) {
        e.instructionSet.gcTick = t;
        for (const A of e.renderGroupChildren) this._updateInstructionGCTick(A, t);
      }
    };
    ka.extension = { type: [M.WebGLSystem, M.WebGPUSystem], name: 'renderableGC', priority: 0 };
    ka.defaultOptions = { renderableGCActive: !0, renderableGCMaxUnusedTime: 6e4, renderableGCFrequency: 3e4 };
    let sf = ka;
    const Ra = class nf {
      constructor(e) {
        (this._renderer = e), (this.count = 0), (this.checkCount = 0);
      }
      init(e) {
        (e = { ...nf.defaultOptions, ...e }),
          (this.checkCountMax = e.textureGCCheckCountMax),
          (this.maxIdle = e.textureGCAMaxIdle ?? e.textureGCMaxIdle),
          (this.active = e.textureGCActive);
      }
      postrender() {
        this._renderer.renderingToScreen &&
          (this.count++,
            this.active && (this.checkCount++, this.checkCount > this.checkCountMax && ((this.checkCount = 0), this.run())));
      }
      run() {
        const e = this._renderer.texture.managedTextures;
        for (let t = 0; t < e.length; t++) {
          const A = e[t];
          A.autoGarbageCollect &&
            A.resource &&
            A._touched > -1 &&
            this.count - A._touched > this.maxIdle &&
            ((A._touched = -1), A.unload());
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    Ra.extension = { type: [M.WebGLSystem, M.WebGPUSystem], name: 'textureGC' };
    Ra.defaultOptions = { textureGCActive: !0, textureGCAMaxIdle: null, textureGCMaxIdle: 3600, textureGCCheckCountMax: 600 };
    let af = Ra;
    const Ba = class of {
      get autoDensity() {
        return this.texture.source.autoDensity;
      }
      set autoDensity(e) {
        this.texture.source.autoDensity = e;
      }
      get resolution() {
        return this.texture.source._resolution;
      }
      set resolution(e) {
        this.texture.source.resize(this.texture.source.width, this.texture.source.height, e);
      }
      init(e) {
        (e = { ...of.defaultOptions, ...e }),
          e.view && (P(W, 'ViewSystem.view has been renamed to ViewSystem.canvas'), (e.canvas = e.view)),
          (this.screen = new F(0, 0, e.width, e.height)),
          (this.canvas = e.canvas || J.get().createCanvas()),
          (this.antialias = !!e.antialias),
          (this.texture = oa(this.canvas, e)),
          (this.renderTarget = new Gi({ colorTextures: [this.texture], depth: !!e.depth, isRoot: !0 })),
          (this.texture.source.transparent = e.backgroundAlpha < 1),
          (this.resolution = e.resolution);
      }
      resize(e, t, A) {
        this.texture.source.resize(e, t, A),
          (this.screen.width = this.texture.frame.width),
          (this.screen.height = this.texture.frame.height);
      }
      destroy(e = !1) {
        (typeof e == 'boolean' ? e : !!e?.removeView) &&
          this.canvas.parentNode &&
          this.canvas.parentNode.removeChild(this.canvas),
          this.texture.destroy();
      }
    };
    Ba.extension = { type: [M.WebGLSystem, M.WebGPUSystem, M.CanvasSystem], name: 'view', priority: 0 };
    Ba.defaultOptions = { width: 800, height: 600, autoDensity: !1, antialias: !1 };
    let lf = Ba;
    const Na = [zd, Ca, dr, lf, Ta, af, va, $d, un, sf, Ua],
      Qa = [ya, Yn, Ia, Ma, Dn, Ln, On, qa],
      xS = [...Na, aa, fd, cd, ta, jn, ga, ha, zn, fa, da, ea, Jd, Aa, $n],
      vS = [...Qa],
      CS = [Wn, Sa, ma],
      hf = [],
      cf = [],
      uf = [];
    Q.handleByNamedList(M.WebGLSystem, hf);
    Q.handleByNamedList(M.WebGLPipes, cf);
    Q.handleByNamedList(M.WebGLPipesAdaptor, uf);
    Q.add(...xS, ...vS, ...CS);
    class df extends zA {
      constructor() {
        const e = { name: 'webgl', type: we.WEBGL, systems: hf, renderPipes: cf, renderPipeAdaptors: uf };
        super(e);
      }
    }
    const US = Object.freeze(
      Object.defineProperty({ __proto__: null, WebGLRenderer: df }, Symbol.toStringTag, { value: 'Module' })
    );
    class wa {
      constructor(e) {
        (this._hash = Object.create(null)), (this._renderer = e), this._renderer.renderableGC.addManagedHash(this, '_hash');
      }
      contextChange(e) {
        this._gpu = e;
      }
      getBindGroup(e, t, A) {
        return e._updateKey(), this._hash[e._key] || this._createBindGroup(e, t, A);
      }
      _createBindGroup(e, t, A) {
        const r = this._gpu.device,
          s = t.layout[A],
          n = [],
          a = this._renderer;
        for (const u in s) {
          const o = e.resources[u] ?? e.resources[s[u]];
          let c;
          if (o._resourceType === 'uniformGroup') {
            const d = o;
            a.ubo.updateUniformGroup(d);
            const f = d.buffer;
            c = { buffer: a.buffer.getGPUBuffer(f), offset: 0, size: f.descriptor.size };
          } else if (o._resourceType === 'buffer') {
            const d = o;
            c = { buffer: a.buffer.getGPUBuffer(d), offset: 0, size: d.descriptor.size };
          } else if (o._resourceType === 'bufferResource') {
            const d = o;
            c = { buffer: a.buffer.getGPUBuffer(d.buffer), offset: d.offset, size: d.size };
          } else if (o._resourceType === 'textureSampler') {
            const d = o;
            c = a.texture.getGpuSampler(d);
          } else if (o._resourceType === 'textureSource') {
            const d = o;
            c = a.texture.getGpuSource(d).createView({});
          }
          n.push({ binding: s[u], resource: c });
        }
        const l = a.shader.getProgramData(t).bindGroups[A],
          h = r.createBindGroup({ layout: l, entries: n });
        return (this._hash[e._key] = h), h;
      }
      destroy() {
        for (const e of Object.keys(this._hash)) this._hash[e] = null;
        (this._hash = null), (this._renderer = null);
      }
    }
    wa.extension = { type: [M.WebGPUSystem], name: 'bindGroup' };
    class Pa {
      constructor(e) {
        (this._gpuBuffers = Object.create(null)), e.renderableGC.addManagedHash(this, '_gpuBuffers');
      }
      contextChange(e) {
        this._gpu = e;
      }
      getGPUBuffer(e) {
        return this._gpuBuffers[e.uid] || this.createGPUBuffer(e);
      }
      updateBuffer(e) {
        const t = this._gpuBuffers[e.uid] || this.createGPUBuffer(e),
          A = e.data;
        return (
          e._updateID &&
          A &&
          ((e._updateID = 0),
            this._gpu.device.queue.writeBuffer(t, 0, A.buffer, 0, ((e._updateSize || A.byteLength) + 3) & -4)),
          t
        );
      }
      destroyAll() {
        for (const e in this._gpuBuffers) this._gpuBuffers[e]?.destroy();
        this._gpuBuffers = {};
      }
      createGPUBuffer(e) {
        this._gpuBuffers[e.uid] ||
          (e.on('update', this.updateBuffer, this),
            e.on('change', this.onBufferChange, this),
            e.on('destroy', this.onBufferDestroy, this));
        const t = this._gpu.device.createBuffer(e.descriptor);
        return (
          (e._updateID = 0), e.data && (Qi(e.data.buffer, t.getMappedRange()), t.unmap()), (this._gpuBuffers[e.uid] = t), t
        );
      }
      onBufferChange(e) {
        this._gpuBuffers[e.uid].destroy(), (e._updateID = 0), (this._gpuBuffers[e.uid] = this.createGPUBuffer(e));
      }
      onBufferDestroy(e) {
        this._destroyBuffer(e);
      }
      destroy() {
        this.destroyAll(), (this._gpuBuffers = {});
      }
      _destroyBuffer(e) {
        if (
          (e.off('update', this.updateBuffer, this),
            e.off('change', this.onBufferChange, this),
            e.off('destroy', this.onBufferDestroy, this),
            !this._gpuBuffers[e.uid])
        )
          return;
        this._gpuBuffers[e.uid].destroy(), (this._gpuBuffers[e.uid] = null);
      }
    }
    Pa.extension = { type: [M.WebGPUSystem], name: 'buffer' };
    class ff {
      constructor({ minUniformOffsetAlignment: e }) {
        (this._minUniformOffsetAlignment = 256),
          (this.byteIndex = 0),
          (this._minUniformOffsetAlignment = e),
          (this.data = new Float32Array(65535));
      }
      clear() {
        this.byteIndex = 0;
      }
      addEmptyGroup(e) {
        if (e > this._minUniformOffsetAlignment / 4) throw new Error(`UniformBufferBatch: array is too large: ${e * 4}`);
        const t = this.byteIndex;
        let A = t + e * 4;
        if (((A = Math.ceil(A / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment), A > this.data.length * 4))
          throw new Error('UniformBufferBatch: ubo batch got too big');
        return (this.byteIndex = A), t;
      }
      addGroup(e) {
        const t = this.addEmptyGroup(e.length);
        for (let A = 0; A < e.length; A++) this.data[t / 4 + A] = e[A];
        return t;
      }
      destroy() {
        this.data = null;
      }
    }
    class Ja {
      constructor(e) {
        (this._colorMaskCache = 15), (this._renderer = e);
      }
      setMask(e) {
        this._colorMaskCache !== e && ((this._colorMaskCache = e), this._renderer.pipeline.setColorMask(e));
      }
      destroy() {
        (this._renderer = null), (this._colorMaskCache = null);
      }
    }
    Ja.extension = { type: [M.WebGPUSystem], name: 'colorMask' };
    class fr {
      constructor(e) {
        this._renderer = e;
      }
      async init(e) {
        return this._initPromise
          ? this._initPromise
          : ((this._initPromise = (e.gpu ? Promise.resolve(e.gpu) : this._createDeviceAndAdaptor(e)).then((t) => {
            (this.gpu = t), this._renderer.runners.contextChange.emit(this.gpu);
          })),
            this._initPromise);
      }
      contextChange(e) {
        this._renderer.gpu = e;
      }
      async _createDeviceAndAdaptor(e) {
        const t = await J.get()
          .getNavigator()
          .gpu.requestAdapter({ powerPreference: e.powerPreference, forceFallbackAdapter: e.forceFallbackAdapter }),
          A = ['texture-compression-bc', 'texture-compression-astc', 'texture-compression-etc2'].filter((s) =>
            t.features.has(s)
          ),
          r = await t.requestDevice({ requiredFeatures: A });
        return { adapter: t, device: r };
      }
      destroy() {
        (this.gpu = null), (this._renderer = null);
      }
    }
    fr.extension = { type: [M.WebGPUSystem], name: 'device' };
    fr.defaultOptions = { powerPreference: void 0, forceFallbackAdapter: !1 };
    class Ga {
      constructor(e) {
        (this._boundBindGroup = Object.create(null)), (this._boundVertexBuffer = Object.create(null)), (this._renderer = e);
      }
      renderStart() {
        (this.commandFinished = new Promise((e) => {
          this._resolveCommandFinished = e;
        })),
          (this.commandEncoder = this._renderer.gpu.device.createCommandEncoder());
      }
      beginRenderPass(e) {
        this.endRenderPass(), this._clearCache(), (this.renderPassEncoder = this.commandEncoder.beginRenderPass(e.descriptor));
      }
      endRenderPass() {
        this.renderPassEncoder && this.renderPassEncoder.end(), (this.renderPassEncoder = null);
      }
      setViewport(e) {
        this.renderPassEncoder.setViewport(e.x, e.y, e.width, e.height, 0, 1);
      }
      setPipelineFromGeometryProgramAndState(e, t, A, r) {
        const s = this._renderer.pipeline.getPipeline(e, t, A, r);
        this.setPipeline(s);
      }
      setPipeline(e) {
        this._boundPipeline !== e && ((this._boundPipeline = e), this.renderPassEncoder.setPipeline(e));
      }
      _setVertexBuffer(e, t) {
        this._boundVertexBuffer[e] !== t &&
          ((this._boundVertexBuffer[e] = t), this.renderPassEncoder.setVertexBuffer(e, this._renderer.buffer.updateBuffer(t)));
      }
      _setIndexBuffer(e) {
        if (this._boundIndexBuffer === e) return;
        this._boundIndexBuffer = e;
        const t = e.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e), t);
      }
      resetBindGroup(e) {
        this._boundBindGroup[e] = null;
      }
      setBindGroup(e, t, A) {
        if (this._boundBindGroup[e] === t) return;
        (this._boundBindGroup[e] = t), t._touch(this._renderer.textureGC.count);
        const r = this._renderer.bindGroup.getBindGroup(t, A, e);
        this.renderPassEncoder.setBindGroup(e, r);
      }
      setGeometry(e, t) {
        const A = this._renderer.pipeline.getBufferNamesToBind(e, t);
        for (const r in A) this._setVertexBuffer(parseInt(r, 10), e.attributes[A[r]].buffer);
        e.indexBuffer && this._setIndexBuffer(e.indexBuffer);
      }
      _setShaderBindGroups(e, t) {
        for (const A in e.groups) {
          const r = e.groups[A];
          t || this._syncBindGroup(r), this.setBindGroup(A, r, e.gpuProgram);
        }
      }
      _syncBindGroup(e) {
        for (const t in e.resources) {
          const A = e.resources[t];
          A.isUniformGroup && this._renderer.ubo.updateUniformGroup(A);
        }
      }
      draw(e) {
        const { geometry: t, shader: A, state: r, topology: s, size: n, start: a, instanceCount: l, skipSync: h } = e;
        this.setPipelineFromGeometryProgramAndState(t, A.gpuProgram, r, s),
          this.setGeometry(t, A.gpuProgram),
          this._setShaderBindGroups(A, h),
          t.indexBuffer
            ? this.renderPassEncoder.drawIndexed(n || t.indexBuffer.data.length, l ?? t.instanceCount, a || 0)
            : this.renderPassEncoder.draw(n || t.getSize(), l ?? t.instanceCount, a || 0);
      }
      finishRenderPass() {
        this.renderPassEncoder && (this.renderPassEncoder.end(), (this.renderPassEncoder = null));
      }
      postrender() {
        this.finishRenderPass(),
          this._gpu.device.queue.submit([this.commandEncoder.finish()]),
          this._resolveCommandFinished(),
          (this.commandEncoder = null);
      }
      restoreRenderPass() {
        const e = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, !1, [0, 0, 0, 1]);
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(e);
        const t = this._boundPipeline,
          A = { ...this._boundVertexBuffer },
          r = this._boundIndexBuffer,
          s = { ...this._boundBindGroup };
        this._clearCache();
        const n = this._renderer.renderTarget.viewport;
        this.renderPassEncoder.setViewport(n.x, n.y, n.width, n.height, 0, 1), this.setPipeline(t);
        for (const a in A) this._setVertexBuffer(a, A[a]);
        for (const a in s) this.setBindGroup(a, s[a], null);
        this._setIndexBuffer(r);
      }
      _clearCache() {
        for (let e = 0; e < 16; e++) (this._boundBindGroup[e] = null), (this._boundVertexBuffer[e] = null);
        (this._boundIndexBuffer = null), (this._boundPipeline = null);
      }
      destroy() {
        (this._renderer = null),
          (this._gpu = null),
          (this._boundBindGroup = null),
          (this._boundVertexBuffer = null),
          (this._boundIndexBuffer = null),
          (this._boundPipeline = null);
      }
      contextChange(e) {
        this._gpu = e;
      }
    }
    Ga.extension = { type: [M.WebGPUSystem], name: 'encoder', priority: 1 };
    class Wa {
      constructor(e) {
        this._renderer = e;
      }
      contextChange() {
        (this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage),
          (this.maxBatchableTextures = this.maxTextures);
      }
      destroy() { }
    }
    Wa.extension = { type: [M.WebGPUSystem], name: 'limits' };
    class Ka {
      constructor(e) {
        (this._renderTargetStencilState = Object.create(null)),
          (this._renderer = e),
          e.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(e) {
        let t = this._renderTargetStencilState[e.uid];
        t || (t = this._renderTargetStencilState[e.uid] = { stencilMode: ie.DISABLED, stencilReference: 0 }),
          (this._activeRenderTarget = e),
          this.setStencilMode(t.stencilMode, t.stencilReference);
      }
      setStencilMode(e, t) {
        const A = this._renderTargetStencilState[this._activeRenderTarget.uid];
        (A.stencilMode = e), (A.stencilReference = t);
        const r = this._renderer;
        r.pipeline.setStencilMode(e), r.encoder.renderPassEncoder.setStencilReference(t);
      }
      destroy() {
        this._renderer.renderTarget.onRenderTargetChange.remove(this),
          (this._renderer = null),
          (this._activeRenderTarget = null),
          (this._renderTargetStencilState = null);
      }
    }
    Ka.extension = { type: [M.WebGPUSystem], name: 'stencil' };
    const NA = {
      i32: { align: 4, size: 4 },
      u32: { align: 4, size: 4 },
      f32: { align: 4, size: 4 },
      f16: { align: 2, size: 2 },
      'vec2<i32>': { align: 8, size: 8 },
      'vec2<u32>': { align: 8, size: 8 },
      'vec2<f32>': { align: 8, size: 8 },
      'vec2<f16>': { align: 4, size: 4 },
      'vec3<i32>': { align: 16, size: 12 },
      'vec3<u32>': { align: 16, size: 12 },
      'vec3<f32>': { align: 16, size: 12 },
      'vec3<f16>': { align: 8, size: 6 },
      'vec4<i32>': { align: 16, size: 16 },
      'vec4<u32>': { align: 16, size: 16 },
      'vec4<f32>': { align: 16, size: 16 },
      'vec4<f16>': { align: 8, size: 8 },
      'mat2x2<f32>': { align: 8, size: 16 },
      'mat2x2<f16>': { align: 4, size: 8 },
      'mat3x2<f32>': { align: 8, size: 24 },
      'mat3x2<f16>': { align: 4, size: 12 },
      'mat4x2<f32>': { align: 8, size: 32 },
      'mat4x2<f16>': { align: 4, size: 16 },
      'mat2x3<f32>': { align: 16, size: 32 },
      'mat2x3<f16>': { align: 8, size: 16 },
      'mat3x3<f32>': { align: 16, size: 48 },
      'mat3x3<f16>': { align: 8, size: 24 },
      'mat4x3<f32>': { align: 16, size: 64 },
      'mat4x3<f16>': { align: 8, size: 32 },
      'mat2x4<f32>': { align: 16, size: 32 },
      'mat2x4<f16>': { align: 8, size: 16 },
      'mat3x4<f32>': { align: 16, size: 48 },
      'mat3x4<f16>': { align: 8, size: 24 },
      'mat4x4<f32>': { align: 16, size: 64 },
      'mat4x4<f16>': { align: 8, size: 32 },
    };
    function pf(i) {
      const e = i.map((A) => ({ data: A, offset: 0, size: 0 }));
      let t = 0;
      for (let A = 0; A < e.length; A++) {
        const r = e[A];
        let s = NA[r.data.type].size;
        const n = NA[r.data.type].align;
        if (!NA[r.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${r.data.type}`);
        r.data.size > 1 && (s = Math.max(s, n) * r.data.size),
          (t = Math.ceil(t / n) * n),
          (r.size = s),
          (r.offset = t),
          (t += s);
      }
      return (t = Math.ceil(t / 16) * 16), { uboElements: e, size: t };
    }
    function gf(i, e) {
      const { size: t, align: A } = NA[i.data.type],
        r = (A - t) / 4,
        s = i.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';
      return `
         v = uv.${i.data.name};
         ${e !== 0 ? `offset += ${e};` : ''}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${i.data.size * (t / 4)}; i++)
         {
             for(var j = 0; j < ${t / 4}; j++)
             {
                 ${s}[arrayOffset++] = v[t++];
             }
             ${r !== 0 ? `arrayOffset += ${r};` : ''}
         }
     `;
    }
    function mf(i) {
      return sa(i, 'uboWgsl', gf, md);
    }
    class Fa extends ia {
      constructor() {
        super({ createUboElements: pf, generateUboSync: mf });
      }
    }
    Fa.extension = { type: [M.WebGPUSystem], name: 'ubo' };
    const at = 128;
    class Ya {
      constructor(e) {
        (this._bindGroupHash = Object.create(null)),
          (this._buffers = []),
          (this._bindGroups = []),
          (this._bufferResources = []),
          (this._renderer = e),
          this._renderer.renderableGC.addManagedHash(this, '_bindGroupHash'),
          (this._batchBuffer = new ff({ minUniformOffsetAlignment: at }));
        const t = 256 / at;
        for (let A = 0; A < t; A++) {
          let r = K.UNIFORM | K.COPY_DST;
          A === 0 && (r |= K.COPY_SRC), this._buffers.push(new be({ data: this._batchBuffer.data, usage: r }));
        }
      }
      renderEnd() {
        this._uploadBindGroups(), this._resetBindGroups();
      }
      _resetBindGroups() {
        for (const e in this._bindGroupHash) this._bindGroupHash[e] = null;
        this._batchBuffer.clear();
      }
      getUniformBindGroup(e, t) {
        if (!t && this._bindGroupHash[e.uid]) return this._bindGroupHash[e.uid];
        this._renderer.ubo.ensureUniformGroup(e);
        const A = e.buffer.data,
          r = this._batchBuffer.addEmptyGroup(A.length);
        return (
          this._renderer.ubo.syncUniformGroup(e, this._batchBuffer.data, r / 4),
          (this._bindGroupHash[e.uid] = this._getBindGroup(r / at)),
          this._bindGroupHash[e.uid]
        );
      }
      getUboResource(e) {
        this._renderer.ubo.updateUniformGroup(e);
        const t = e.buffer.data,
          A = this._batchBuffer.addGroup(t);
        return this._getBufferResource(A / at);
      }
      getArrayBindGroup(e) {
        const t = this._batchBuffer.addGroup(e);
        return this._getBindGroup(t / at);
      }
      getArrayBufferResource(e) {
        const A = this._batchBuffer.addGroup(e) / at;
        return this._getBufferResource(A);
      }
      _getBufferResource(e) {
        if (!this._bufferResources[e]) {
          const t = this._buffers[e % 2];
          this._bufferResources[e] = new cr({ buffer: t, offset: ((e / 2) | 0) * 256, size: at });
        }
        return this._bufferResources[e];
      }
      _getBindGroup(e) {
        if (!this._bindGroups[e]) {
          const t = new Le({ 0: this._getBufferResource(e) });
          this._bindGroups[e] = t;
        }
        return this._bindGroups[e];
      }
      _uploadBindGroups() {
        const e = this._renderer.buffer,
          t = this._buffers[0];
        t.update(this._batchBuffer.byteIndex), e.updateBuffer(t);
        const A = this._renderer.gpu.device.createCommandEncoder();
        for (let r = 1; r < this._buffers.length; r++) {
          const s = this._buffers[r];
          A.copyBufferToBuffer(e.getGPUBuffer(t), at, e.getGPUBuffer(s), 0, this._batchBuffer.byteIndex);
        }
        this._renderer.gpu.device.queue.submit([A.finish()]);
      }
      destroy() {
        for (let e = 0; e < this._bindGroups.length; e++) this._bindGroups[e]?.destroy();
        (this._bindGroups = null), (this._bindGroupHash = null);
        for (let e = 0; e < this._buffers.length; e++) this._buffers[e].destroy();
        this._buffers = null;
        for (let e = 0; e < this._bufferResources.length; e++) this._bufferResources[e].destroy();
        (this._bufferResources = null), this._batchBuffer.destroy(), (this._bindGroupHash = null), (this._renderer = null);
      }
    }
    Ya.extension = { type: [M.WebGPUPipes], name: 'uniformBatch' };
    const kS = { 'point-list': 0, 'line-list': 1, 'line-strip': 2, 'triangle-list': 3, 'triangle-strip': 4 };
    function RS(i, e, t, A, r) {
      return (i << 24) | (e << 16) | (t << 10) | (A << 5) | r;
    }
    function BS(i, e, t, A) {
      return (t << 6) | (i << 3) | (A << 1) | e;
    }
    class Da {
      constructor(e) {
        (this._moduleCache = Object.create(null)),
          (this._bufferLayoutsCache = Object.create(null)),
          (this._bindingNamesCache = Object.create(null)),
          (this._pipeCache = Object.create(null)),
          (this._pipeStateCaches = Object.create(null)),
          (this._colorMask = 15),
          (this._multisampleCount = 1),
          (this._renderer = e);
      }
      contextChange(e) {
        (this._gpu = e), this.setStencilMode(ie.DISABLED), this._updatePipeHash();
      }
      setMultisampleCount(e) {
        this._multisampleCount !== e && ((this._multisampleCount = e), this._updatePipeHash());
      }
      setRenderTarget(e) {
        (this._multisampleCount = e.msaaSamples),
          (this._depthStencilAttachment = e.descriptor.depthStencilAttachment ? 1 : 0),
          this._updatePipeHash();
      }
      setColorMask(e) {
        this._colorMask !== e && ((this._colorMask = e), this._updatePipeHash());
      }
      setStencilMode(e) {
        this._stencilMode !== e && ((this._stencilMode = e), (this._stencilState = rt[e]), this._updatePipeHash());
      }
      setPipeline(e, t, A, r) {
        const s = this.getPipeline(e, t, A);
        r.setPipeline(s);
      }
      getPipeline(e, t, A, r) {
        e._layoutKey || (Xn(e, t.attributeData), this._generateBufferKey(e)), r || (r = e.topology);
        const s = RS(e._layoutKey, t._layoutKey, A.data, A._blendModeId, kS[r]);
        return this._pipeCache[s]
          ? this._pipeCache[s]
          : ((this._pipeCache[s] = this._createPipeline(e, t, A, r)), this._pipeCache[s]);
      }
      _createPipeline(e, t, A, r) {
        const s = this._gpu.device,
          n = this._createVertexBufferLayouts(e, t),
          a = this._renderer.state.getColorTargets(A);
        a[0].writeMask = this._stencilMode === ie.RENDERING_MASK_ADD ? 0 : this._colorMask;
        const l = this._renderer.shader.getProgramData(t).pipeline,
          h = {
            vertex: { module: this._getModule(t.vertex.source), entryPoint: t.vertex.entryPoint, buffers: n },
            fragment: { module: this._getModule(t.fragment.source), entryPoint: t.fragment.entryPoint, targets: a },
            primitive: { topology: r, cullMode: A.cullMode },
            layout: l,
            multisample: { count: this._multisampleCount },
            label: 'PIXI Pipeline',
          };
        return (
          this._depthStencilAttachment &&
          (h.depthStencil = {
            ...this._stencilState,
            format: 'depth24plus-stencil8',
            depthWriteEnabled: A.depthTest,
            depthCompare: A.depthTest ? 'less' : 'always',
          }),
          s.createRenderPipeline(h)
        );
      }
      _getModule(e) {
        return this._moduleCache[e] || this._createModule(e);
      }
      _createModule(e) {
        const t = this._gpu.device;
        return (this._moduleCache[e] = t.createShaderModule({ code: e })), this._moduleCache[e];
      }
      _generateBufferKey(e) {
        const t = [];
        let A = 0;
        const r = Object.keys(e.attributes).sort();
        for (let n = 0; n < r.length; n++) {
          const a = e.attributes[r[n]];
          (t[A++] = a.offset), (t[A++] = a.format), (t[A++] = a.stride), (t[A++] = a.instance);
        }
        const s = t.join('|');
        return (e._layoutKey = _t(s, 'geometry')), e._layoutKey;
      }
      _generateAttributeLocationsKey(e) {
        const t = [];
        let A = 0;
        const r = Object.keys(e.attributeData).sort();
        for (let n = 0; n < r.length; n++) {
          const a = e.attributeData[r[n]];
          t[A++] = a.location;
        }
        const s = t.join('|');
        return (e._attributeLocationsKey = _t(s, 'programAttributes')), e._attributeLocationsKey;
      }
      getBufferNamesToBind(e, t) {
        const A = (e._layoutKey << 16) | t._attributeLocationsKey;
        if (this._bindingNamesCache[A]) return this._bindingNamesCache[A];
        const r = this._createVertexBufferLayouts(e, t),
          s = Object.create(null),
          n = t.attributeData;
        for (let a = 0; a < r.length; a++) {
          const h = Object.values(r[a].attributes)[0].shaderLocation;
          for (const u in n)
            if (n[u].location === h) {
              s[a] = u;
              break;
            }
        }
        return (this._bindingNamesCache[A] = s), s;
      }
      _createVertexBufferLayouts(e, t) {
        t._attributeLocationsKey || this._generateAttributeLocationsKey(t);
        const A = (e._layoutKey << 16) | t._attributeLocationsKey;
        if (this._bufferLayoutsCache[A]) return this._bufferLayoutsCache[A];
        const r = [];
        return (
          e.buffers.forEach((s) => {
            const n = { arrayStride: 0, stepMode: 'vertex', attributes: [] },
              a = n.attributes;
            for (const l in t.attributeData) {
              const h = e.attributes[l];
              (h.divisor ?? 1) !== 1 &&
                N(`Attribute ${l} has an invalid divisor value of '${h.divisor}'. WebGPU only supports a divisor value of 1`),
                h.buffer === s &&
                ((n.arrayStride = h.stride),
                  (n.stepMode = h.instance ? 'instance' : 'vertex'),
                  a.push({ shaderLocation: t.attributeData[l].location, offset: h.offset, format: h.format }));
            }
            a.length && r.push(n);
          }),
          (this._bufferLayoutsCache[A] = r),
          r
        );
      }
      _updatePipeHash() {
        const e = BS(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
        this._pipeStateCaches[e] || (this._pipeStateCaches[e] = Object.create(null)),
          (this._pipeCache = this._pipeStateCaches[e]);
      }
      destroy() {
        (this._renderer = null), (this._bufferLayoutsCache = null);
      }
    }
    Da.extension = { type: [M.WebGPUSystem], name: 'pipeline' };
    class Sf {
      constructor() {
        (this.contexts = []), (this.msaaTextures = []), (this.msaaSamples = 1);
      }
    }
    class qf {
      init(e, t) {
        (this._renderer = e), (this._renderTargetSystem = t);
      }
      copyToTexture(e, t, A, r, s) {
        const n = this._renderer,
          a = this._getGpuColorTexture(e),
          l = n.texture.getGpuSource(t.source);
        return n.encoder.commandEncoder.copyTextureToTexture({ texture: a, origin: A }, { texture: l, origin: s }, r), t;
      }
      startRenderPass(e, t = !0, A, r) {
        const n = this._renderTargetSystem.getGpuRenderTarget(e),
          a = this.getDescriptor(e, t, A);
        (n.descriptor = a),
          this._renderer.pipeline.setRenderTarget(n),
          this._renderer.encoder.beginRenderPass(n),
          this._renderer.encoder.setViewport(r);
      }
      finishRenderPass() {
        this._renderer.encoder.endRenderPass();
      }
      _getGpuColorTexture(e) {
        const t = this._renderTargetSystem.getGpuRenderTarget(e);
        return t.contexts[0]
          ? t.contexts[0].getCurrentTexture()
          : this._renderer.texture.getGpuSource(e.colorTextures[0].source);
      }
      getDescriptor(e, t, A) {
        typeof t == 'boolean' && (t = t ? Ve.ALL : Ve.NONE);
        const r = this._renderTargetSystem,
          s = r.getGpuRenderTarget(e),
          n = e.colorTextures.map((h, u) => {
            const o = s.contexts[u];
            let c, d;
            o
              ? (c = o.getCurrentTexture().createView())
              : (c = this._renderer.texture.getGpuSource(h).createView({ mipLevelCount: 1 })),
              s.msaaTextures[u] && ((d = c), (c = this._renderer.texture.getTextureView(s.msaaTextures[u])));
            const f = t & Ve.COLOR ? 'clear' : 'load';
            return A ?? (A = r.defaultClearColor), { view: c, resolveTarget: d, clearValue: A, storeOp: 'store', loadOp: f };
          });
        let a;
        if (
          ((e.stencil || e.depth) &&
            !e.depthStencilTexture &&
            (e.ensureDepthStencilTexture(), (e.depthStencilTexture.source.sampleCount = s.msaa ? 4 : 1)),
            e.depthStencilTexture)
        ) {
          const h = t & Ve.STENCIL ? 'clear' : 'load',
            u = t & Ve.DEPTH ? 'clear' : 'load';
          a = {
            view: this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),
            stencilStoreOp: 'store',
            stencilLoadOp: h,
            depthClearValue: 1,
            depthLoadOp: u,
            depthStoreOp: 'store',
          };
        }
        return { colorAttachments: n, depthStencilAttachment: a };
      }
      clear(e, t = !0, A, r) {
        if (!t) return;
        const { gpu: s, encoder: n } = this._renderer,
          a = s.device;
        if (n.commandEncoder === null) {
          const h = a.createCommandEncoder(),
            u = this.getDescriptor(e, t, A),
            o = h.beginRenderPass(u);
          o.setViewport(r.x, r.y, r.width, r.height, 0, 1), o.end();
          const c = h.finish();
          a.queue.submit([c]);
        } else this.startRenderPass(e, t, A, r);
      }
      initGpuRenderTarget(e) {
        e.isRoot = !0;
        const t = new Sf();
        return (
          e.colorTextures.forEach((A, r) => {
            if (A instanceof Oe) {
              const s = A.resource.getContext('webgpu'),
                n = A.transparent ? 'premultiplied' : 'opaque';
              try {
                s.configure({
                  device: this._renderer.gpu.device,
                  usage:
                    GPUTextureUsage.TEXTURE_BINDING |
                    GPUTextureUsage.COPY_DST |
                    GPUTextureUsage.RENDER_ATTACHMENT |
                    GPUTextureUsage.COPY_SRC,
                  format: 'bgra8unorm',
                  alphaMode: n,
                });
              } catch { }
              t.contexts[r] = s;
            }
            if (((t.msaa = A.source.antialias), A.source.antialias)) {
              const s = new ne({ width: 0, height: 0, sampleCount: 4 });
              t.msaaTextures[r] = s;
            }
          }),
          t.msaa && ((t.msaaSamples = 4), e.depthStencilTexture && (e.depthStencilTexture.source.sampleCount = 4)),
          t
        );
      }
      destroyGpuRenderTarget(e) {
        e.contexts.forEach((t) => {
          t.unconfigure();
        }),
          e.msaaTextures.forEach((t) => {
            t.destroy();
          }),
          (e.msaaTextures.length = 0),
          (e.contexts.length = 0);
      }
      ensureDepthStencilTexture(e) {
        const t = this._renderTargetSystem.getGpuRenderTarget(e);
        e.depthStencilTexture && t.msaa && (e.depthStencilTexture.source.sampleCount = 4);
      }
      resizeGpuRenderTarget(e) {
        const t = this._renderTargetSystem.getGpuRenderTarget(e);
        (t.width = e.width),
          (t.height = e.height),
          t.msaa &&
          e.colorTextures.forEach((A, r) => {
            t.msaaTextures[r]?.resize(A.source.width, A.source.height, A.source._resolution);
          });
      }
    }
    class Oa extends la {
      constructor(e) {
        super(e), (this.adaptor = new qf()), this.adaptor.init(e, this);
      }
    }
    Oa.extension = { type: [M.WebGPUSystem], name: 'renderTarget' };
    class La {
      constructor() {
        this._gpuProgramData = Object.create(null);
      }
      contextChange(e) {
        this._gpu = e;
      }
      getProgramData(e) {
        return this._gpuProgramData[e._layoutKey] || this._createGPUProgramData(e);
      }
      _createGPUProgramData(e) {
        const t = this._gpu.device,
          A = e.gpuLayout.map((s) => t.createBindGroupLayout({ entries: s })),
          r = { bindGroupLayouts: A };
        return (
          (this._gpuProgramData[e._layoutKey] = { bindGroups: A, pipeline: t.createPipelineLayout(r) }),
          this._gpuProgramData[e._layoutKey]
        );
      }
      destroy() {
        (this._gpu = null), (this._gpuProgramData = null);
      }
    }
    La.extension = { type: [M.WebGPUSystem], name: 'shader' };
    const Ee = {};
    Ee.normal = {
      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      color: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
    };
    Ee.add = {
      alpha: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      color: { srcFactor: 'one', dstFactor: 'one', operation: 'add' },
    };
    Ee.multiply = {
      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      color: { srcFactor: 'dst', dstFactor: 'one-minus-src-alpha', operation: 'add' },
    };
    Ee.screen = {
      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      color: { srcFactor: 'one', dstFactor: 'one-minus-src', operation: 'add' },
    };
    Ee.overlay = {
      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      color: { srcFactor: 'one', dstFactor: 'one-minus-src', operation: 'add' },
    };
    Ee.none = {
      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      color: { srcFactor: 'zero', dstFactor: 'zero', operation: 'add' },
    };
    Ee['normal-npm'] = {
      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
    };
    Ee['add-npm'] = {
      alpha: { srcFactor: 'one', dstFactor: 'one', operation: 'add' },
      color: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
    };
    Ee['screen-npm'] = {
      alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src', operation: 'add' },
    };
    Ee.erase = {
      alpha: { srcFactor: 'zero', dstFactor: 'one-minus-src-alpha', operation: 'add' },
      color: { srcFactor: 'zero', dstFactor: 'one-minus-src', operation: 'add' },
    };
    Ee.min = {
      alpha: { srcFactor: 'one', dstFactor: 'one', operation: 'min' },
      color: { srcFactor: 'one', dstFactor: 'one', operation: 'min' },
    };
    Ee.max = {
      alpha: { srcFactor: 'one', dstFactor: 'one', operation: 'max' },
      color: { srcFactor: 'one', dstFactor: 'one', operation: 'max' },
    };
    class ja {
      constructor() {
        (this.defaultState = new Ue()), (this.defaultState.blend = !0);
      }
      contextChange(e) {
        this.gpu = e;
      }
      getColorTargets(e) {
        return [{ format: 'bgra8unorm', writeMask: 0, blend: Ee[e.blendMode] || Ee.normal }];
      }
      destroy() {
        this.gpu = null;
      }
    }
    ja.extension = { type: [M.WebGPUSystem], name: 'state' };
    const Mf = {
      type: 'image',
      upload(i, e, t) {
        const A = i.resource,
          r = (i.pixelWidth | 0) * (i.pixelHeight | 0),
          s = A.byteLength / r;
        t.device.queue.writeTexture(
          { texture: e },
          A,
          { offset: 0, rowsPerImage: i.pixelHeight, bytesPerRow: i.pixelWidth * s },
          { width: i.pixelWidth, height: i.pixelHeight, depthOrArrayLayers: 1 }
        );
      },
    },
      Za = {
        'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
        'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
        'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      },
      NS = { blockBytes: 4, blockWidth: 1, blockHeight: 1 },
      Ef = {
        type: 'compressed',
        upload(i, e, t) {
          let A = i.pixelWidth,
            r = i.pixelHeight;
          const s = Za[i.format] || NS;
          for (let n = 0; n < i.resource.length; n++) {
            const a = i.resource[n],
              l = Math.ceil(A / s.blockWidth) * s.blockBytes;
            t.device.queue.writeTexture(
              { texture: e, mipLevel: n },
              a,
              { offset: 0, bytesPerRow: l },
              {
                width: Math.ceil(A / s.blockWidth) * s.blockWidth,
                height: Math.ceil(r / s.blockHeight) * s.blockHeight,
                depthOrArrayLayers: 1,
              }
            ),
              (A = Math.max(A >> 1, 1)),
              (r = Math.max(r >> 1, 1));
          }
        },
      },
      Xa = {
        type: 'image',
        upload(i, e, t) {
          const A = i.resource;
          if (!A) return;
          if (globalThis.HTMLImageElement && A instanceof HTMLImageElement) {
            const a = J.get().createCanvas(A.width, A.height);
            a.getContext('2d').drawImage(A, 0, 0, A.width, A.height),
              (i.resource = a),
              N('ImageSource: Image element passed, converting to canvas and replacing resource.');
          }
          const r = Math.min(e.width, i.resourceWidth || i.pixelWidth),
            s = Math.min(e.height, i.resourceHeight || i.pixelHeight),
            n = i.alphaMode === 'premultiply-alpha-on-upload';
          t.device.queue.copyExternalImageToTexture(
            { source: A },
            { texture: e, premultipliedAlpha: n },
            { width: r, height: s }
          );
        },
      },
      Vf = {
        type: 'video',
        upload(i, e, t) {
          Xa.upload(i, e, t);
        },
      };
    class Tf {
      constructor(e) {
        (this.device = e), (this.sampler = e.createSampler({ minFilter: 'linear' })), (this.pipelines = {});
      }
      _getMipmapPipeline(e) {
        let t = this.pipelines[e];
        return (
          t ||
          (this.mipmapShaderModule ||
            (this.mipmapShaderModule = this.device.createShaderModule({
              code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `,
            })),
            (t = this.device.createRenderPipeline({
              layout: 'auto',
              vertex: { module: this.mipmapShaderModule, entryPoint: 'vertexMain' },
              fragment: { module: this.mipmapShaderModule, entryPoint: 'fragmentMain', targets: [{ format: e }] },
            })),
            (this.pipelines[e] = t)),
          t
        );
      }
      generateMipmap(e) {
        const t = this._getMipmapPipeline(e.format);
        if (e.dimension === '3d' || e.dimension === '1d')
          throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');
        let A = e;
        const r = e.depthOrArrayLayers || 1,
          s = e.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!s) {
          const l = {
            size: { width: Math.ceil(e.width / 2), height: Math.ceil(e.height / 2), depthOrArrayLayers: r },
            format: e.format,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
            mipLevelCount: e.mipLevelCount - 1,
          };
          A = this.device.createTexture(l);
        }
        const n = this.device.createCommandEncoder({}),
          a = t.getBindGroupLayout(0);
        for (let l = 0; l < r; ++l) {
          let h = e.createView({ baseMipLevel: 0, mipLevelCount: 1, dimension: '2d', baseArrayLayer: l, arrayLayerCount: 1 }),
            u = s ? 1 : 0;
          for (let o = 1; o < e.mipLevelCount; ++o) {
            const c = A.createView({
              baseMipLevel: u++,
              mipLevelCount: 1,
              dimension: '2d',
              baseArrayLayer: l,
              arrayLayerCount: 1,
            }),
              d = n.beginRenderPass({
                colorAttachments: [{ view: c, storeOp: 'store', loadOp: 'clear', clearValue: { r: 0, g: 0, b: 0, a: 0 } }],
              }),
              f = this.device.createBindGroup({
                layout: a,
                entries: [
                  { binding: 0, resource: this.sampler },
                  { binding: 1, resource: h },
                ],
              });
            d.setPipeline(t), d.setBindGroup(0, f), d.draw(3, 1, 0, 0), d.end(), (h = c);
          }
        }
        if (!s) {
          const l = { width: Math.ceil(e.width / 2), height: Math.ceil(e.height / 2), depthOrArrayLayers: r };
          for (let h = 1; h < e.mipLevelCount; ++h)
            n.copyTextureToTexture({ texture: A, mipLevel: h - 1 }, { texture: e, mipLevel: h }, l),
              (l.width = Math.ceil(l.width / 2)),
              (l.height = Math.ceil(l.height / 2));
        }
        return this.device.queue.submit([n.finish()]), s || A.destroy(), e;
      }
    }
    class Ha {
      constructor(e) {
        (this.managedTextures = []),
          (this._gpuSources = Object.create(null)),
          (this._gpuSamplers = Object.create(null)),
          (this._bindGroupHash = Object.create(null)),
          (this._textureViewHash = Object.create(null)),
          (this._uploads = { image: Xa, buffer: Mf, video: Vf, compressed: Ef }),
          (this._renderer = e),
          e.renderableGC.addManagedHash(this, '_gpuSources'),
          e.renderableGC.addManagedHash(this, '_gpuSamplers'),
          e.renderableGC.addManagedHash(this, '_bindGroupHash'),
          e.renderableGC.addManagedHash(this, '_textureViewHash');
      }
      contextChange(e) {
        this._gpu = e;
      }
      initSource(e) {
        return this._gpuSources[e.uid] ? this._gpuSources[e.uid] : this._initSource(e);
      }
      _initSource(e) {
        if (e.autoGenerateMipmaps) {
          const l = Math.max(e.pixelWidth, e.pixelHeight);
          e.mipLevelCount = Math.floor(Math.log2(l)) + 1;
        }
        let t = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
        e.uploadMethodId !== 'compressed' && ((t |= GPUTextureUsage.RENDER_ATTACHMENT), (t |= GPUTextureUsage.COPY_SRC));
        const A = Za[e.format] || { blockWidth: 1, blockHeight: 1 },
          r = Math.ceil(e.pixelWidth / A.blockWidth) * A.blockWidth,
          s = Math.ceil(e.pixelHeight / A.blockHeight) * A.blockHeight,
          n = {
            label: e.label,
            size: { width: r, height: s },
            format: e.format,
            sampleCount: e.sampleCount,
            mipLevelCount: e.mipLevelCount,
            dimension: e.dimension,
            usage: t,
          },
          a = (this._gpuSources[e.uid] = this._gpu.device.createTexture(n));
        return (
          this.managedTextures.includes(e) ||
          (e.on('update', this.onSourceUpdate, this),
            e.on('resize', this.onSourceResize, this),
            e.on('destroy', this.onSourceDestroy, this),
            e.on('unload', this.onSourceUnload, this),
            e.on('updateMipmaps', this.onUpdateMipmaps, this),
            this.managedTextures.push(e)),
          this.onSourceUpdate(e),
          a
        );
      }
      onSourceUpdate(e) {
        const t = this.getGpuSource(e);
        t &&
          (this._uploads[e.uploadMethodId] && this._uploads[e.uploadMethodId].upload(e, t, this._gpu),
            e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e));
      }
      onSourceUnload(e) {
        const t = this._gpuSources[e.uid];
        t && ((this._gpuSources[e.uid] = null), t.destroy());
      }
      onUpdateMipmaps(e) {
        this._mipmapGenerator || (this._mipmapGenerator = new Tf(this._gpu.device));
        const t = this.getGpuSource(e);
        this._mipmapGenerator.generateMipmap(t);
      }
      onSourceDestroy(e) {
        e.off('update', this.onSourceUpdate, this),
          e.off('unload', this.onSourceUnload, this),
          e.off('destroy', this.onSourceDestroy, this),
          e.off('resize', this.onSourceResize, this),
          e.off('updateMipmaps', this.onUpdateMipmaps, this),
          this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
          this.onSourceUnload(e);
      }
      onSourceResize(e) {
        const t = this._gpuSources[e.uid];
        t
          ? (t.width !== e.pixelWidth || t.height !== e.pixelHeight) &&
          ((this._textureViewHash[e.uid] = null),
            (this._bindGroupHash[e.uid] = null),
            this.onSourceUnload(e),
            this.initSource(e))
          : this.initSource(e);
      }
      _initSampler(e) {
        return (this._gpuSamplers[e._resourceId] = this._gpu.device.createSampler(e)), this._gpuSamplers[e._resourceId];
      }
      getGpuSampler(e) {
        return this._gpuSamplers[e._resourceId] || this._initSampler(e);
      }
      getGpuSource(e) {
        return this._gpuSources[e.uid] || this.initSource(e);
      }
      getTextureBindGroup(e) {
        return this._bindGroupHash[e.uid] ?? this._createTextureBindGroup(e);
      }
      _createTextureBindGroup(e) {
        const t = e.source;
        return (
          (this._bindGroupHash[e.uid] = new Le({
            0: t,
            1: t.style,
            2: new qe({ uTextureMatrix: { type: 'mat3x3<f32>', value: e.textureMatrix.mapCoord } }),
          })),
          this._bindGroupHash[e.uid]
        );
      }
      getTextureView(e) {
        const t = e.source;
        return this._textureViewHash[t.uid] ?? this._createTextureView(t);
      }
      _createTextureView(e) {
        return (this._textureViewHash[e.uid] = this.getGpuSource(e).createView()), this._textureViewHash[e.uid];
      }
      generateCanvas(e) {
        const t = this._renderer,
          A = t.gpu.device.createCommandEncoder(),
          r = J.get().createCanvas();
        (r.width = e.source.pixelWidth), (r.height = e.source.pixelHeight);
        const s = r.getContext('webgpu');
        return (
          s.configure({
            device: t.gpu.device,
            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            format: J.get().getNavigator().gpu.getPreferredCanvasFormat(),
            alphaMode: 'premultiplied',
          }),
          A.copyTextureToTexture(
            { texture: t.texture.getGpuSource(e.source), origin: { x: 0, y: 0 } },
            { texture: s.getCurrentTexture() },
            { width: r.width, height: r.height }
          ),
          t.gpu.device.queue.submit([A.finish()]),
          r
        );
      }
      getPixels(e) {
        const t = this.generateCanvas(e),
          A = Xe.getOptimalCanvasAndContext(t.width, t.height),
          r = A.context;
        r.drawImage(t, 0, 0);
        const { width: s, height: n } = t,
          a = r.getImageData(0, 0, s, n),
          l = new Uint8ClampedArray(a.data.buffer);
        return Xe.returnCanvasAndContext(A), { pixels: l, width: s, height: n };
      }
      destroy() {
        this.managedTextures.slice().forEach((e) => this.onSourceDestroy(e)), (this.managedTextures = null);
        for (const e of Object.keys(this._bindGroupHash)) {
          const t = Number(e);
          this._bindGroupHash[t]?.destroy(), (this._bindGroupHash[t] = null);
        }
        (this._renderer = null),
          (this._gpu = null),
          (this._mipmapGenerator = null),
          (this._gpuSources = null),
          (this._bindGroupHash = null),
          (this._textureViewHash = null),
          (this._gpuSamplers = null);
      }
    }
    Ha.extension = { type: [M.WebGPUSystem], name: 'texture' };
    class za {
      constructor() {
        this._maxTextures = 0;
      }
      contextChange(e) {
        const t = new qe({
          uTransformMatrix: { value: new R(), type: 'mat3x3<f32>' },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },
          uRound: { value: 0, type: 'f32' },
        });
        this._maxTextures = e.limits.maxBatchableTextures;
        const A = rA({ name: 'graphics', bits: [er, Ar(this._maxTextures), nd, nA] });
        this.shader = new ke({ gpuProgram: A, resources: { localUniforms: t } });
      }
      execute(e, t) {
        const A = t.context,
          r = A.customShader || this.shader,
          s = e.renderer,
          n = s.graphicsContext,
          { batcher: a, instructions: l } = n.getContextRenderData(A),
          h = s.encoder;
        h.setGeometry(a.geometry, r.gpuProgram);
        const u = s.globalUniforms.bindGroup;
        h.setBindGroup(0, u, r.gpuProgram);
        const o = s.renderPipes.uniformBatch.getUniformBindGroup(r.resources.localUniforms, !0);
        h.setBindGroup(2, o, r.gpuProgram);
        const c = l.instructions;
        let d = null;
        for (let f = 0; f < l.instructionSize; f++) {
          const g = c[f];
          if (
            (g.topology !== d &&
              ((d = g.topology), h.setPipelineFromGeometryProgramAndState(a.geometry, r.gpuProgram, e.state, g.topology)),
              (r.groups[1] = g.bindGroup),
              !g.gpuBindGroup)
          ) {
            const p = g.textures;
            (g.bindGroup = $i(p.textures, p.count, this._maxTextures)),
              (g.gpuBindGroup = s.bindGroup.getBindGroup(g.bindGroup, r.gpuProgram, 1));
          }
          h.setBindGroup(1, g.bindGroup, r.gpuProgram), h.renderPassEncoder.drawIndexed(g.size, 1, g.start);
        }
      }
      destroy() {
        this.shader.destroy(!0), (this.shader = null);
      }
    }
    za.extension = { type: [M.WebGPUPipesAdaptor], name: 'graphics' };
    class _a {
      init() {
        const e = rA({ name: 'mesh', bits: [Ht, ad, nA] });
        this._shader = new ke({
          gpuProgram: e,
          resources: {
            uTexture: v.EMPTY._source,
            uSampler: v.EMPTY._source.style,
            textureUniforms: { uTextureMatrix: { type: 'mat3x3<f32>', value: new R() } },
          },
        });
      }
      execute(e, t) {
        const A = e.renderer;
        let r = t._shader;
        if (!r) (r = this._shader), (r.groups[2] = A.texture.getTextureBindGroup(t.texture));
        else if (!r.gpuProgram) {
          N('Mesh shader has no gpuProgram', t.shader);
          return;
        }
        const s = r.gpuProgram;
        if ((s.autoAssignGlobalUniforms && (r.groups[0] = A.globalUniforms.bindGroup), s.autoAssignLocalUniforms)) {
          const n = e.localUniforms;
          r.groups[1] = A.renderPipes.uniformBatch.getUniformBindGroup(n, !0);
        }
        A.encoder.draw({ geometry: t._geometry, shader: r, state: t.state });
      }
      destroy() {
        this._shader.destroy(!0), (this._shader = null);
      }
    }
    _a.extension = { type: [M.WebGPUPipesAdaptor], name: 'mesh' };
    const QS = [...Na, Fa, Ga, fr, Wa, Pa, Ha, Oa, La, ja, Da, Ja, Ka, wa],
      wS = [...Qa, Ya],
      PS = [Kn, _a, za],
      If = [],
      bf = [],
      yf = [];
    Q.handleByNamedList(M.WebGPUSystem, If);
    Q.handleByNamedList(M.WebGPUPipes, bf);
    Q.handleByNamedList(M.WebGPUPipesAdaptor, yf);
    Q.add(...QS, ...wS, ...PS);
    class xf extends zA {
      constructor() {
        const e = { name: 'webgpu', type: we.WEBGPU, systems: If, renderPipes: bf, renderPipeAdaptors: yf };
        super(e);
      }
    }
    const JS = Object.freeze(
      Object.defineProperty({ __proto__: null, WebGPURenderer: xf }, Symbol.toStringTag, { value: 'Module' })
    );
    class vf {
      constructor() {
        (this.batches = []), (this.batched = !1);
      }
      destroy() {
        this.batches.forEach((e) => {
          se.return(e);
        }),
          (this.batches.length = 0);
      }
    }
    class $a {
      constructor(e, t) {
        (this.state = Ue.for2d()), (this.renderer = e), (this._adaptor = t), this.renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._adaptor.contextChange(this.renderer);
      }
      validateRenderable(e) {
        const t = e.context,
          A = !!e._gpuData,
          r = this.renderer.graphicsContext.updateGpuContext(t);
        return !!(r.isBatchable || A !== r.isBatchable);
      }
      addRenderable(e, t) {
        const A = this.renderer.graphicsContext.updateGpuContext(e.context);
        e.didViewUpdate && this._rebuild(e),
          A.isBatchable ? this._addToBatcher(e, t) : (this.renderer.renderPipes.batch.break(t), t.add(e));
      }
      updateRenderable(e) {
        const A = this._getGpuDataForRenderable(e).batches;
        for (let r = 0; r < A.length; r++) {
          const s = A[r];
          s._batcher.updateElement(s);
        }
      }
      execute(e) {
        if (!e.isRenderable) return;
        const t = this.renderer,
          A = e.context;
        if (!t.graphicsContext.getGpuContext(A).batches.length) return;
        const s = A.customShader || this._adaptor.shader;
        this.state.blendMode = e.groupBlendMode;
        const n = s.resources.localUniforms.uniforms;
        (n.uTransformMatrix = e.groupTransform),
          (n.uRound = t._roundPixels | e._roundPixels),
          lA(e.groupColorAlpha, n.uColor, 0),
          this._adaptor.execute(this, e);
      }
      _rebuild(e) {
        const t = this._getGpuDataForRenderable(e),
          A = this.renderer.graphicsContext.updateGpuContext(e.context);
        t.destroy(), A.isBatchable && this._updateBatchesForRenderable(e, t);
      }
      _addToBatcher(e, t) {
        const A = this.renderer.renderPipes.batch,
          r = this._getGpuDataForRenderable(e).batches;
        for (let s = 0; s < r.length; s++) {
          const n = r[s];
          A.addToBatch(n, t);
        }
      }
      _getGpuDataForRenderable(e) {
        return e._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(e);
      }
      _initGpuDataForRenderable(e) {
        const t = new vf();
        return (e._gpuData[this.renderer.uid] = t), t;
      }
      _updateBatchesForRenderable(e, t) {
        const A = e.context,
          r = this.renderer.graphicsContext.getGpuContext(A),
          s = this.renderer._roundPixels | e._roundPixels;
        t.batches = r.batches.map((n) => {
          const a = se.get(nr);
          return n.copyTo(a), (a.renderable = e), (a.roundPixels = s), a;
        });
      }
      destroy() {
        (this.renderer = null), this._adaptor.destroy(), (this._adaptor = null), (this.state = null);
      }
    }
    $a.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'graphics' };
    const Cf = class Uf extends oA {
      constructor(...e) {
        super({});
        let t = e[0] ?? {};
        typeof t == 'number' &&
          (P(W, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead'),
            (t = { width: t, height: e[1], verticesX: e[2], verticesY: e[3] })),
          this.build(t);
      }
      build(e) {
        (e = { ...Uf.defaultOptions, ...e }),
          (this.verticesX = this.verticesX ?? e.verticesX),
          (this.verticesY = this.verticesY ?? e.verticesY),
          (this.width = this.width ?? e.width),
          (this.height = this.height ?? e.height);
        const t = this.verticesX * this.verticesY,
          A = [],
          r = [],
          s = [],
          n = this.verticesX - 1,
          a = this.verticesY - 1,
          l = this.width / n,
          h = this.height / a;
        for (let o = 0; o < t; o++) {
          const c = o % this.verticesX,
            d = (o / this.verticesX) | 0;
          A.push(c * l, d * h), r.push(c / n, d / a);
        }
        const u = n * a;
        for (let o = 0; o < u; o++) {
          const c = o % n,
            d = (o / n) | 0,
            f = d * this.verticesX + c,
            g = d * this.verticesX + c + 1,
            p = (d + 1) * this.verticesX + c,
            m = (d + 1) * this.verticesX + c + 1;
          s.push(f, g, p, g, m, p);
        }
        (this.buffers[0].data = new Float32Array(A)),
          (this.buffers[1].data = new Float32Array(r)),
          (this.indexBuffer.data = new Uint32Array(s)),
          this.buffers[0].update(),
          this.buffers[1].update(),
          this.indexBuffer.update();
      }
    };
    Cf.defaultOptions = { width: 100, height: 100, verticesX: 10, verticesY: 10 };
    let kf = Cf;
    const Rf = class Bf extends oA {
      constructor(e) {
        const { width: t, points: A, textureScale: r } = { ...Bf.defaultOptions, ...e };
        super({
          positions: new Float32Array(A.length * 4),
          uvs: new Float32Array(A.length * 4),
          indices: new Uint32Array((A.length - 1) * 6),
        }),
          (this.points = A),
          (this._width = t),
          (this.textureScale = r),
          this._build();
      }
      get width() {
        return this._width;
      }
      _build() {
        const e = this.points;
        if (!e) return;
        const t = this.getBuffer('aPosition'),
          A = this.getBuffer('aUV'),
          r = this.getIndex();
        if (e.length < 1) return;
        t.data.length / 4 !== e.length &&
          ((t.data = new Float32Array(e.length * 4)),
            (A.data = new Float32Array(e.length * 4)),
            (r.data = new Uint16Array((e.length - 1) * 6)));
        const s = A.data,
          n = r.data;
        (s[0] = 0), (s[1] = 0), (s[2] = 0), (s[3] = 1);
        let a = 0,
          l = e[0];
        const h = this._width * this.textureScale,
          u = e.length;
        for (let c = 0; c < u; c++) {
          const d = c * 4;
          if (this.textureScale > 0) {
            const f = l.x - e[c].x,
              g = l.y - e[c].y,
              p = Math.sqrt(f * f + g * g);
            (l = e[c]), (a += p / h);
          } else a = c / (u - 1);
          (s[d] = a), (s[d + 1] = 0), (s[d + 2] = a), (s[d + 3] = 1);
        }
        let o = 0;
        for (let c = 0; c < u - 1; c++) {
          const d = c * 2;
          (n[o++] = d), (n[o++] = d + 1), (n[o++] = d + 2), (n[o++] = d + 2), (n[o++] = d + 1), (n[o++] = d + 3);
        }
        A.update(), r.update(), this.updateVertices();
      }
      updateVertices() {
        const e = this.points;
        if (e.length < 1) return;
        let t = e[0],
          A,
          r = 0,
          s = 0;
        const n = this.buffers[0].data,
          a = e.length,
          l = this.textureScale > 0 ? (this.textureScale * this._width) / 2 : this._width / 2;
        for (let h = 0; h < a; h++) {
          const u = e[h],
            o = h * 4;
          h < e.length - 1 ? (A = e[h + 1]) : (A = u), (s = -(A.x - t.x)), (r = A.y - t.y);
          const c = Math.sqrt(r * r + s * s);
          c < 1e-6 ? ((r = 0), (s = 0)) : ((r /= c), (s /= c), (r *= l), (s *= l)),
            (n[o] = u.x + r),
            (n[o + 1] = u.y + s),
            (n[o + 2] = u.x - r),
            (n[o + 3] = u.y - s),
            (t = u);
        }
        this.buffers[0].update();
      }
      update() {
        this.textureScale > 0 ? this._build() : this.updateVertices();
      }
    };
    Rf.defaultOptions = { width: 200, points: [], textureScale: 0 };
    let Nf = Rf;
    const Qf = class wf extends $u {
      constructor(e) {
        const { texture: t, points: A, textureScale: r, ...s } = { ...wf.defaultOptions, ...e },
          n = new Nf(wA({ width: t.height, points: A, textureScale: r }));
        r > 0 && (t.source.style.addressMode = 'repeat'),
          super(wA({ ...s, texture: t, geometry: n })),
          (this.autoUpdate = !0),
          (this.onRender = this._render);
      }
      _render() {
        const e = this.geometry;
        (this.autoUpdate || e._width !== this.texture.height) && ((e._width = this.texture.height), e.update());
      }
    };
    Qf.defaultOptions = { textureScale: 0 };
    let Pf = Qf;
    class pr {
      constructor() {
        (this.batcherName = 'default'),
          (this.packAsQuad = !1),
          (this.indexOffset = 0),
          (this.attributeOffset = 0),
          (this.roundPixels = 0),
          (this._batcher = null),
          (this._batch = null),
          (this._textureMatrixUpdateId = -1),
          (this._uvUpdateId = -1);
      }
      get blendMode() {
        return this.renderable.groupBlendMode;
      }
      get topology() {
        return this._topology || this.geometry.topology;
      }
      set topology(e) {
        this._topology = e;
      }
      reset() {
        (this.renderable = null),
          (this.texture = null),
          (this._batcher = null),
          (this._batch = null),
          (this.geometry = null),
          (this._uvUpdateId = -1),
          (this._textureMatrixUpdateId = -1);
      }
      setTexture(e) {
        this.texture !== e && ((this.texture = e), (this._textureMatrixUpdateId = -1));
      }
      get uvs() {
        const t = this.geometry.getBuffer('aUV'),
          A = t.data;
        let r = A;
        const s = this.texture.textureMatrix;
        return (
          s.isSimple ||
          ((r = this._transformedUvs),
            (this._textureMatrixUpdateId !== s._updateID || this._uvUpdateId !== t._updateID) &&
            ((!r || r.length < A.length) && (r = this._transformedUvs = new Float32Array(A.length)),
              (this._textureMatrixUpdateId = s._updateID),
              (this._uvUpdateId = t._updateID),
              s.multiplyUvs(A, r))),
          r
        );
      }
      get positions() {
        return this.geometry.positions;
      }
      get indices() {
        return this.geometry.indices;
      }
      get color() {
        return this.renderable.groupColorAlpha;
      }
      get groupTransform() {
        return this.renderable.groupTransform;
      }
      get attributeSize() {
        return this.geometry.positions.length / 2;
      }
      get indexSize() {
        return this.geometry.indices.length;
      }
    }
    class Ks {
      destroy() { }
    }
    class eo {
      constructor(e, t) {
        (this.localUniforms = new qe({
          uTransformMatrix: { value: new R(), type: 'mat3x3<f32>' },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },
          uRound: { value: 0, type: 'f32' },
        })),
          (this.localUniformsBindGroup = new Le({ 0: this.localUniforms })),
          (this.renderer = e),
          (this._adaptor = t),
          this._adaptor.init();
      }
      validateRenderable(e) {
        const t = this._getMeshData(e),
          A = t.batched,
          r = e.batched;
        if (((t.batched = r), A !== r)) return !0;
        if (r) {
          const s = e._geometry;
          if (s.indices.length !== t.indexSize || s.positions.length !== t.vertexSize)
            return (t.indexSize = s.indices.length), (t.vertexSize = s.positions.length), !0;
          const n = this._getBatchableMesh(e);
          return (
            n.texture.uid !== e._texture.uid && (n._textureMatrixUpdateId = -1),
            !n._batcher.checkAndUpdateTexture(n, e._texture)
          );
        }
        return !1;
      }
      addRenderable(e, t) {
        const A = this.renderer.renderPipes.batch,
          r = this._getMeshData(e);
        if (
          (e.didViewUpdate && ((r.indexSize = e._geometry.indices?.length), (r.vertexSize = e._geometry.positions?.length)),
            r.batched)
        ) {
          const s = this._getBatchableMesh(e);
          s.setTexture(e._texture), (s.geometry = e._geometry), A.addToBatch(s, t);
        } else A.break(t), t.add(e);
      }
      updateRenderable(e) {
        if (e.batched) {
          const t = this._getBatchableMesh(e);
          t.setTexture(e._texture), (t.geometry = e._geometry), t._batcher.updateElement(t);
        }
      }
      execute(e) {
        if (!e.isRenderable) return;
        e.state.blendMode = eA(e.groupBlendMode, e.texture._source);
        const t = this.localUniforms;
        (t.uniforms.uTransformMatrix = e.groupTransform),
          (t.uniforms.uRound = this.renderer._roundPixels | e._roundPixels),
          t.update(),
          lA(e.groupColorAlpha, t.uniforms.uColor, 0),
          this._adaptor.execute(this, e);
      }
      _getMeshData(e) {
        var t, A;
        return (
          (t = e._gpuData)[(A = this.renderer.uid)] || (t[A] = new Ks()),
          e._gpuData[this.renderer.uid].meshData || this._initMeshData(e)
        );
      }
      _initMeshData(e) {
        return (
          (e._gpuData[this.renderer.uid].meshData = { batched: e.batched, indexSize: 0, vertexSize: 0 }),
          e._gpuData[this.renderer.uid].meshData
        );
      }
      _getBatchableMesh(e) {
        var t, A;
        return (
          (t = e._gpuData)[(A = this.renderer.uid)] || (t[A] = new Ks()),
          e._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(e)
        );
      }
      _initBatchableMesh(e) {
        const t = new pr();
        return (
          (t.renderable = e),
          t.setTexture(e._texture),
          (t.transform = e.groupTransform),
          (t.roundPixels = this.renderer._roundPixels | e._roundPixels),
          (e._gpuData[this.renderer.uid].batchableMesh = t),
          t
        );
      }
      destroy() {
        (this.localUniforms = null),
          (this.localUniformsBindGroup = null),
          this._adaptor.destroy(),
          (this._adaptor = null),
          (this.renderer = null);
      }
    }
    eo.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'mesh' };
    class Jf {
      execute(e, t) {
        const A = e.state,
          r = e.renderer,
          s = t.shader || e.defaultShader;
        (s.resources.uTexture = t.texture._source), (s.resources.uniforms = e.localUniforms);
        const n = r.gl,
          a = e.getBuffers(t);
        r.shader.bind(s), r.state.set(A), r.geometry.bind(a.geometry, s.glProgram);
        const h = a.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
        n.drawElements(n.TRIANGLES, t.particleChildren.length * 6, h, 0);
      }
    }
    class Gf {
      execute(e, t) {
        const A = e.renderer,
          r = t.shader || e.defaultShader;
        (r.groups[0] = A.renderPipes.uniformBatch.getUniformBindGroup(e.localUniforms, !0)),
          (r.groups[1] = A.texture.getTextureBindGroup(t.texture));
        const s = e.state,
          n = e.getBuffers(t);
        A.encoder.draw({
          geometry: n.geometry,
          shader: t.shader || e.defaultShader,
          state: s,
          size: t.particleChildren.length * 6,
        });
      }
    }
    function Fs(i, e = null) {
      const t = i * 6;
      if ((t > 65535 ? e || (e = new Uint32Array(t)) : e || (e = new Uint16Array(t)), e.length !== t))
        throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${t}`);
      for (let A = 0, r = 0; A < t; A += 6, r += 4)
        (e[A + 0] = r + 0), (e[A + 1] = r + 1), (e[A + 2] = r + 2), (e[A + 3] = r + 0), (e[A + 4] = r + 2), (e[A + 5] = r + 3);
      return e;
    }
    function Wf(i) {
      return { dynamicUpdate: Ql(i, !0), staticUpdate: Ql(i, !1) };
    }
    function Ql(i, e) {
      const t = [];
      t.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
      let A = 0;
      for (const s in i) {
        const n = i[s];
        if (e !== n.dynamic) continue;
        t.push(`offset = index + ${A}`), t.push(n.code);
        const a = et(n.format);
        A += a.stride / 4;
      }
      t.push(`
            index += stride * 4;
        }
    `),
        t.unshift(`
        var stride = ${A};
    `);
      const r = t.join(`
`);
      return new Function('ps', 'f32v', 'u32v', r);
    }
    class Kf {
      constructor(e) {
        (this._size = 0), (this._generateParticleUpdateCache = {});
        const t = (this._size = e.size ?? 1e3),
          A = e.properties;
        let r = 0,
          s = 0;
        for (const u in A) {
          const o = A[u],
            c = et(o.format);
          o.dynamic ? (s += c.stride) : (r += c.stride);
        }
        (this._dynamicStride = s / 4),
          (this._staticStride = r / 4),
          (this.staticAttributeBuffer = new bt(t * 4 * r)),
          (this.dynamicAttributeBuffer = new bt(t * 4 * s)),
          (this.indexBuffer = Fs(t));
        const n = new Bt();
        let a = 0,
          l = 0;
        (this._staticBuffer = new be({
          data: new Float32Array(1),
          label: 'static-particle-buffer',
          shrinkToFit: !1,
          usage: K.VERTEX | K.COPY_DST,
        })),
          (this._dynamicBuffer = new be({
            data: new Float32Array(1),
            label: 'dynamic-particle-buffer',
            shrinkToFit: !1,
            usage: K.VERTEX | K.COPY_DST,
          }));
        for (const u in A) {
          const o = A[u],
            c = et(o.format);
          o.dynamic
            ? (n.addAttribute(o.attributeName, {
              buffer: this._dynamicBuffer,
              stride: this._dynamicStride * 4,
              offset: a * 4,
              format: o.format,
            }),
              (a += c.size))
            : (n.addAttribute(o.attributeName, {
              buffer: this._staticBuffer,
              stride: this._staticStride * 4,
              offset: l * 4,
              format: o.format,
            }),
              (l += c.size));
        }
        n.addIndex(this.indexBuffer);
        const h = this.getParticleUpdate(A);
        (this._dynamicUpload = h.dynamicUpdate), (this._staticUpload = h.staticUpdate), (this.geometry = n);
      }
      getParticleUpdate(e) {
        const t = GS(e);
        return this._generateParticleUpdateCache[t]
          ? this._generateParticleUpdateCache[t]
          : ((this._generateParticleUpdateCache[t] = this.generateParticleUpdate(e)), this._generateParticleUpdateCache[t]);
      }
      generateParticleUpdate(e) {
        return Wf(e);
      }
      update(e, t) {
        e.length > this._size &&
          ((t = !0),
            (this._size = Math.max(e.length, (this._size * 1.5) | 0)),
            (this.staticAttributeBuffer = new bt(this._size * this._staticStride * 4 * 4)),
            (this.dynamicAttributeBuffer = new bt(this._size * this._dynamicStride * 4 * 4)),
            (this.indexBuffer = Fs(this._size)),
            this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, !0));
        const A = this.dynamicAttributeBuffer;
        if (
          (this._dynamicUpload(e, A.float32View, A.uint32View),
            this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, e.length * this._dynamicStride * 4, !0),
            t)
        ) {
          const r = this.staticAttributeBuffer;
          this._staticUpload(e, r.float32View, r.uint32View),
            this._staticBuffer.setDataWithSize(r.float32View, e.length * this._staticStride * 4, !0);
        }
      }
      destroy() {
        this._staticBuffer.destroy(), this._dynamicBuffer.destroy(), this.geometry.destroy();
      }
    }
    function GS(i) {
      const e = [];
      for (const t in i) {
        const A = i[t];
        e.push(t, A.code, A.dynamic ? 'd' : 's');
      }
      return e.join('_');
    }
    var Ff = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`,
      Yf = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`,
      Ys = `
struct ParticleUniforms {
  uTranslationMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uRound:f32,
  uResolution:vec2<f32>,
};

fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
{
  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

   if(uniforms.uRound == 1.0) {
       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);
   }

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;
    class Df extends ke {
      constructor() {
        const e = dt.from({ vertex: Yf, fragment: Ff }),
          t = it.from({
            fragment: { source: Ys, entryPoint: 'mainFragment' },
            vertex: { source: Ys, entryPoint: 'mainVertex' },
          });
        super({
          glProgram: e,
          gpuProgram: t,
          resources: {
            uTexture: v.WHITE.source,
            uSampler: new Je({}),
            uniforms: {
              uTranslationMatrix: { value: new R(), type: 'mat3x3<f32>' },
              uColor: { value: new $(16777215), type: 'vec4<f32>' },
              uRound: { value: 1, type: 'f32' },
              uResolution: { value: [0, 0], type: 'vec2<f32>' },
            },
          },
        });
      }
    }
    class to {
      constructor(e, t) {
        (this.state = Ue.for2d()),
          (this.localUniforms = new qe({
            uTranslationMatrix: { value: new R(), type: 'mat3x3<f32>' },
            uColor: { value: new Float32Array(4), type: 'vec4<f32>' },
            uRound: { value: 1, type: 'f32' },
            uResolution: { value: [0, 0], type: 'vec2<f32>' },
          })),
          (this.renderer = e),
          (this.adaptor = t),
          (this.defaultShader = new Df()),
          (this.state = Ue.for2d());
      }
      validateRenderable(e) {
        return !1;
      }
      addRenderable(e, t) {
        this.renderer.renderPipes.batch.break(t), t.add(e);
      }
      getBuffers(e) {
        return e._gpuData[this.renderer.uid] || this._initBuffer(e);
      }
      _initBuffer(e) {
        return (
          (e._gpuData[this.renderer.uid] = new Kf({ size: e.particleChildren.length, properties: e._properties })),
          e._gpuData[this.renderer.uid]
        );
      }
      updateRenderable(e) { }
      execute(e) {
        const t = e.particleChildren;
        if (t.length === 0) return;
        const A = this.renderer,
          r = this.getBuffers(e);
        e.texture || (e.texture = t[0].texture);
        const s = this.state;
        r.update(t, e._childrenDirty), (e._childrenDirty = !1), (s.blendMode = eA(e.blendMode, e.texture._source));
        const n = this.localUniforms.uniforms,
          a = n.uTranslationMatrix;
        e.worldTransform.copyTo(a),
          a.prepend(A.globalUniforms.globalUniformData.projectionMatrix),
          (n.uResolution = A.globalUniforms.globalUniformData.resolution),
          (n.uRound = A._roundPixels | e._roundPixels),
          lA(e.groupColorAlpha, n.uColor, 0),
          this.adaptor.execute(this, e);
      }
      destroy() {
        (this.renderer = null), this.defaultShader && (this.defaultShader.destroy(), (this.defaultShader = null));
      }
    }
    class Ao extends to {
      constructor(e) {
        super(e, new Jf());
      }
    }
    Ao.extension = { type: [M.WebGLPipes], name: 'particle' };
    class io extends to {
      constructor(e) {
        super(e, new Gf());
      }
    }
    io.extension = { type: [M.WebGPUPipes], name: 'particle' };
    const Of = class Lf extends kf {
      constructor(e = {}) {
        (e = { ...Lf.defaultOptions, ...e }),
          super({ width: e.width, height: e.height, verticesX: 4, verticesY: 4 }),
          this.update(e);
      }
      update(e) {
        (this.width = e.width ?? this.width),
          (this.height = e.height ?? this.height),
          (this._originalWidth = e.originalWidth ?? this._originalWidth),
          (this._originalHeight = e.originalHeight ?? this._originalHeight),
          (this._leftWidth = e.leftWidth ?? this._leftWidth),
          (this._rightWidth = e.rightWidth ?? this._rightWidth),
          (this._topHeight = e.topHeight ?? this._topHeight),
          (this._bottomHeight = e.bottomHeight ?? this._bottomHeight),
          (this._anchorX = e.anchor?.x),
          (this._anchorY = e.anchor?.y),
          this.updateUvs(),
          this.updatePositions();
      }
      updatePositions() {
        const e = this.positions,
          {
            width: t,
            height: A,
            _leftWidth: r,
            _rightWidth: s,
            _topHeight: n,
            _bottomHeight: a,
            _anchorX: l,
            _anchorY: h,
          } = this,
          u = r + s,
          o = t > u ? 1 : t / u,
          c = n + a,
          d = A > c ? 1 : A / c,
          f = Math.min(o, d),
          g = l * t,
          p = h * A;
        (e[0] = e[8] = e[16] = e[24] = -g),
          (e[2] = e[10] = e[18] = e[26] = r * f - g),
          (e[4] = e[12] = e[20] = e[28] = t - s * f - g),
          (e[6] = e[14] = e[22] = e[30] = t - g),
          (e[1] = e[3] = e[5] = e[7] = -p),
          (e[9] = e[11] = e[13] = e[15] = n * f - p),
          (e[17] = e[19] = e[21] = e[23] = A - a * f - p),
          (e[25] = e[27] = e[29] = e[31] = A - p),
          this.getBuffer('aPosition').update();
      }
      updateUvs() {
        const e = this.uvs;
        (e[0] = e[8] = e[16] = e[24] = 0),
          (e[1] = e[3] = e[5] = e[7] = 0),
          (e[6] = e[14] = e[22] = e[30] = 1),
          (e[25] = e[27] = e[29] = e[31] = 1);
        const t = 1 / this._originalWidth,
          A = 1 / this._originalHeight;
        (e[2] = e[10] = e[18] = e[26] = t * this._leftWidth),
          (e[9] = e[11] = e[13] = e[15] = A * this._topHeight),
          (e[4] = e[12] = e[20] = e[28] = 1 - t * this._rightWidth),
          (e[17] = e[19] = e[21] = e[23] = 1 - A * this._bottomHeight),
          this.getBuffer('aUV').update();
      }
    };
    Of.defaultOptions = {
      width: 100,
      height: 100,
      leftWidth: 10,
      topHeight: 10,
      rightWidth: 10,
      bottomHeight: 10,
      originalWidth: 100,
      originalHeight: 100,
    };
    let jf = Of;
    class Zf extends pr {
      constructor() {
        super(), (this.geometry = new jf());
      }
      destroy() {
        this.geometry.destroy();
      }
    }
    class ro {
      constructor(e) {
        this._renderer = e;
      }
      addRenderable(e, t) {
        const A = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, A), this._renderer.renderPipes.batch.addToBatch(A, t);
      }
      updateRenderable(e) {
        const t = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, t), t._batcher.updateElement(t);
      }
      validateRenderable(e) {
        const t = this._getGpuSprite(e);
        return !t._batcher.checkAndUpdateTexture(t, e._texture);
      }
      _updateBatchableSprite(e, t) {
        t.geometry.update(e), t.setTexture(e._texture);
      }
      _getGpuSprite(e) {
        return e._gpuData[this._renderer.uid] || this._initGPUSprite(e);
      }
      _initGPUSprite(e) {
        const t = (e._gpuData[this._renderer.uid] = new Zf()),
          A = t;
        return (
          (A.renderable = e),
          (A.transform = e.groupTransform),
          (A.texture = e._texture),
          (A.roundPixels = this._renderer._roundPixels | e._roundPixels),
          e.didViewUpdate || this._updateBatchableSprite(e, A),
          t
        );
      }
      destroy() {
        this._renderer = null;
      }
    }
    ro.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'nineSliceSprite' };
    const Xf = {
      name: 'tiling-bit',
      vertex: {
        header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
        main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `,
      },
      fragment: {
        header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
        main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `,
      },
    },
      Hf = {
        name: 'tiling-bit',
        vertex: {
          header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,
          main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `,
        },
        fragment: {
          header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
          main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `,
        },
      };
    let Hr, zr;
    class zf extends ke {
      constructor() {
        Hr ?? (Hr = rA({ name: 'tiling-sprite-shader', bits: [Ht, Xf, nA] })),
          zr ?? (zr = sA({ name: 'tiling-sprite-shader', bits: [hr, Hf, aA] }));
        const e = new qe({
          uMapCoord: { value: new R(), type: 'mat3x3<f32>' },
          uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },
          uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },
          uTextureTransform: { value: new R(), type: 'mat3x3<f32>' },
          uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },
        });
        super({
          glProgram: zr,
          gpuProgram: Hr,
          resources: {
            localUniforms: new qe({
              uTransformMatrix: { value: new R(), type: 'mat3x3<f32>' },
              uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },
              uRound: { value: 0, type: 'f32' },
            }),
            tilingUniforms: e,
            uTexture: v.EMPTY.source,
            uSampler: v.EMPTY.source.style,
          },
        });
      }
      updateUniforms(e, t, A, r, s, n) {
        const a = this.resources.tilingUniforms,
          l = n.width,
          h = n.height,
          u = n.textureMatrix,
          o = a.uniforms.uTextureTransform;
        o.set((A.a * l) / e, (A.b * l) / t, (A.c * h) / e, (A.d * h) / t, A.tx / e, A.ty / t),
          o.invert(),
          (a.uniforms.uMapCoord = u.mapCoord),
          (a.uniforms.uClampFrame = u.uClampFrame),
          (a.uniforms.uClampOffset = u.uClampOffset),
          (a.uniforms.uTextureTransform = o),
          (a.uniforms.uSizeAnchor[0] = e),
          (a.uniforms.uSizeAnchor[1] = t),
          (a.uniforms.uSizeAnchor[2] = r),
          (a.uniforms.uSizeAnchor[3] = s),
          n && ((this.resources.uTexture = n.source), (this.resources.uSampler = n.source.style));
      }
    }
    class _f extends oA {
      constructor() {
        super({
          positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          indices: new Uint32Array([0, 1, 2, 0, 2, 3]),
        });
      }
    }
    function $f(i, e) {
      const t = i.anchor.x,
        A = i.anchor.y;
      (e[0] = -t * i.width),
        (e[1] = -A * i.height),
        (e[2] = (1 - t) * i.width),
        (e[3] = -A * i.height),
        (e[4] = (1 - t) * i.width),
        (e[5] = (1 - A) * i.height),
        (e[6] = -t * i.width),
        (e[7] = (1 - A) * i.height);
    }
    function ep(i, e, t, A) {
      let r = 0;
      const s = i.length / e,
        n = A.a,
        a = A.b,
        l = A.c,
        h = A.d,
        u = A.tx,
        o = A.ty;
      for (t *= e; r < s;) {
        const c = i[t],
          d = i[t + 1];
        (i[t] = n * c + l * d + u), (i[t + 1] = a * c + h * d + o), (t += e), r++;
      }
    }
    function tp(i, e) {
      const t = i.texture,
        A = t.frame.width,
        r = t.frame.height;
      let s = 0,
        n = 0;
      i.applyAnchorToTexture && ((s = i.anchor.x), (n = i.anchor.y)),
        (e[0] = e[6] = -s),
        (e[2] = e[4] = 1 - s),
        (e[1] = e[3] = -n),
        (e[5] = e[7] = 1 - n);
      const a = R.shared;
      a.copyFrom(i._tileTransform.matrix),
        (a.tx /= i.width),
        (a.ty /= i.height),
        a.invert(),
        a.scale(i.width / A, i.height / r),
        ep(e, 2, 0, a);
    }
    const Ui = new _f();
    class Ap {
      constructor() {
        (this.canBatch = !0),
          (this.geometry = new oA({ indices: Ui.indices.slice(), positions: Ui.positions.slice(), uvs: Ui.uvs.slice() }));
      }
      destroy() {
        this.geometry.destroy(), this.shader?.destroy();
      }
    }
    class so {
      constructor(e) {
        (this._state = Ue.default2d), (this._renderer = e);
      }
      validateRenderable(e) {
        const t = this._getTilingSpriteData(e),
          A = t.canBatch;
        this._updateCanBatch(e);
        const r = t.canBatch;
        if (r && r === A) {
          const { batchableMesh: s } = t;
          return !s._batcher.checkAndUpdateTexture(s, e.texture);
        }
        return A !== r;
      }
      addRenderable(e, t) {
        const A = this._renderer.renderPipes.batch;
        this._updateCanBatch(e);
        const r = this._getTilingSpriteData(e),
          { geometry: s, canBatch: n } = r;
        if (n) {
          r.batchableMesh || (r.batchableMesh = new pr());
          const a = r.batchableMesh;
          e.didViewUpdate &&
            (this._updateBatchableMesh(e),
              (a.geometry = s),
              (a.renderable = e),
              (a.transform = e.groupTransform),
              a.setTexture(e._texture)),
            (a.roundPixels = this._renderer._roundPixels | e._roundPixels),
            A.addToBatch(a, t);
        } else A.break(t), r.shader || (r.shader = new zf()), this.updateRenderable(e), t.add(e);
      }
      execute(e) {
        const { shader: t } = this._getTilingSpriteData(e);
        t.groups[0] = this._renderer.globalUniforms.bindGroup;
        const A = t.resources.localUniforms.uniforms;
        (A.uTransformMatrix = e.groupTransform),
          (A.uRound = this._renderer._roundPixels | e._roundPixels),
          lA(e.groupColorAlpha, A.uColor, 0),
          (this._state.blendMode = eA(e.groupBlendMode, e.texture._source)),
          this._renderer.encoder.draw({ geometry: Ui, shader: t, state: this._state });
      }
      updateRenderable(e) {
        const t = this._getTilingSpriteData(e),
          { canBatch: A } = t;
        if (A) {
          const { batchableMesh: r } = t;
          e.didViewUpdate && this._updateBatchableMesh(e), r._batcher.updateElement(r);
        } else if (e.didViewUpdate) {
          const { shader: r } = t;
          r.updateUniforms(e.width, e.height, e._tileTransform.matrix, e.anchor.x, e.anchor.y, e.texture);
        }
      }
      _getTilingSpriteData(e) {
        return e._gpuData[this._renderer.uid] || this._initTilingSpriteData(e);
      }
      _initTilingSpriteData(e) {
        const t = new Ap();
        return (t.renderable = e), (e._gpuData[this._renderer.uid] = t), t;
      }
      _updateBatchableMesh(e) {
        const t = this._getTilingSpriteData(e),
          { geometry: A } = t,
          r = e.texture.source.style;
        r.addressMode !== 'repeat' && ((r.addressMode = 'repeat'), r.update()), tp(e, A.uvs), $f(e, A.positions);
      }
      destroy() {
        this._renderer = null;
      }
      _updateCanBatch(e) {
        const t = this._getTilingSpriteData(e),
          A = e.texture;
        let r = !0;
        return (
          this._renderer.type === we.WEBGL && (r = this._renderer.context.supports.nonPowOf2wrapping),
          (t.canBatch = A.textureMatrix.isSimple && (r || A.source.isPowerOfTwo)),
          t.canBatch
        );
      }
    }
    so.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'tilingSprite' };
    const ip = {
      name: 'local-uniform-msdf-bit',
      vertex: {
        header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
        main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
        end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `,
      },
      fragment: {
        header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
        main: `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `,
      },
    },
      rp = {
        name: 'local-uniform-msdf-bit',
        vertex: {
          header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
          main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
          end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `,
        },
        fragment: {
          header: `
            uniform float uDistance;
         `,
          main: `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `,
        },
      },
      sp = {
        name: 'msdf-bit',
        fragment: {
          header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `,
        },
      },
      np = {
        name: 'msdf-bit',
        fragment: {
          header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `,
        },
      };
    let _r, $r;
    class ap extends ke {
      constructor(e) {
        const t = new qe({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },
          uTransformMatrix: { value: new R(), type: 'mat3x3<f32>' },
          uDistance: { value: 4, type: 'f32' },
          uRound: { value: 0, type: 'f32' },
        });
        _r ?? (_r = rA({ name: 'sdf-shader', bits: [er, Ar(e), ip, sp, nA] })),
          $r ?? ($r = sA({ name: 'sdf-shader', bits: [tr, ir(e), rp, np, aA] })),
          super({ glProgram: $r, gpuProgram: _r, resources: { localUniforms: t, batchSamplers: rr(e) } });
      }
    }
    class op extends Ut {
      destroy() {
        this.context.customShader && this.context.customShader.destroy(), super.destroy();
      }
    }
    class no {
      constructor(e) {
        this._renderer = e;
      }
      validateRenderable(e) {
        const t = this._getGpuBitmapText(e);
        return this._renderer.renderPipes.graphics.validateRenderable(t);
      }
      addRenderable(e, t) {
        const A = this._getGpuBitmapText(e);
        wl(e, A),
          e._didTextUpdate && ((e._didTextUpdate = !1), this._updateContext(e, A)),
          this._renderer.renderPipes.graphics.addRenderable(A, t),
          A.context.customShader && this._updateDistanceField(e);
      }
      updateRenderable(e) {
        const t = this._getGpuBitmapText(e);
        wl(e, t),
          this._renderer.renderPipes.graphics.updateRenderable(t),
          t.context.customShader && this._updateDistanceField(e);
      }
      _updateContext(e, t) {
        const { context: A } = t,
          r = Pi.getFont(e.text, e._style);
        A.clear(),
          r.distanceField.type !== 'none' &&
          (A.customShader || (A.customShader = new ap(this._renderer.limits.maxBatchableTextures)));
        const s = Ne.graphemeSegmenter(e.text),
          n = e._style;
        let a = r.baseLineOffset;
        const l = Cn(s, n, r, !0),
          h = n.padding,
          u = l.scale;
        let o = l.width,
          c = l.height + l.offsetY;
        n._stroke && ((o += n._stroke.width / u), (c += n._stroke.width / u)),
          A.translate(-e._anchor._x * o - h, -e._anchor._y * c - h).scale(u, u);
        const d = r.applyFillAsTint ? n._fill.color : 16777215;
        let f = r.fontMetrics.fontSize,
          g = r.lineHeight;
        n.lineHeight && ((f = n.fontSize / u), (g = n.lineHeight / u));
        let p = (g - f) / 2;
        p - r.baseLineOffset < 0 && (p = 0);
        for (let m = 0; m < l.lines.length; m++) {
          const S = l.lines[m];
          for (let q = 0; q < S.charPositions.length; q++) {
            const E = S.chars[q],
              b = r.chars[E];
            if (b?.texture) {
              const T = b.texture;
              A.texture(
                T,
                d || 'black',
                Math.round(S.charPositions[q] + b.xOffset),
                Math.round(a + b.yOffset + p),
                T.orig.width,
                T.orig.height
              );
            }
          }
          a += g;
        }
      }
      _getGpuBitmapText(e) {
        return e._gpuData[this._renderer.uid] || this.initGpuText(e);
      }
      initGpuText(e) {
        const t = new op();
        return (e._gpuData[this._renderer.uid] = t), this._updateContext(e, t), t;
      }
      _updateDistanceField(e) {
        const t = this._getGpuBitmapText(e).context,
          A = e._style.fontFamily,
          r = Z.get(`${A}-bitmap`),
          { a: s, b: n, c: a, d: l } = e.groupTransform,
          h = Math.sqrt(s * s + n * n),
          u = Math.sqrt(a * a + l * l),
          o = (Math.abs(h) + Math.abs(u)) / 2,
          c = r.baseRenderedFontSize / e._style.fontSize,
          d = o * r.distanceField.range * (1 / c);
        t.customShader.resources.localUniforms.uniforms.uDistance = d;
      }
      destroy() {
        this._renderer = null;
      }
    }
    no.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'bitmapText' };
    function wl(i, e) {
      (e.groupTransform = i.groupTransform),
        (e.groupColorAlpha = i.groupColorAlpha),
        (e.groupColor = i.groupColor),
        (e.groupBlendMode = i.groupBlendMode),
        (e.globalDisplayStatus = i.globalDisplayStatus),
        (e.groupTransform = i.groupTransform),
        (e.localDisplayStatus = i.localDisplayStatus),
        (e.groupAlpha = i.groupAlpha),
        (e._roundPixels = i._roundPixels);
    }
    class lp extends ti {
      constructor(e) {
        super(),
          (this.generatingTexture = !1),
          (this.currentKey = '--'),
          (this._renderer = e),
          e.runners.resolutionChange.add(this);
      }
      resolutionChange() {
        const e = this.renderable;
        e._autoResolution && e.onViewUpdate();
      }
      destroy() {
        const { htmlText: e } = this._renderer;
        e.getReferenceCount(this.currentKey) === null
          ? e.returnTexturePromise(this.texturePromise)
          : e.decreaseReferenceCount(this.currentKey),
          this._renderer.runners.resolutionChange.remove(this),
          (this.texturePromise = null),
          (this._renderer = null);
      }
    }
    function Fi(i, e) {
      const { texture: t, bounds: A } = i,
        r = e._style._getFinalPadding();
      Ls(A, e._anchor, t);
      const s = e._anchor._x * r * 2,
        n = e._anchor._y * r * 2;
      (A.minX -= r - s), (A.minY -= r - n), (A.maxX -= r - s), (A.maxY -= r - n);
    }
    class ao {
      constructor(e) {
        this._renderer = e;
      }
      validateRenderable(e) {
        const t = this._getGpuText(e),
          A = e.styleKey;
        return t.currentKey !== A;
      }
      addRenderable(e, t) {
        const A = this._getGpuText(e);
        if (e._didTextUpdate) {
          const r = e._autoResolution ? this._renderer.resolution : e.resolution;
          (A.currentKey !== e.styleKey || e.resolution !== r) && this._updateGpuText(e).catch((s) => { }),
            (e._didTextUpdate = !1),
            Fi(A, e);
        }
        this._renderer.renderPipes.batch.addToBatch(A, t);
      }
      updateRenderable(e) {
        const t = this._getGpuText(e);
        t._batcher.updateElement(t);
      }
      async _updateGpuText(e) {
        e._didTextUpdate = !1;
        const t = this._getGpuText(e);
        if (t.generatingTexture) return;
        const A = t.texturePromise;
        (t.texturePromise = null),
          (t.generatingTexture = !0),
          (e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution);
        let r = this._renderer.htmlText.getTexturePromise(e);
        A &&
          (r = r.finally(() => {
            this._renderer.htmlText.decreaseReferenceCount(t.currentKey), this._renderer.htmlText.returnTexturePromise(A);
          })),
          (t.texturePromise = r),
          (t.currentKey = e.styleKey),
          (t.texture = await r);
        const s = e.renderGroup || e.parentRenderGroup;
        s && (s.structureDidChange = !0), (t.generatingTexture = !1), Fi(t, e);
      }
      _getGpuText(e) {
        return e._gpuData[this._renderer.uid] || this.initGpuText(e);
      }
      initGpuText(e) {
        const t = new lp(this._renderer);
        return (
          (t.renderable = e),
          (t.transform = e.groupTransform),
          (t.texture = v.EMPTY),
          (t.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
          (t.roundPixels = this._renderer._roundPixels | e._roundPixels),
          (e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution),
          (e._gpuData[this._renderer.uid] = t),
          t
        );
      }
      destroy() {
        this._renderer = null;
      }
    }
    ao.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'htmlText' };
    function hp() {
      const { userAgent: i } = J.get().getNavigator();
      return /^((?!chrome|android).)*safari/i.test(i);
    }
    const WS = new de();
    function oo(i, e, t, A) {
      const r = WS;
      (r.minX = 0), (r.minY = 0), (r.maxX = (i.width / A) | 0), (r.maxY = (i.height / A) | 0);
      const s = ce.getOptimalTexture(r.width, r.height, A, !1);
      return (
        (s.source.uploadMethodId = 'image'),
        (s.source.resource = i),
        (s.source.alphaMode = 'premultiply-alpha-on-upload'),
        (s.frame.width = e / A),
        (s.frame.height = t / A),
        s.source.emit('update', s.source),
        s.updateUvs(),
        s
      );
    }
    function cp(i, e) {
      const t = e.fontFamily,
        A = [],
        r = {},
        s = /font-family:([^;"\s]+)/g,
        n = i.match(s);
      function a(l) {
        r[l] || (A.push(l), (r[l] = !0));
      }
      if (Array.isArray(t)) for (let l = 0; l < t.length; l++) a(t[l]);
      else a(t);
      n &&
        n.forEach((l) => {
          const h = l.split(':')[1].trim();
          a(h);
        });
      for (const l in e.tagStyles) {
        const h = e.tagStyles[l].fontFamily;
        a(h);
      }
      return A;
    }
    async function up(i) {
      const t = await (await J.get().fetch(i)).blob(),
        A = new FileReader();
      return await new Promise((s, n) => {
        (A.onloadend = () => s(A.result)), (A.onerror = n), A.readAsDataURL(t);
      });
    }
    async function dp(i, e) {
      const t = await up(e);
      return `@font-face {
        font-family: "${i.fontFamily}";
        font-weight: ${i.fontWeight};
        font-style: ${i.fontStyle};
        src: url('${t}');
    }`;
    }
    const ki = new Map();
    async function fp(i) {
      const e = i
        .filter((t) => Z.has(`${t}-and-url`))
        .map((t) => {
          if (!ki.has(t)) {
            const { entries: A } = Z.get(`${t}-and-url`),
              r = [];
            A.forEach((s) => {
              const n = s.url,
                l = s.faces.map((h) => ({ weight: h.weight, style: h.style }));
              r.push(...l.map((h) => dp({ fontWeight: h.weight, fontStyle: h.style, fontFamily: t }, n)));
            }),
              ki.set(
                t,
                Promise.all(r).then((s) =>
                  s.join(`
`)
                )
              );
          }
          return ki.get(t);
        });
      return (await Promise.all(e)).join(`
`);
    }
    function pp(i, e, t, A, r) {
      const { domElement: s, styleElement: n, svgRoot: a } = r;
      (s.innerHTML = `<style>${e.cssStyle}</style><div style='padding:0;'>${i}</div>`),
        s.setAttribute('style', `transform: scale(${t});transform-origin: top left; display: inline-block`),
        (n.textContent = A);
      const { width: l, height: h } = r.image;
      return (
        a.setAttribute('width', l.toString()), a.setAttribute('height', h.toString()), new XMLSerializer().serializeToString(a)
      );
    }
    function gp(i, e) {
      const t = Xe.getOptimalCanvasAndContext(i.width, i.height, e),
        { context: A } = t;
      return A.clearRect(0, 0, i.width, i.height), A.drawImage(i, 0, 0), t;
    }
    function mp(i, e, t) {
      return new Promise(async (A) => {
        t && (await new Promise((r) => setTimeout(r, 100))),
          (i.onload = () => {
            A();
          }),
          (i.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`),
          (i.crossOrigin = 'anonymous');
      });
    }
    class lo {
      constructor(e) {
        (this._activeTextures = {}), (this._renderer = e), (this._createCanvas = e.type === we.WEBGPU);
      }
      getTexture(e) {
        return this.getTexturePromise(e);
      }
      getManagedTexture(e) {
        const t = e.styleKey;
        if (this._activeTextures[t]) return this._increaseReferenceCount(t), this._activeTextures[t].promise;
        const A = this._buildTexturePromise(e).then((r) => ((this._activeTextures[t].texture = r), r));
        return (this._activeTextures[t] = { texture: null, promise: A, usageCount: 1 }), A;
      }
      getReferenceCount(e) {
        return this._activeTextures[e]?.usageCount ?? null;
      }
      _increaseReferenceCount(e) {
        this._activeTextures[e].usageCount++;
      }
      decreaseReferenceCount(e) {
        const t = this._activeTextures[e];
        t &&
          (t.usageCount--,
            t.usageCount === 0 &&
            (t.texture
              ? this._cleanUp(t.texture)
              : t.promise
                .then((A) => {
                  (t.texture = A), this._cleanUp(t.texture);
                })
                .catch(() => {
                  N('HTMLTextSystem: Failed to clean texture');
                }),
              (this._activeTextures[e] = null)));
      }
      getTexturePromise(e) {
        return this._buildTexturePromise(e);
      }
      async _buildTexturePromise(e) {
        const { text: t, style: A, resolution: r, textureStyle: s } = e,
          n = se.get(Gn),
          a = cp(t, A),
          l = await fp(a),
          h = rd(t, A, l, n),
          u = Math.ceil(Math.ceil(Math.max(1, h.width) + A.padding * 2) * r),
          o = Math.ceil(Math.ceil(Math.max(1, h.height) + A.padding * 2) * r),
          c = n.image,
          d = 2;
        (c.width = (u | 0) + d), (c.height = (o | 0) + d);
        const f = pp(t, A, r, l, n);
        await mp(c, f, hp() && a.length > 0);
        const g = c;
        let p;
        this._createCanvas && (p = gp(c, r));
        const m = oo(p ? p.canvas : g, c.width - d, c.height - d, r);
        return (
          s && (m.source.style = s),
          this._createCanvas && (this._renderer.texture.initSource(m.source), Xe.returnCanvasAndContext(p)),
          se.return(n),
          m
        );
      }
      returnTexturePromise(e) {
        e.then((t) => {
          this._cleanUp(t);
        }).catch(() => {
          N('HTMLTextSystem: Failed to clean texture');
        });
      }
      _cleanUp(e) {
        ce.returnTexture(e, !0), (e.source.resource = null), (e.source.uploadMethodId = 'unknown');
      }
      destroy() {
        this._renderer = null;
        for (const e in this._activeTextures)
          this._activeTextures[e] && this.returnTexturePromise(this._activeTextures[e].promise);
        this._activeTextures = null;
      }
    }
    lo.extension = { type: [M.WebGLSystem, M.WebGPUSystem, M.CanvasSystem], name: 'htmlText' };
    class Sp extends ti {
      constructor(e) {
        super(), (this._renderer = e), e.runners.resolutionChange.add(this);
      }
      resolutionChange() {
        const e = this.renderable;
        e._autoResolution && e.onViewUpdate();
      }
      destroy() {
        const { canvasText: e } = this._renderer;
        e.getReferenceCount(this.currentKey) > 0
          ? e.decreaseReferenceCount(this.currentKey)
          : this.texture && e.returnTexture(this.texture),
          this._renderer.runners.resolutionChange.remove(this),
          (this._renderer = null);
      }
    }
    class ho {
      constructor(e) {
        this._renderer = e;
      }
      validateRenderable(e) {
        const t = this._getGpuText(e),
          A = e.styleKey;
        return t.currentKey !== A ? !0 : e._didTextUpdate;
      }
      addRenderable(e, t) {
        const A = this._getGpuText(e);
        if (e._didTextUpdate) {
          const r = e._autoResolution ? this._renderer.resolution : e.resolution;
          (A.currentKey !== e.styleKey || e.resolution !== r) && this._updateGpuText(e), (e._didTextUpdate = !1), Fi(A, e);
        }
        this._renderer.renderPipes.batch.addToBatch(A, t);
      }
      updateRenderable(e) {
        const t = this._getGpuText(e);
        t._batcher.updateElement(t);
      }
      _updateGpuText(e) {
        const t = this._getGpuText(e);
        t.texture && this._renderer.canvasText.decreaseReferenceCount(t.currentKey),
          (e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution),
          (t.texture = this._renderer.canvasText.getManagedTexture(e)),
          (t.currentKey = e.styleKey);
      }
      _getGpuText(e) {
        return e._gpuData[this._renderer.uid] || this.initGpuText(e);
      }
      initGpuText(e) {
        const t = new Sp(this._renderer);
        return (
          (t.currentKey = '--'),
          (t.renderable = e),
          (t.transform = e.groupTransform),
          (t.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
          (t.roundPixels = this._renderer._roundPixels | e._roundPixels),
          (e._gpuData[this._renderer.uid] = t),
          t
        );
      }
      destroy() {
        this._renderer = null;
      }
    }
    ho.extension = { type: [M.WebGLPipes, M.WebGPUPipes, M.CanvasPipes], name: 'text' };
    class co {
      constructor(e) {
        (this._activeTextures = {}), (this._renderer = e);
      }
      getTexture(e, t, A, r) {
        typeof e == 'string' &&
          (P('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments'),
            (e = { text: e, style: A, resolution: t })),
          e.style instanceof tt || (e.style = new tt(e.style)),
          e.textureStyle instanceof Je || (e.textureStyle = new Je(e.textureStyle)),
          typeof e.text != 'string' && (e.text = e.text.toString());
        const { text: s, style: n, textureStyle: a } = e,
          l = e.resolution ?? this._renderer.resolution,
          { frame: h, canvasAndContext: u } = Xt.getCanvasAndContext({ text: s, style: n, resolution: l }),
          o = oo(u.canvas, h.width, h.height, l);
        if (
          (a && (o.source.style = a),
            n.trim && (h.pad(n.padding), o.frame.copyFrom(h), o.frame.scale(1 / l), o.updateUvs()),
            n.filters)
        ) {
          const c = this._applyFilters(o, n.filters);
          return this.returnTexture(o), Xt.returnCanvasAndContext(u), c;
        }
        return this._renderer.texture.initSource(o._source), Xt.returnCanvasAndContext(u), o;
      }
      returnTexture(e) {
        const t = e.source;
        (t.resource = null), (t.uploadMethodId = 'unknown'), (t.alphaMode = 'no-premultiply-alpha'), ce.returnTexture(e, !0);
      }
      renderTextToCanvas() {
        P('8.10.0', 'CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead');
      }
      getManagedTexture(e) {
        e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution;
        const t = e.styleKey;
        if (this._activeTextures[t]) return this._increaseReferenceCount(t), this._activeTextures[t].texture;
        const A = this.getTexture({ text: e.text, style: e.style, resolution: e._resolution, textureStyle: e.textureStyle });
        return (this._activeTextures[t] = { texture: A, usageCount: 1 }), A;
      }
      decreaseReferenceCount(e) {
        const t = this._activeTextures[e];
        t.usageCount--, t.usageCount === 0 && (this.returnTexture(t.texture), (this._activeTextures[e] = null));
      }
      getReferenceCount(e) {
        return this._activeTextures[e]?.usageCount ?? 0;
      }
      _increaseReferenceCount(e) {
        this._activeTextures[e].usageCount++;
      }
      _applyFilters(e, t) {
        const A = this._renderer.renderTarget.renderTarget,
          r = this._renderer.filter.generateFilteredTexture({ texture: e, filters: t });
        return this._renderer.renderTarget.bind(A, !1), r;
      }
      destroy() {
        this._renderer = null;
        for (const e in this._activeTextures) this._activeTextures[e] && this.returnTexture(this._activeTextures[e].texture);
        this._activeTextures = null;
      }
    }
    co.extension = { type: [M.WebGLSystem, M.WebGPUSystem, M.CanvasSystem], name: 'canvasText' };
    Q.add(Yl, Dl);
    const KS = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          AbstractBitmapFont: gn,
          AbstractRenderer: zA,
          AbstractText: ed,
          AccessibilitySystem: Jh,
          AlphaMask: $s,
          AlphaMaskPipe: Dn,
          AnimatedSprite: AA,
          Application: dn,
          ApplicationInitHook: cn,
          Assets: te,
          AssetsClass: Ku,
          BLEND_TO_NPM: qc,
          BUFFER_TYPE: RA,
          BackgroundLoader: qu,
          BackgroundSystem: zd,
          Batch: Vc,
          BatchGeometry: xc,
          BatchTextureArray: Ec,
          BatchableGraphics: nr,
          BatchableHTMLText: lp,
          BatchableMesh: pr,
          BatchableSprite: ti,
          BatchableText: Sp,
          Batcher: bc,
          BatcherPipe: Yn,
          BigPool: se,
          BindGroup: Le,
          BindGroupSystem: wa,
          BitmapFont: Un,
          BitmapFontManager: Pi,
          BitmapTextGraphics: op,
          BitmapTextPipe: no,
          BlendModePipe: ya,
          Bounds: de,
          BrowserAdapter: Ih,
          Buffer: be,
          BufferImageSource: Di,
          BufferResource: cr,
          BufferUsage: K,
          CLEAR: Ve,
          Cache: Z,
          CanvasObserver: rn,
          CanvasPool: Xe,
          CanvasPoolClass: du,
          CanvasSource: Oe,
          CanvasTextGenerator: Xt,
          CanvasTextMetrics: Ne,
          CanvasTextPipe: ho,
          CanvasTextSystem: co,
          Circle: Hi,
          Color: $,
          ColorMask: en,
          ColorMaskPipe: On,
          Container: _,
          CustomRenderPipe: qa,
          DEG_TO_RAD: Zl,
          DOMAdapter: J,
          DOMPipe: Nn,
          DefaultBatcher: sr,
          DefaultShader: Ms,
          DynamicBitmapFont: vs,
          Ellipse: zi,
          EventBoundary: Fu,
          EventEmitter: ye,
          EventSystem: wn,
          EventsTicker: Fe,
          ExtensionType: M,
          ExtractSystem: $d,
          FederatedContainer: Yu,
          FederatedEvent: iA,
          FederatedMouseEvent: XA,
          FederatedPointerEvent: Re,
          FederatedWheelEvent: Ct,
          FillGradient: Ze,
          FillPattern: _A,
          Filter: on,
          FilterEffect: PA,
          FilterPipe: Pn,
          FilterSystem: Jn,
          FontStylePromiseCache: ki,
          GL_FORMATS: Ji,
          GL_TARGETS: Hn,
          GL_TYPES: Y,
          GenerateTextureSystem: va,
          Geometry: Bt,
          GlBackBufferSystem: fd,
          GlBatchAdaptor: Wn,
          GlBuffer: ld,
          GlBufferSystem: jn,
          GlColorMaskSystem: $n,
          GlContextSystem: cd,
          GlEncoderSystem: ea,
          GlGeometrySystem: zn,
          GlGraphicsAdaptor: ma,
          GlLimitsSystem: ta,
          GlMeshAdaptor: Sa,
          GlParticleContainerAdaptor: Jf,
          GlParticleContainerPipe: Ao,
          GlProgram: dt,
          GlProgramData: yd,
          GlRenderTarget: pd,
          GlRenderTargetAdaptor: Md,
          GlRenderTargetSystem: ha,
          GlShaderSystem: da,
          GlStateSystem: Jd,
          GlStencilSystem: Aa,
          GlTexture: Gd,
          GlTextureSystem: ga,
          GlUboSystem: aa,
          GlUniformGroupSystem: fa,
          GlobalResourceRegistry: kt,
          GlobalUniformSystem: Ca,
          GpuBatchAdaptor: Kn,
          GpuBlendModesToPixi: Ee,
          GpuBufferSystem: Pa,
          GpuColorMaskSystem: Ja,
          GpuDeviceSystem: fr,
          GpuEncoderSystem: Ga,
          GpuGraphicsAdaptor: za,
          GpuGraphicsContext: $c,
          GpuLimitsSystem: Wa,
          GpuMeshAdapter: _a,
          GpuMipmapGenerator: Tf,
          GpuParticleContainerAdaptor: Gf,
          GpuParticleContainerPipe: io,
          GpuProgram: it,
          GpuRenderTarget: Sf,
          GpuRenderTargetAdaptor: qf,
          GpuRenderTargetSystem: Oa,
          GpuShaderSystem: La,
          GpuStateSystem: ja,
          GpuStencilModesToPixi: rt,
          GpuStencilSystem: Ka,
          GpuTextureSystem: Ha,
          GpuUboSystem: Fa,
          GpuUniformBatchPipe: Ya,
          Graphics: Ut,
          GraphicsContext: Ce,
          GraphicsContextRenderData: eu,
          GraphicsContextSystem: ar,
          GraphicsGpuData: vf,
          GraphicsPath: je,
          GraphicsPipe: $a,
          HTMLTextPipe: ao,
          HTMLTextRenderData: Gn,
          HTMLTextSystem: lo,
          HelloSystem: dr,
          ImageSource: ct,
          InstructionSet: Hs,
          Loader: vu,
          LoaderParserPriority: At,
          MaskEffectManager: Ri,
          MaskEffectManagerClass: hh,
          MaskFilter: Hu,
          Matrix: R,
          Mesh: $u,
          MeshGeometry: oA,
          MeshGpuData: Ks,
          MeshPipe: eo,
          MeshRope: Pf,
          NOOP: Ds,
          NineSliceGeometry: jf,
          NineSliceSpriteGpuData: Zf,
          NineSliceSpritePipe: ro,
          ObservablePoint: le,
          PI_2: Ll,
          ParticleBuffer: Kf,
          ParticleContainerPipe: to,
          ParticleShader: Df,
          PassthroughFilter: Lu,
          PipelineSystem: Da,
          PlaneGeometry: kf,
          Point: H,
          Polygon: Lt,
          Pool: sh,
          PoolGroupClass: nh,
          QuadGeometry: _f,
          RAD_TO_DEG: jl,
          Rectangle: F,
          RenderGroup: Bi,
          RenderGroupPipe: Ma,
          RenderGroupSystem: Ta,
          RenderTarget: Gi,
          RenderTargetSystem: la,
          RenderTexture: ur,
          RenderableGCSystem: sf,
          RendererInitHook: un,
          RendererType: we,
          ResizePlugin: fn,
          Resolver: Rt,
          RopeGeometry: Nf,
          RoundedRectangle: _i,
          STENCIL_MODES: ie,
          SVGParser: cu,
          SchedulerSystem: Ua,
          SdfShader: ap,
          Shader: ke,
          ShaderStage: Yt,
          ShapePath: nu,
          SharedRenderPipes: Qa,
          SharedSystems: Na,
          Sprite: re,
          SpritePipe: Ia,
          Spritesheet: KA,
          State: Ue,
          StencilMask: tn,
          StencilMaskPipe: Ln,
          SystemRunner: hn,
          Text: id,
          TextStyle: tt,
          Texture: v,
          TextureGCSystem: af,
          TextureMatrix: Os,
          TexturePool: ce,
          TexturePoolClass: Eh,
          TextureSource: ne,
          TextureStyle: Je,
          Ticker: ue,
          TickerListener: bi,
          TickerPlugin: pn,
          TilingSpriteGpuData: Ap,
          TilingSpritePipe: so,
          TilingSpriteShader: zf,
          UNIFORM_TO_ARRAY_SETTERS: Nd,
          UNIFORM_TO_SINGLE_SETTERS: Bd,
          UNIFORM_TYPES_MAP: zh,
          UNIFORM_TYPES_VALUES: an,
          UPDATE_BLEND: Zi,
          UPDATE_COLOR: GA,
          UPDATE_PRIORITY: ut,
          UPDATE_VISIBLE: Dt,
          UboBatch: ff,
          UboSystem: ia,
          UniformGroup: qe,
          VERSION: OA,
          VideoSource: Ot,
          ViewContainer: HA,
          ViewSystem: lf,
          ViewableBuffer: bt,
          WGSL_ALIGN_SIZE_DATA: NA,
          WGSL_TO_STD40_SIZE: ra,
          WebGLRenderer: df,
          WebGPURenderer: xf,
          WorkerManager: Rs,
          accessibilityTarget: Gh,
          addBits: gs,
          addMaskBounds: zs,
          addMaskLocalBounds: _s,
          addProgramDefines: Kh,
          appendSVGPath: xs,
          applyMatrix: ep,
          applyStyleParams: Ws,
          assignWithIgnore: Vh,
          autoDetectRenderer: dc,
          bgr2rgb: CA,
          bitmapFontCachePlugin: mu,
          bitmapFontTextParser: xi,
          bitmapFontXMLParser: Cs,
          bitmapFontXMLStringParser: Us,
          blockDataMap: Za,
          boundsPool: De,
          browserExt: Yl,
          buildAdaptiveBezier: In,
          buildAdaptiveQuadratic: tu,
          buildArc: bn,
          buildArcTo: Au,
          buildArcToSvg: iu,
          buildCircle: tA,
          buildContextBatches: _c,
          buildEllipse: Yc,
          buildLine: Lc,
          buildPixelLine: jc,
          buildPolygon: Zc,
          buildRectangle: Xc,
          buildRoundedRectangle: Dc,
          buildSimpleUvs: Fc,
          buildTriangle: Hc,
          buildUvs: Kc,
          cacheAsTextureMixin: ah,
          cacheTextureArray: Mu,
          calculatePathArea: hu,
          calculateProjection: Ed,
          checkChildrenDidChange: Xs,
          checkDataUrl: Nt,
          checkExtension: Qt,
          checkForNestedPattern: ou,
          checkMaxIfStatementsInShader: Sn,
          childrenHelperMixin: oh,
          cleanArray: Af,
          cleanHash: tf,
          clearList: Ki,
          closePointEps: En,
          collectRenderablesMixin: lh,
          color32BitToUniform: lA,
          colorBit: er,
          colorBitGl: tr,
          compareModeToGlCompare: Dd,
          compileHighShader: Cc,
          compileHighShaderGl: Uc,
          compileHighShaderGlProgram: sA,
          compileHighShaderGpuProgram: rA,
          compileHooks: ms,
          compileInputs: Ss,
          compileOutputs: vc,
          compileShader: Ps,
          convertToList: Be,
          copySearchParams: Ni,
          createIdFromString: _t,
          createIndicesForQuads: Fs,
          createStringVariations: kh,
          createTexture: lr,
          createUboElementsSTD40: gd,
          createUboElementsWGSL: pf,
          createUboSyncFunction: sa,
          createUboSyncFunctionSTD40: qd,
          createUboSyncFunctionWGSL: mf,
          crossOrigin: wu,
          cullingMixin: rh,
          curveEps: Es,
          defaultFilterVert: Du,
          defaultValue: ca,
          definedProps: wA,
          deprecation: P,
          detectAvif: Eu,
          detectDefaults: Vu,
          detectMp4: Tu,
          detectOgv: Iu,
          detectVideoAlphaMode: An,
          detectWebm: bu,
          detectWebp: yu,
          determineCrossOrigin: Ju,
          earcut: oc,
          effectsMixin: ch,
          ensureAttributes: Xn,
          ensureIsBuffer: qn,
          ensurePrecision: Fh,
          ensureTextOptions: td,
          executeInstructions: Wi,
          extensions: Q,
          extractAttributesFromGlProgram: vd,
          extractAttributesFromGpuProgram: jh,
          extractFontFamilies: cp,
          extractStructAndGroups: yi,
          extractSubpaths: lu,
          extractSvgUrlId: bs,
          fastCopy: Qi,
          findMixin: uh,
          fontStringFromTextStyle: LA,
          fragmentGPUTemplate: Nc,
          fragmentGlTemplate: wc,
          generateArraySyncSTD40: Sd,
          generateArraySyncWGSL: gf,
          generateGpuLayoutGroups: Zh,
          generateLayoutHash: Xh,
          generateParticleUpdateFunction: Wf,
          generateProgram: Rd,
          generateShaderSyncCode: bd,
          generateTextureBatchBit: Ar,
          generateTextureBatchBitGl: ir,
          generateTextureMatrix: zc,
          generateUniformsSync: Qd,
          getAdjustedBlendModeBlend: eA,
          getAttributeInfoFromFormat: et,
          getBatchSamplersUniformGroup: rr,
          getBitmapTextLayout: Cn,
          getCanvasBoundingBox: Ad,
          getCanvasFillStyle: ZA,
          getCanvasTexture: oa,
          getDefaultUniformValue: _h,
          getFastGlobalBoundsMixin: dh,
          getFontCss: fp,
          getFontFamilyName: ku,
          getGeometryBounds: yc,
          getGlTypeFromFormat: ud,
          getGlobalBounds: Oi,
          getGlobalMixin: ph,
          getGlobalRenderableBounds: ju,
          getLocalBounds: ji,
          getMaxFragmentPrecision: Wh,
          getMaxTexturesPerBatch: Mc,
          getOrientationOfPoints: Oc,
          getPo2TextureFromSource: oo,
          getResolutionOfUrl: or,
          getSVGUrl: pp,
          getTemporaryCanvasFromImage: gp,
          getTestContext: nn,
          getTextureBatchBindGroup: $i,
          getUboData: Cd,
          getUniformData: Ud,
          getUrlExtension: Rh,
          glUploadBufferImageResource: Wd,
          glUploadCompressedTextureResource: Kd,
          glUploadImageResource: pa,
          glUploadVideoResource: Fd,
          globalUniformsBit: Pc,
          globalUniformsBitGl: Jc,
          gpuUploadBufferImageResource: Mf,
          gpuUploadCompressedTextureResource: Ef,
          gpuUploadImageResource: Xa,
          gpuUploadVideoResource: Vf,
          groupD8: j,
          injectBits: qs,
          insertVersion: Yh,
          isMobile: wh,
          isPow2: rs,
          isRenderingToScreen: Vd,
          isSafari: hp,
          isSingleItem: WA,
          isWebGLSupported: cc,
          isWebGPUSupported: uc,
          loadBitmapFont: Su,
          loadEnvironmentExtensions: ic,
          loadFontAsBase64: up,
          loadFontCSS: dp,
          loadImageBitmap: Qu,
          loadJson: Cu,
          loadSVGImage: mp,
          loadSvg: Bu,
          loadTextures: Rn,
          loadTxt: Uu,
          loadVideoTextures: Gu,
          loadWebFont: Ru,
          localUniformBit: Ht,
          localUniformBitGl: hr,
          localUniformBitGroup2: nd,
          localUniformMSDFBit: ip,
          localUniformMSDFBitGl: rp,
          logProgramError: kd,
          mSDFBit: sp,
          mSDFBitGl: np,
          mapFormatToGlFormat: Od,
          mapFormatToGlInternalFormat: Ld,
          mapFormatToGlType: jd,
          mapGlToVertexFormat: xd,
          mapType: ua,
          mapWebGLBlendModesToPixi: wd,
          maskFrag: Zu,
          maskVert: Xu,
          maskWgsl: ws,
          matrixPool: Se,
          measureHtmlText: rd,
          measureMixin: mh,
          mipmapScaleModeToGlFilter: Yd,
          multiplyColors: JA,
          multiplyHexColors: Zs,
          nextPow2: xt,
          normalizeExtensionPriority: IA,
          onRenderMixin: Sh,
          parseSVGDefinitions: au,
          parseSVGFloatAttribute: ee,
          parseSVGPath: gc,
          parseSVGStyle: yn,
          particlesFrag: Ff,
          particlesVert: Yf,
          particlesWgsl: Ys,
          passthroughFrag: Ou,
          passthroughWgsl: Ns,
          path: Ie,
          pointInTriangle: Qs,
          preloadVideo: Pu,
          removeItems: js,
          removeStructAndGroupDuplicates: Hh,
          resolveCharacters: gu,
          resolveJsonUrl: Wu,
          resolveTextureUrl: Bn,
          resourceToTexture: vh,
          roundPixelsBit: nA,
          roundPixelsBitGl: aA,
          roundedShapeArc: ru,
          roundedShapeQuadraticCurve: su,
          sayHello: ef,
          scaleModeToGlFilter: Gs,
          setPositions: $f,
          setProgramName: Dh,
          setUvs: tp,
          shapeBuilders: $A,
          sortMixin: qh,
          spritesheetAsset: Qh,
          squaredDistanceToLineSegment: mc,
          stripVersion: Oh,
          styleAttributes: ys,
          testImageFormat: kn,
          testVideoFormat: ei,
          textureBit: ad,
          textureBitGl: od,
          textureFrom: Ch,
          tilingBit: Xf,
          tilingBitGl: Hf,
          toFillStyle: lt,
          toLocalGlobalMixin: Mh,
          toStrokeStyle: jA,
          transformVertices: Mn,
          triangulateWithHoles: Vn,
          uboSyncFunctionsSTD40: na,
          uboSyncFunctionsWGSL: md,
          uid: z,
          uniformParsers: ht,
          unsafeEvalSupported: ln,
          updateQuadBounds: Ls,
          updateRenderGroupTransform: Zd,
          updateRenderGroupTransforms: Ea,
          updateTextBounds: Fi,
          updateTransformAndChildren: Va,
          updateTransformBackwards: Li,
          v8_0_0: W,
          v8_3_4: Hl,
          validateRenderables: Xd,
          vertexGPUTemplate: Bc,
          vertexGlTemplate: Qc,
          warn: N,
          webworkerExt: Dl,
          wrapModeToGlAddress: Ci,
        },
        Symbol.toStringTag,
        { value: 'Module' }
      )
    );
    class qp {
      constructor() {
        V(
          this,
          'GOOGLE_PLAY_URL',
          'https://play.google.com/store/apps/details?id=ae.goragaming.playoff.blocks.game.make.earn.money.rewarded'
        );
        V(this, 'APP_STORE_URL', 'https://apps.apple.com/us/app/win-real-money-playoff-games/id6444492155');
        V(this, 'isReady', !1);
        V(this, 'eventListeners', new Map());
        V(this, 'mraidReadyHandler');
        V(this, 'mraidViewableChangeHandler');
        V(this, 'mraidSizeChangeHandler');
        window.super_html &&
          (window.super_html.set_google_play_url(this.GOOGLE_PLAY_URL),
            window.super_html.set_app_store_url(this.APP_STORE_URL)),
          this.initMRAID();
      }
      initMRAID() {
        if (!window.mraid) {
          this.markReady();
          return;
        }
        (this.mraidReadyHandler = () => {
          this.markReady(),
            window.mraid?.addEventListener &&
            ((this.mraidViewableChangeHandler = (e) => {
              this.emit('viewableChange', e);
            }),
              window.mraid.addEventListener('viewableChange', this.mraidViewableChangeHandler),
              (this.mraidSizeChangeHandler = (e, t) => {
                this.emit('sizeChange', { width: e, height: t });
              }),
              window.mraid.addEventListener('sizeChange', this.mraidSizeChangeHandler));
        }),
          window.mraid.getState && window.mraid.getState() !== 'loading'
            ? this.mraidReadyHandler()
            : window.mraid.addEventListener('ready', this.mraidReadyHandler);
      }
      markReady() {
        (this.isReady = !0), this.emit('ready');
      }
      waitForReady() {
        return this.isReady
          ? Promise.resolve()
          : new Promise((e) => {
            this.once('ready', () => e());
          });
      }
      download() {
        if (window.FbPlayableAd?.onCTAClick) {
          window.FbPlayableAd.onCTAClick();
          return;
        }
        if (window.mraid) {
          const t = this.getStoreUrl();
          window.mraid.openStoreUrl ? window.mraid.openStoreUrl(t) : window.mraid.open && window.mraid.open(t);
          return;
        }
        if (window.super_html?.download) {
          window.super_html.download();
          return;
        }
        const e = this.getStoreUrl();
        window.open(e, '_blank');
      }
      getStoreUrl() {
        return this.isAndroid() ? this.GOOGLE_PLAY_URL : this.APP_STORE_URL;
      }
      gameEnd() {
        window.mraid?.close && window.mraid.close(), window.super_html?.game_end && window.super_html.game_end();
      }
      isAudioEnabled() {
        return window.super_html?.is_audio ? window.super_html.is_audio() : !0;
      }
      isDownloadHidden() {
        return window.super_html?.is_hide_download ? window.super_html.is_hide_download() : !1;
      }
      getMaxSize() {
        return window.mraid?.getMaxSize ? window.mraid.getMaxSize() : null;
      }
      isViewable() {
        return window.mraid?.isViewable ? window.mraid.isViewable() : !0;
      }
      isAndroid() {
        return /Android/i.test(navigator.userAgent);
      }
      on(e, t) {
        this.eventListeners.has(e) || this.eventListeners.set(e, new Set()), this.eventListeners.get(e).add(t);
      }
      once(e, t) {
        const A = (r) => {
          t(r), this.off(e, A);
        };
        this.on(e, A);
      }
      off(e, t) {
        const A = this.eventListeners.get(e);
        A && A.delete(t);
      }
      emit(e, t) {
        const A = this.eventListeners.get(e);
        A && A.forEach((r) => r(t));
      }
      destroy() {
        window.mraid &&
          window.mraid.removeEventListener &&
          (this.mraidReadyHandler && window.mraid.removeEventListener('ready', this.mraidReadyHandler),
            this.mraidViewableChangeHandler &&
            window.mraid.removeEventListener('viewableChange', this.mraidViewableChangeHandler),
            this.mraidSizeChangeHandler && window.mraid.removeEventListener('sizeChange', this.mraidSizeChangeHandler)),
          this.eventListeners.clear();
      }
    }
    const FS = {
      currency: 'USD',
      currencySymbol: '$',
      buttons: { play: 'PLAY', download: 'DOWNLOAD', continue: 'CONTINUE', install: 'INSTALL' },
      game: { score: 'SCORE', level: 'LEVEL', balance: 'BALANCE' },
      tutorial: { tapToStart: 'Tap to start earning!', tapToJump: 'Jump to avoid enemies' },
      praise: ['Awesome!', 'Fantastic!', 'Great!', 'Perfect!'],
      warnings: { avoid: 'EVADE' },
      winScreen: { title: 'Congratulations!', subtitle: 'Choose your reward!', reward: 'Your reward' },
      loseScreen: { title: "You didn't make it!", subtitle: 'Try again on the app!' },
      endScreen: { title: 'Play Now!', ctaButton: 'Install and Earn', nextPayment: 'Next payment in one minute' },
      disclaimer: 'The actual payment depends on playing and interacting with the JustPlay app.',
    },
      YS = {
        currency: 'EUR',
        currencySymbol: '',
        buttons: { play: 'JUGAR', download: 'DESCARGAR', continue: 'CONTINUAR', install: 'INSTALAR' },
        game: { score: 'PUNTOS', level: 'NIVEL', balance: 'SALDO' },
        tutorial: { tapToStart: 'Toca para empezar a ganar!', tapToJump: 'Salta para evitar enemigos' },
        praise: ['Increble!', 'Fantstico!', 'Genial!', 'Perfecto!'],
        warnings: { avoid: 'ESQUIVA!' },
        winScreen: { title: 'Felicidades!', subtitle: 'Elige tu recompensa!', reward: 'Tu recompensa' },
        loseScreen: { title: 'No lo lograste!', subtitle: 'Intntalo de nuevo en la app!' },
        endScreen: { title: 'Juega Ahora!', ctaButton: 'Instalar y ganar', nextPayment: 'Prximo pago en un minuto' },
        disclaimer: 'El pago real depende de jugar e interactuar con la app JustPlay.',
      },
      DS = {
        currency: 'EUR',
        currencySymbol: '',
        buttons: { play: 'GIOCA', download: 'SCARICA', continue: 'CONTINUA', install: 'INSTALLA' },
        game: { score: 'PUNTI', level: 'LIVELLO', balance: 'SALDO' },
        tutorial: { tapToStart: 'Tocca per iniziare a guadagnare!', tapToJump: 'Salta per evitare i nemici' },
        praise: ['Fantastico!', 'Incredibile!', 'Ottimo!', 'Perfetto!'],
        warnings: { avoid: 'EVITA' },
        winScreen: { title: 'Congratulazioni!', subtitle: 'Scegli la tua ricompensa!', reward: 'La tua ricompensa' },
        loseScreen: { title: "Non ce l'hai fatta!", subtitle: "Riprova ora sull'app!" },
        endScreen: { title: 'Gioca Ora!', ctaButton: 'Installa e guadagna', nextPayment: 'Prossimo pagamento in un minuto' },
        disclaimer: "Il pagamento effettivo e l'importo dipendono dal giocare e interagire con l'app JustPlay.",
      },
      OS = 'en',
      Pl = { en: FS, es: YS, it: DS },
      LS = Pl[OS] || Pl.en,
      ae = LS,
      $e = 720,
      Me = 1280;
    let yt = 720,
      es = 1280;
    function Jl() {
      const i = window.innerWidth,
        e = window.innerHeight;
      return i > e ? ((yt = 1280), (es = 720)) : ((yt = 720), (es = 1280)), { width: yt, height: es };
    }
    const oe = {
      X_POSITION: 0.18,
      GROUND_Y: 280,
      JUMP_HEIGHT: 300,
      JUMP_DURATION: 800,
      INVINCIBILITY_TIME: 500,
      SCALE: 0.54,
      ANIMATION_SPEED: 0.15,
    },
      jS = { CHASE_SPEED: 300 },
      Ye = { BASE_SPEED: 600, PARALLAX: { GROUND: 1 } },
      Te = {
        PLAYER_SCALE: { X: 0.25, Y: 0.7 },
        PLAYER_OFFSET: { X: 0, Y: -0.15 },
        ENEMY_SCALE: { X: 0.3, Y: 0.5 },
        ENEMY_OFFSET: { X: 0, Y: 0.2 },
        OBSTACLE_SHRINK: 10,
        OBSTACLE_OFFSET: { X: 0, Y: 0 },
        COLLECTIBLE_RADIUS: 60,
      },
      Gt = { DOLLAR_VALUE: 20, PAYPAL_CARD_MIN: 5, PAYPAL_CARD_MAX: 50, START_BALANCE: 0 },
      Yi = { MAX_HP: 3 },
      Gl = [
        { type: 'collectible', distance: 1 },
        { type: 'collectible', distance: 2 },
        { type: 'enemy', distance: 3, pauseForTutorial: !0 },
        { type: 'collectible', distance: 4, yOffset: 50 },
        { type: 'collectible', distance: 4.2, yOffset: 150 },
        { type: 'collectible', distance: 4.4, yOffset: 250 },
        { type: 'collectible', distance: 4.6, yOffset: 150 },
        { type: 'collectible', distance: 4.8, yOffset: 50 },
        { type: 'obstacle', distance: 5.6, warningLabel: !0 },
        { type: 'collectible', distance: 6.4 },
        { type: 'enemy', distance: 7 },
        { type: 'collectible', distance: 7.6 },
        { type: 'collectible', distance: 7.8, yOffset: 100 },
        { type: 'collectible', distance: 8, yOffset: 200 },
        { type: 'collectible', distance: 8.2, yOffset: 280 },
        { type: 'collectible', distance: 8.4, yOffset: 200 },
        { type: 'collectible', distance: 8.6, yOffset: 100 },
        { type: 'obstacle', distance: 9, warningLabel: !0 },
        { type: 'collectible', distance: 9.6 },
        { type: 'enemy', distance: 10 },
        { type: 'collectible', distance: 10.6 },
        { type: 'collectible', distance: 11, yOffset: 80 },
        { type: 'collectible', distance: 11.2, yOffset: 180 },
        { type: 'collectible', distance: 11.4, yOffset: 80 },
        { type: 'obstacle', distance: 12 },
        { type: 'enemy', distance: 12.6 },
        { type: 'collectible', distance: 13 },
        { type: 'collectible', distance: 13.2, yOffset: 100 },
        { type: 'collectible', distance: 13.4, yOffset: 200 },
        { type: 'collectible', distance: 13.6, yOffset: 100 },
        { type: 'obstacle', distance: 14, warningLabel: !0 },
        { type: 'collectible', distance: 14.5 },
        { type: 'enemy', distance: 15 },
        { type: 'collectible', distance: 15.4, yOffset: 80 },
        { type: 'collectible', distance: 15.6, yOffset: 180 },
        { type: 'collectible', distance: 15.8, yOffset: 260 },
        { type: 'collectible', distance: 16, yOffset: 180 },
        { type: 'collectible', distance: 16.2, yOffset: 80 },
        { type: 'obstacle', distance: 16.5 },
        { type: 'finish', distance: 18 },
      ];
    var ge = ((i) => (
      (i.LOADING = 'loading'),
      (i.INTRO = 'intro'),
      (i.RUNNING = 'running'),
      (i.PAUSED = 'paused'),
      (i.JUMPING = 'jumping'),
      (i.HURT = 'hurt'),
      (i.END_WIN = 'end_win'),
      (i.END_LOSE = 'end_lose'),
      i
    ))(ge || {}),
      pe = ((i) => ((i.IDLE = 'idle'), (i.RUN = 'run'), (i.JUMP = 'jump'), (i.HURT = 'hurt'), i))(pe || {});
    const Ti = { PULSE_SPEED: 5e-4, PULSE_MIN: 0.95, PULSE_MAX: 1.05 },
      me = {
        FAR_BACKGROUND: 0,
        MID_BACKGROUND: 5,
        NEAR_BACKGROUND: 8,
        GROUND: 10,
        COLLECTIBLES: 20,
        OBSTACLES: 30,
        FINISH_LINE: 35,
        ENEMIES: 40,
        WARNING_LABEL: 50,
        PLAYER: 70,
        CONFETTI: 90,
        OVERLAY: 85,
      },
      gr = { HITBOX_COLORS: { PLAYER: 65280, ENEMY: 16711680, OBSTACLE: 16746496, COLLECTIBLE: 65535 } },
      ZS = {
        hurt_0: {
          frame: { x: 1, y: 419, w: 116, h: 254 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 116, h: 254 },
          sourceSize: { w: 116, h: 254 },
        },
        hurt_1: {
          frame: { x: 1, y: 131, w: 142, h: 255 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 142, h: 255 },
          sourceSize: { w: 142, h: 255 },
        },
        hurt_2: {
          frame: { x: 1, y: 275, w: 142, h: 254 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 142, h: 254 },
          sourceSize: { w: 142, h: 254 },
        },
        hurt_3: {
          frame: { x: 1, y: 1, w: 128, h: 263 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 128, h: 263 },
          sourceSize: { w: 128, h: 263 },
        },
        idle_0: {
          frame: { x: 1, y: 1603, w: 84, h: 244 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 84, h: 244 },
          sourceSize: { w: 84, h: 244 },
        },
        idle_1: {
          frame: { x: 250, y: 1393, w: 85, h: 243 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 85, h: 243 },
          sourceSize: { w: 85, h: 243 },
        },
        idle_2: {
          frame: { x: 1, y: 1429, w: 85, h: 247 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 85, h: 247 },
          sourceSize: { w: 85, h: 247 },
        },
        idle_3: {
          frame: { x: 1, y: 1516, w: 85, h: 247 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 85, h: 247 },
          sourceSize: { w: 85, h: 247 },
        },
        idle_4: {
          frame: { x: 1, y: 1341, w: 86, h: 247 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 86, h: 247 },
          sourceSize: { w: 86, h: 247 },
        },
        idle_5: {
          frame: { x: 1, y: 1252, w: 87, h: 248 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 87, h: 248 },
          sourceSize: { w: 87, h: 248 },
        },
        idle_6: {
          frame: { x: 1, y: 1164, w: 86, h: 249 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 86, h: 249 },
          sourceSize: { w: 86, h: 249 },
        },
        idle_7: {
          frame: { x: 1, y: 897, w: 87, h: 250 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 87, h: 250 },
          sourceSize: { w: 87, h: 250 },
        },
        idle_8: {
          frame: { x: 1, y: 717, w: 88, h: 250 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 88, h: 250 },
          sourceSize: { w: 88, h: 250 },
        },
        idle_9: {
          frame: { x: 1, y: 986, w: 87, h: 250 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 87, h: 250 },
          sourceSize: { w: 87, h: 250 },
        },
        idle_10: {
          frame: { x: 1, y: 807, w: 88, h: 250 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 88, h: 250 },
          sourceSize: { w: 88, h: 250 },
        },
        idle_11: {
          frame: { x: 1, y: 1075, w: 87, h: 250 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 87, h: 250 },
          sourceSize: { w: 87, h: 250 },
        },
        idle_12: {
          frame: { x: 1, y: 627, w: 88, h: 251 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 88, h: 251 },
          sourceSize: { w: 88, h: 251 },
        },
        idle_13: {
          frame: { x: 1, y: 537, w: 88, h: 252 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 88, h: 252 },
          sourceSize: { w: 88, h: 252 },
        },
        jump_0: {
          frame: { x: 176, y: 1689, w: 161, h: 190 },
          rotated: !1,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 161, h: 190 },
          sourceSize: { w: 161, h: 190 },
        },
        jump_1: {
          frame: { x: 1, y: 1689, w: 173, h: 191 },
          rotated: !1,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 173, h: 191 },
          sourceSize: { w: 173, h: 191 },
        },
        jump_2: {
          frame: { x: 252, y: 1171, w: 110, h: 208 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 110, h: 208 },
          sourceSize: { w: 110, h: 208 },
        },
        jump_3: {
          frame: { x: 251, y: 1283, w: 108, h: 208 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 108, h: 208 },
          sourceSize: { w: 108, h: 208 },
        },
        jump_4: {
          frame: { x: 250, y: 1480, w: 146, h: 207 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 146, h: 207 },
          sourceSize: { w: 146, h: 207 },
        },
        jump_5: {
          frame: { x: 339, y: 1628, w: 148, h: 200 },
          rotated: !1,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 148, h: 200 },
          sourceSize: { w: 148, h: 200 },
        },
        jump_6: {
          frame: { x: 253, y: 1061, w: 108, h: 212 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 108, h: 212 },
          sourceSize: { w: 108, h: 212 },
        },
        jump_7: {
          frame: { x: 253, y: 959, w: 100, h: 228 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 100, h: 228 },
          sourceSize: { w: 100, h: 228 },
        },
        run_0: {
          frame: { x: 266, y: 1, w: 157, h: 212 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 157, h: 212 },
          sourceSize: { w: 157, h: 212 },
        },
        run_1: {
          frame: { x: 257, y: 501, w: 99, h: 229 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 99, h: 229 },
          sourceSize: { w: 99, h: 229 },
        },
        run_2: {
          frame: { x: 258, y: 259, w: 125, h: 232 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 125, h: 232 },
          sourceSize: { w: 125, h: 232 },
        },
        run_3: {
          frame: { x: 258, y: 160, w: 97, h: 234 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 97, h: 234 },
          sourceSize: { w: 97, h: 234 },
        },
        run_4: {
          frame: { x: 253, y: 802, w: 155, h: 228 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 155, h: 228 },
          sourceSize: { w: 155, h: 228 },
        },
        run_5: {
          frame: { x: 257, y: 386, w: 113, h: 236 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 113, h: 236 },
          sourceSize: { w: 113, h: 236 },
        },
        run_6: {
          frame: { x: 255, y: 602, w: 112, h: 237 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 112, h: 237 },
          sourceSize: { w: 112, h: 237 },
        },
        run_7: {
          frame: { x: 254, y: 716, w: 84, h: 239 },
          rotated: !0,
          trimmed: !1,
          spriteSourceSize: { x: 0, y: 0, w: 84, h: 239 },
          sourceSize: { w: 84, h: 239 },
        },
      },
      XS = {
        idle: [
          'idle_0',
          'idle_1',
          'idle_2',
          'idle_3',
          'idle_4',
          'idle_5',
          'idle_6',
          'idle_7',
          'idle_8',
          'idle_9',
          'idle_10',
          'idle_11',
          'idle_12',
          'idle_13',
        ],
        run: ['run_0', 'run_1', 'run_2', 'run_3', 'run_4', 'run_5', 'run_6', 'run_7'],
        jump: ['jump_0', 'jump_1', 'jump_2', 'jump_3', 'jump_4', 'jump_5', 'jump_6', 'jump_7'],
        hurt: ['hurt_0', 'hurt_1', 'hurt_2', 'hurt_3'],
      },
      HS = {
        app: 'https://www.codeandweb.com/texturepacker',
        version: '1.1',
        image: 'toly-new.png',
        format: 'RGBA8888',
        size: { w: 494, h: 1881 },
        scale: 0.5,
        smartupdate:
          '$TexturePacker:SmartUpdate:0fdcabd6b50ff868268f356d71424d0e:f6cc5806492cd3d30946c8929b3f4132:50728fd2577e627ee40cc03139638b0d$',
      },
      zS = { frames: ZS, animations: XS, meta: HS },
      _S =
        '[PLACEHOLDER:image/webp]';
    class $S extends _ {
      constructor() {
        super();
        V(this, 'sprite');
        V(this, 'spritesheet');
        V(this, 'currentAnimation', pe.IDLE);
        V(this, 'isJumping', !1);
        V(this, 'jumpStartY', 0);
        V(this, 'jumpProgress', 0);
        V(this, '_isInvincible', !1);
        V(this, 'invincibilityTimer', 0);
        V(this, 'blinkTimer', 0);
        V(this, 'groundY');
        V(this, 'debugGraphics');
        this.groundY = Me - oe.GROUND_Y;
      }
      async init() {
        const t = await te.load(_S);
        (this.spritesheet = new KA(t, zS)), await this.spritesheet.parse();
        const A = this.spritesheet.animations[pe.IDLE];
        (this.sprite = new AA(A)),
          this.sprite.anchor.set(0.5, 1),
          this.sprite.scale.set(oe.SCALE),
          (this.sprite.animationSpeed = oe.ANIMATION_SPEED),
          this.sprite.play(),
          this.addChild(this.sprite),
          (this.x = $e * oe.X_POSITION),
          (this.y = this.groundY);
      }
      playAnimation(t) {
        if (this.currentAnimation === t) return;
        const A = this.spritesheet.animations[t];
        if (A) {



          switch (((this.currentAnimation = t), (this.sprite.textures = A), t)) {
            case pe.JUMP:
              (this.sprite.loop = !1), (this.sprite.animationSpeed = oe.ANIMATION_SPEED * 1.5);
              break;
            case pe.HURT:
              (this.sprite.loop = !1), (this.sprite.animationSpeed = oe.ANIMATION_SPEED * 2);
              break;
            default:
              (this.sprite.loop = !0), (this.sprite.animationSpeed = oe.ANIMATION_SPEED);
          }
          this.sprite.gotoAndPlay(0);
        }
      }
      async jump() {
        if (!this.isJumping)
          return (
            (this.isJumping = !0),
            (this.jumpStartY = this.y),
            (this.jumpProgress = 0),
            this.playAnimation(pe.JUMP),
            new Promise((t) => {
              const A = () => {
                this.isJumping ? requestAnimationFrame(A) : t();
              };
              A();
            })
          );
      }
      hurt() {
        if (this._isInvincible) return;
        const t = this.currentAnimation;
        this.playAnimation(pe.HURT),
          (this._isInvincible = !0),
          (this.invincibilityTimer = oe.INVINCIBILITY_TIME),
          (this.sprite.onComplete = () => {
            (this.sprite.onComplete = void 0), this.isJumping || this.playAnimation(t === pe.HURT ? pe.IDLE : t);
          });
      }
      run() {
        !this.isJumping && this.currentAnimation !== pe.HURT && this.playAnimation(pe.RUN);
      }
      idle(t = !1) {
        (t || (!this.isJumping && this.currentAnimation !== pe.HURT)) && this.playAnimation(pe.IDLE);
      }
      update(t) {
        if (this.isJumping)
          if (((this.jumpProgress += t / oe.JUMP_DURATION), this.jumpProgress >= 1))
            (this.isJumping = !1),
              (this.y = this.groundY),
              (this.jumpProgress = 0),
              this.currentAnimation === pe.JUMP && this.playAnimation(pe.RUN);
          else {
            const A = Math.sin(this.jumpProgress * Math.PI) * oe.JUMP_HEIGHT;
            this.y = this.jumpStartY - A;
          }
        this._isInvincible &&
          ((this.invincibilityTimer -= t),
            (this.blinkTimer += t),
            this.blinkTimer >= 100 &&
            ((this.blinkTimer = 0), (this.sprite.tint = this.sprite.tint === 16777215 ? 16729156 : 16777215)),
            this.invincibilityTimer <= 0 && ((this._isInvincible = !1), (this.sprite.tint = 16777215)));
      }
      updateDebugGraphics() {
        if (!this.debugGraphics) return;
        const t = this.getHitbox(),
          A = this.toLocal({ x: t.x, y: t.y }),
          r = this.toLocal({ x: t.x + t.width, y: t.y + t.height }),
          s = r.x - A.x,
          n = r.y - A.y;
        this.debugGraphics.clear(),
          this.debugGraphics.rect(A.x, A.y, s, n),
          this.debugGraphics.stroke({ width: 2, color: gr.HITBOX_COLORS.PLAYER });
      }
      getHitbox() {
        const t = this.sprite.getBounds(),
          A = t.width * Te.PLAYER_SCALE.X,
          r = t.height * Te.PLAYER_SCALE.Y,
          s = (t.width - A) / 2,
          n = t.height - r,
          a = t.width * Te.PLAYER_OFFSET.X,
          l = t.height * Te.PLAYER_OFFSET.Y;
        return new F(t.x + s + a, t.y + n + l, A, r);
      }
      get isInvincible() {
        return this._isInvincible;
      }
      get isOnGround() {
        return !this.isJumping;
      }
      get animation() {
        return this.currentAnimation;
      }
      reset() {
        (this.isJumping = !1),
          (this.jumpProgress = 0),
          (this._isInvincible = !1),
          (this.invincibilityTimer = 0),
          (this.sprite.tint = 16777215),
          (this.y = this.groundY),
          this.playAnimation(pe.IDLE);
      }
    }
    const eq = {
      frame_0: {
        frame: { x: 3, y: 3, w: 174, h: 357 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 29, y: 0, w: 174, h: 357 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_1: {
        frame: { x: 182, y: 2, w: 145, h: 357 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 44, y: 0, w: 145, h: 357 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_2: {
        frame: { x: 333, y: 2, w: 183, h: 354 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 25, y: 3, w: 183, h: 354 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_3: {
        frame: { x: 520, y: 3, w: 146, h: 353 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 43, y: 4, w: 146, h: 353 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_4: {
        frame: { x: 672, y: 2, w: 134, h: 354 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 49, y: 3, w: 134, h: 354 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_5: {
        frame: { x: 812, y: 2, w: 145, h: 353 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 44, y: 4, w: 145, h: 353 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_6: {
        frame: { x: 963, y: 3, w: 163, h: 350 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 35, y: 7, w: 163, h: 350 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_7: {
        frame: { x: 1131, y: 3, w: 154, h: 348 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 39, y: 9, w: 154, h: 348 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_8: {
        frame: { x: 1290, y: 2, w: 150, h: 349 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 41, y: 8, w: 150, h: 349 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_9: {
        frame: { x: 1446, y: 3, w: 233, h: 336 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 0, y: 21, w: 233, h: 336 },
        sourceSize: { w: 233, h: 357 },
      },
      frame_10: {
        frame: { x: 2, y: 365, w: 161, h: 359 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 32, y: 0, w: 161, h: 359 },
        sourceSize: { w: 226, h: 359 },
      },
      frame_11: {
        frame: { x: 167, y: 365, w: 136, h: 357 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 45, y: 2, w: 136, h: 357 },
        sourceSize: { w: 226, h: 359 },
      },
      frame_12: {
        frame: { x: 307, y: 363, w: 205, h: 355 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 10, y: 4, w: 205, h: 355 },
        sourceSize: { w: 226, h: 359 },
      },
      frame_13: {
        frame: { x: 518, y: 361, w: 159, h: 355 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 33, y: 4, w: 159, h: 355 },
        sourceSize: { w: 226, h: 359 },
      },
      frame_14: {
        frame: { x: 683, y: 361, w: 165, h: 353 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 30, y: 6, w: 165, h: 353 },
        sourceSize: { w: 226, h: 359 },
      },
      frame_15: {
        frame: { x: 854, y: 360, w: 192, h: 351 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 17, y: 8, w: 192, h: 351 },
        sourceSize: { w: 226, h: 359 },
      },
      frame_16: {
        frame: { x: 1050, y: 358, w: 156, h: 350 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 35, y: 9, w: 156, h: 350 },
        sourceSize: { w: 226, h: 359 },
      },
      frame_17: {
        frame: { x: 1211, y: 357, w: 208, h: 347 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 9, y: 12, w: 208, h: 347 },
        sourceSize: { w: 226, h: 359 },
      },
      frame_18: {
        frame: { x: 1423, y: 356, w: 226, h: 338 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 0, y: 21, w: 226, h: 338 },
        sourceSize: { w: 226, h: 359 },
      },
      frame_19: {
        frame: { x: 3, y: 728, w: 151, h: 358 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 26, y: 0, w: 151, h: 358 },
        sourceSize: { w: 203, h: 358 },
      },
      frame_20: {
        frame: { x: 160, y: 729, w: 169, h: 357 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 17, y: 1, w: 169, h: 357 },
        sourceSize: { w: 203, h: 358 },
      },
      frame_21: {
        frame: { x: 334, y: 723, w: 183, h: 354 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 10, y: 4, w: 183, h: 354 },
        sourceSize: { w: 203, h: 358 },
      },
      frame_22: {
        frame: { x: 521, y: 720, w: 143, h: 353 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 30, y: 5, w: 143, h: 353 },
        sourceSize: { w: 203, h: 358 },
      },
      frame_23: {
        frame: { x: 669, y: 721, w: 185, h: 351 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 9, y: 7, w: 185, h: 351 },
        sourceSize: { w: 203, h: 358 },
      },
      frame_24: {
        frame: { x: 858, y: 715, w: 180, h: 350 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 11, y: 8, w: 180, h: 350 },
        sourceSize: { w: 203, h: 358 },
      },
      frame_25: {
        frame: { x: 1044, y: 715, w: 173, h: 349 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 15, y: 9, w: 173, h: 349 },
        sourceSize: { w: 203, h: 358 },
      },
      frame_26: {
        frame: { x: 1223, y: 709, w: 147, h: 349 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 28, y: 9, w: 147, h: 349 },
        sourceSize: { w: 203, h: 358 },
      },
      frame_27: {
        frame: { x: 1375, y: 710, w: 203, h: 347 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 0, y: 11, w: 203, h: 347 },
        sourceSize: { w: 203, h: 358 },
      },
      frame_28: {
        frame: { x: 3, y: 1091, w: 152, h: 359 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 27, y: 0, w: 152, h: 359 },
        sourceSize: { w: 207, h: 359 },
      },
      frame_29: {
        frame: { x: 160, y: 1090, w: 195, h: 355 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 6, y: 4, w: 195, h: 355 },
        sourceSize: { w: 207, h: 359 },
      },
      frame_30: {
        frame: { x: 360, y: 1082, w: 134, h: 353 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 36, y: 6, w: 134, h: 353 },
        sourceSize: { w: 207, h: 359 },
      },
      frame_31: {
        frame: { x: 500, y: 1081, w: 155, h: 353 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 26, y: 6, w: 155, h: 353 },
        sourceSize: { w: 207, h: 359 },
      },
      frame_32: {
        frame: { x: 660, y: 1078, w: 135, h: 353 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 36, y: 6, w: 135, h: 353 },
        sourceSize: { w: 207, h: 359 },
      },
      frame_33: {
        frame: { x: 801, y: 1078, w: 190, h: 349 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 8, y: 10, w: 190, h: 349 },
        sourceSize: { w: 207, h: 359 },
      },
      frame_34: {
        frame: { x: 997, y: 1070, w: 173, h: 350 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 17, y: 9, w: 173, h: 350 },
        sourceSize: { w: 207, h: 359 },
      },
      frame_35: {
        frame: { x: 1175, y: 1069, w: 160, h: 349 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 23, y: 10, w: 160, h: 349 },
        sourceSize: { w: 207, h: 359 },
      },
      frame_36: {
        frame: { x: 1340, y: 1062, w: 207, h: 347 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 0, y: 12, w: 207, h: 347 },
        sourceSize: { w: 207, h: 359 },
      },
      frame_37: {
        frame: { x: 3, y: 1455, w: 252, h: 309 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 6, y: 36, w: 252, h: 309 },
        sourceSize: { w: 264, h: 345 },
      },
      frame_38: {
        frame: { x: 260, y: 1451, w: 230, h: 318 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 17, y: 27, w: 230, h: 318 },
        sourceSize: { w: 264, h: 345 },
      },
      frame_39: {
        frame: { x: 496, y: 1441, w: 242, h: 325 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 11, y: 20, w: 242, h: 325 },
        sourceSize: { w: 264, h: 345 },
      },
      frame_40: {
        frame: { x: 743, y: 1436, w: 264, h: 323 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 0, y: 22, w: 264, h: 323 },
        sourceSize: { w: 264, h: 345 },
      },
      frame_41: {
        frame: { x: 1012, y: 1426, w: 190, h: 342 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 37, y: 3, w: 190, h: 342 },
        sourceSize: { w: 264, h: 345 },
      },
      frame_42: {
        frame: { x: 1208, y: 1424, w: 167, h: 345 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 48, y: 0, w: 167, h: 345 },
        sourceSize: { w: 264, h: 345 },
      },
      frame_43: {
        frame: { x: 1381, y: 1414, w: 226, h: 333 },
        rotated: !1,
        trimmed: !0,
        spriteSourceSize: { x: 19, y: 12, w: 226, h: 333 },
        sourceSize: { w: 264, h: 345 },
      },
    },
      tq = {
        default: [
          'frame_0',
          'frame_1',
          'frame_2',
          'frame_3',
          'frame_4',
          'frame_5',
          'frame_6',
          'frame_7',
          'frame_8',
          'frame_9',
          'frame_10',
          'frame_11',
          'frame_12',
          'frame_13',
          'frame_14',
          'frame_15',
          'frame_16',
          'frame_17',
          'frame_18',
          'frame_19',
          'frame_20',
          'frame_21',
          'frame_22',
          'frame_23',
          'frame_24',
          'frame_25',
          'frame_26',
          'frame_27',
          'frame_28',
          'frame_29',
          'frame_30',
          'frame_31',
          'frame_32',
          'frame_33',
          'frame_34',
          'frame_35',
          'frame_36',
          'frame_37',
          'frame_38',
          'frame_39',
          'frame_40',
          'frame_41',
          'frame_42',
          'frame_43',
        ],
      },
      Aq = {
        app: 'auto-detect',
        version: '1.0',
        image: 'enemy-spritesheet.png',
        format: 'RGBA8888',
        size: { w: 1682, h: 1771 },
        scale: 1,
      },
      iq = { frames: eq, animations: tq, meta: Aq },
      rq =
        '[PLACEHOLDER:image/webp]';
    class sq extends _ {
      constructor() {
        super();
        V(this, 'sprite');
        V(this, 'spritesheet');
        V(this, '_speed', 0);
        V(this, 'debugGraphics');
        V(this, '_isTutorialEnemy', !1);
      }
      async init() {
        const t = await te.load(rq);
        (this.spritesheet = new KA(t, iq)), await this.spritesheet.parse();
        const A =
          this.spritesheet.animations.default ||
          this.spritesheet.animations.idle ||
          Object.values(this.spritesheet.animations)[0];
        (this.sprite = new AA(A)), this.sprite.anchor.set(0.5, 1);
        const r = oe.SCALE * 1.3;
        this.sprite.scale.set(-r, r),
          (this.sprite.animationSpeed = 0.2),
          this.sprite.play(),
          this.addChild(this.sprite),
          (this.y = Me - oe.GROUND_Y - 20);
      }
      update(t) {
        const A = this._speed + jS.CHASE_SPEED;
        this.x -= (A * t) / 1e3;
      }
      updateDebugGraphics() {
        if (!this.debugGraphics) return;
        const t = this.getHitbox(),
          A = this.toLocal({ x: t.x, y: t.y }),
          r = this.toLocal({ x: t.x + t.width, y: t.y + t.height }),
          s = r.x - A.x,
          n = r.y - A.y;
        this.debugGraphics.clear(),
          this.debugGraphics.rect(A.x, A.y, s, n),
          this.debugGraphics.stroke({ width: 2, color: gr.HITBOX_COLORS.ENEMY });
      }
      set speed(t) {
        this._speed = t;
      }
      get speed() {
        return this._speed;
      }
      getHitbox() {
        const t = this.sprite.getBounds(),
          A = t.width * Te.ENEMY_SCALE.X,
          r = t.height * Te.ENEMY_SCALE.Y,
          s = (t.width - A) / 2,
          n = t.height - r,
          a = t.width * Te.ENEMY_OFFSET.X,
          l = t.height * Te.ENEMY_OFFSET.Y;
        return new F(t.x + s + a, t.y + n + l, A, r);
      }
      isOffScreen() {
        const t = this.sprite.getBounds();
        return t.x + t.width < 0;
      }
      stop() {
        this.sprite.stop();
      }
      play() {
        this.sprite.play();
      }
      set isTutorialEnemy(t) {
        this._isTutorialEnemy = t;
      }
      get isTutorialEnemy() {
        return this._isTutorialEnemy;
      }
    }
    const nq =
      '[PLACEHOLDER:image/webp]',
      aq =
        '[PLACEHOLDER:image/webp]',
      Mt = { PULSE_SPEED: 0.003, SCALE_MIN: 0.9, SCALE_MAX: 1.1, BASE_SCALE: 0.8 };
    class oq extends _ {
      constructor() {
        super();
        V(this, 'sprite');
        V(this, 'glowSprite');
        V(this, '_speed', 0);
        V(this, 'pulseTime', 0);
        V(this, 'debugGraphics');
      }
      async init() {
        const [t, A] = await Promise.all([te.load(nq), te.load(aq)]);
        (this.glowSprite = new re(A)),
          this.glowSprite.anchor.set(0.5, 1),
          this.glowSprite.scale.set(Mt.BASE_SCALE),
          (this.glowSprite.alpha = 0.8),
          this.addChild(this.glowSprite),
          (this.sprite = new re(t)),
          this.sprite.anchor.set(0.5, 1),
          this.sprite.scale.set(Mt.BASE_SCALE),
          this.addChild(this.sprite),
          (this.y = Me - oe.GROUND_Y - 20),
          (this.pulseTime = Math.random() * Math.PI * 2);
      }
      update(t) {
        (this.x -= (this._speed * t) / 1e3), (this.pulseTime += t * Mt.PULSE_SPEED);
        const A = (Math.sin(this.pulseTime) + 1) / 2,
          r = Mt.BASE_SCALE * (Mt.SCALE_MIN + A * (Mt.SCALE_MAX - Mt.SCALE_MIN));
        this.glowSprite.scale.set(r);
      }
      updateDebugGraphics() {
        if (!this.debugGraphics) return;
        const t = this.getHitbox(),
          A = this.toLocal({ x: t.x, y: t.y }),
          r = this.toLocal({ x: t.x + t.width, y: t.y + t.height }),
          s = r.x - A.x,
          n = r.y - A.y;
        this.debugGraphics.clear(),
          this.debugGraphics.rect(A.x, A.y, s, n),
          this.debugGraphics.stroke({ width: 2, color: gr.HITBOX_COLORS.OBSTACLE });
      }
      set speed(t) {
        this._speed = t;
      }
      get speed() {
        return this._speed;
      }
      getHitbox() {
        const t = this.sprite.getBounds(),
          A = Te.OBSTACLE_SHRINK,
          r = t.width * Te.OBSTACLE_OFFSET.X,
          s = t.height * Te.OBSTACLE_OFFSET.Y;
        return new F(t.x + A + r, t.y + A + s, t.width - A * 2, t.height - A * 2);
      }
      isOffScreen() {
        const t = this.sprite.getBounds();
        return t.x + t.width < 0;
      }
    }
    const Mp =
      '[PLACEHOLDER:image/png]',
      Ep =
        '[PLACEHOLDER:image/webp]';
    class lq extends _ {
      constructor() {
        super();
        V(this, 'sprite');
        V(this, '_speed', 0);
        V(this, 'pulseTime', 0);
        V(this, 'baseScale', 0.15);
        V(this, '_collected', !1);
        V(this, '_type', 'dollar');
        V(this, 'debugGraphics');
      }
      async init(t = 0, A = 'dollar') {
        this._type = A;
        const r = A === 'dollar' ? Mp : Ep,
          s = await te.load(r);
        (this.sprite = new re(s)), this.sprite.anchor.set(0.5, 0.5);
        const n = A === 'dollar' ? this.baseScale : this.baseScale * 1.2;
        this.sprite.scale.set(n), this.addChild(this.sprite), (this.y = Me - oe.GROUND_Y - 200 - t);
      }
      get collectibleType() {
        return this._type;
      }
      update(t) {
        if (this._collected) return;
        (this.x -= (this._speed * t) / 1e3), (this.pulseTime += t * Ti.PULSE_SPEED);
        const A = Ti.PULSE_MIN + (Math.sin(this.pulseTime) * 0.5 + 0.5) * (Ti.PULSE_MAX - Ti.PULSE_MIN);
        this.sprite.scale.set(this.baseScale * A), (this.sprite.y = Math.sin(this.pulseTime * 2) * 5);
      }
      updateDebugGraphics() {
        this.debugGraphics &&
          (this.debugGraphics.clear(),
            this.debugGraphics.circle(0, 0, Te.COLLECTIBLE_RADIUS),
            this.debugGraphics.stroke({ width: 2, color: gr.HITBOX_COLORS.COLLECTIBLE }));
      }
      set speed(t) {
        this._speed = t;
      }
      get speed() {
        return this._speed;
      }
      checkCollectionWithHitbox(t) {
        if (this._collected) return !1;
        const A = this.worldTransform.a,
          r = Te.COLLECTIBLE_RADIUS * A,
          s = this.getGlobalPosition(),
          n = Math.max(t.x, Math.min(s.x, t.x + t.width)),
          a = Math.max(t.y, Math.min(s.y, t.y + t.height)),
          l = s.x - n,
          h = s.y - a;
        return Math.sqrt(l * l + h * h) < r;
      }
      checkCollection(t, A) {
        if (this._collected) return !1;
        const r = this.x - t,
          s = this.y - A,
          n = Math.sqrt(r * r + s * s),
          a = Te.COLLECTIBLE_RADIUS;
        return n < a;
      }
      collect() {
        (this._collected = !0), (this.visible = !1);
      }
      get collected() {
        return this._collected;
      }
      isOffScreen() {
        const t = this.getBounds();
        return t.x + t.width < 0;
      }
      getScreenPosition() {
        return { x: this.x, y: this.y };
      }
    }
    const hq =
      '[PLACEHOLDER:image/png]',
      cq =
        '[PLACEHOLDER:image/png]',
      uq =
        '[PLACEHOLDER:image/png]',
      dq =
        '[PLACEHOLDER:image/png]',
      fq =
        '[PLACEHOLDER:image/png]',
      fe = {
        ROPE_SEGMENTS: 10,
        ROPE_LENGTH_FACTOR: 0.3,
        GRAVITY: 0.3,
        DAMPING: 0.95,
        WAVE_SPEED: 0.01,
        TIME_DECAY: 0.15,
        MIN_VELOCITY_THRESHOLD: 0.1,
        MIN_ANIMATION_TIME: 1,
        ROPE_SEGMENT_DISTANCE: 10,
        LEFT_ROPE_OFFSET_X: 0,
        LEFT_ROPE_OFFSET_Y: 0,
        RIGHT_ROPE_OFFSET_X: 20,
        RIGHT_ROPE_OFFSET_Y: -20,
        TAPE_BREAK_OFFSET: -300,
      };
    class pq extends _ {
      constructor() {
        super();
        V(this, 'speed', 0);
        V(this, 'floorPattern');
        V(this, 'leftPole');
        V(this, 'rightPole');
        V(this, 'leftTape');
        V(this, 'rightTape');
        V(this, 'leftRope');
        V(this, 'rightRope');
        V(this, 'leftRopePoints', []);
        V(this, 'rightRopePoints', []);
        V(this, 'leftVelocities', []);
        V(this, 'rightVelocities', []);
        V(this, 'isTapeBroken', !1);
        V(this, 'animationTime', 0);
        V(this, 'isAnimating', !1);
        V(this, 'leftTapeTexture');
        V(this, 'rightTapeTexture');
        this.sortableChildren = !0;
      }
      async init() {
        const [t, A, r, s, n] = await Promise.all([te.load(hq), te.load(cq), te.load(uq), te.load(dq), te.load(fq)]);
        (this.leftTapeTexture = s), (this.rightTapeTexture = n);
        const a = Me - oe.GROUND_Y;
        (this.floorPattern = new re(t)),
          this.floorPattern.anchor.set(0.5, 0.5),
          (this.floorPattern.x = 0),
          (this.floorPattern.y = a - 80),
          this.floorPattern.scale.set(2),
          (this.floorPattern.zIndex = 5),
          this.addChild(this.floorPattern),
          (this.leftPole = new re(A)),
          this.leftPole.anchor.set(0.5, 1),
          (this.leftPole.rotation = -Math.PI / 2),
          (this.leftPole.x = -370),
          (this.leftPole.y = a - 182),
          this.leftPole.scale.set(1),
          (this.leftPole.zIndex = 8),
          this.addChild(this.leftPole),
          (this.rightPole = new re(r)),
          this.rightPole.anchor.set(0.5, 1),
          (this.rightPole.rotation = -Math.PI / 2),
          (this.rightPole.x = -235),
          (this.rightPole.y = a - 95),
          this.rightPole.scale.set(1),
          (this.rightPole.zIndex = 12),
          this.addChild(this.rightPole),
          (this.leftTape = new re(s)),
          this.leftTape.anchor.set(0, 0),
          (this.leftTape.rotation = 0.4),
          (this.leftTape.x = this.leftPole.x),
          (this.leftTape.y = this.leftPole.y - 50),
          this.leftTape.scale.set(1.8, 1),
          (this.leftTape.zIndex = 9),
          this.addChild(this.leftTape),
          (this.rightTape = new re(n)),
          this.rightTape.anchor.set(0, 0),
          (this.rightTape.rotation = -2.5),
          (this.rightTape.x = this.rightPole.x - 20),
          (this.rightTape.y = this.rightPole.y - 46),
          this.rightTape.scale.set(1.8, 1),
          (this.rightTape.zIndex = 13),
          this.addChild(this.rightTape);
      }
      update(t) {
        (this.x -= (this.speed * t) / 1e3), this.isAnimating && this.updateRopeAnimation();
      }
      breakTape() {
        this.isTapeBroken ||
          !this.leftTapeTexture ||
          !this.rightTapeTexture ||
          ((this.isTapeBroken = !0),
            (this.leftTape.visible = !1),
            (this.rightTape.visible = !1),
            this.createRopeFromTape(this.leftTape, this.leftTapeTexture, this.leftRopePoints, 'left'),
            this.createRopeFromTape(this.rightTape, this.rightTapeTexture, this.rightRopePoints, 'right'),
            (this.leftVelocities = this.leftRopePoints.map(() => ({ x: 0, y: 0 }))),
            (this.rightVelocities = this.rightRopePoints.map(() => ({ x: 0, y: 0 }))),
            (this.animationTime = 0),
            (this.isAnimating = !0));
      }
      createRopeFromTape(t, A, r, s) {
        r.length = 0;
        const n = A.width * Math.abs(t.scale.x),
          a = A.height * Math.abs(t.scale.y),
          l = Math.cos(t.rotation),
          h = Math.sin(t.rotation),
          u = -t.anchor.x * n,
          o = -t.anchor.y * a,
          c = u * l - o * h,
          d = u * h + o * l,
          f = s === 'left' ? fe.LEFT_ROPE_OFFSET_X : fe.RIGHT_ROPE_OFFSET_X,
          g = s === 'left' ? fe.LEFT_ROPE_OFFSET_Y : fe.RIGHT_ROPE_OFFSET_Y;
        for (let m = 0; m < fe.ROPE_SEGMENTS; m++) {
          const q = (m / (fe.ROPE_SEGMENTS - 1)) * n * fe.ROPE_LENGTH_FACTOR,
            E = 0,
            b = q * l - E * h,
            T = q * h + E * l,
            I = t.x + c + b + f,
            B = t.y + d + T + g;
          r.push(new H(I, B));
        }
        const p = new Pf({ texture: A, points: r });
        (p.zIndex = t.zIndex), this.addChild(p), s === 'left' ? (this.leftRope = p) : (this.rightRope = p);
      }
      updateRopeAnimation() {
        (this.animationTime += 0.05),
          this.animateRopePoints(this.leftRopePoints, this.leftVelocities),
          this.animateRopePoints(this.rightRopePoints, this.rightVelocities);
        let t = 0,
          A = 0;
        [...this.leftVelocities, ...this.rightVelocities].forEach((s) => {
          const n = Math.sqrt(s.x * s.x + s.y * s.y);
          (t += n), A++;
        }),
          (A > 0 ? t / A : 0) < fe.MIN_VELOCITY_THRESHOLD &&
          this.animationTime > fe.MIN_ANIMATION_TIME &&
          (this.isAnimating = !1);
      }
      animateRopePoints(t, A) {
        const r = Math.exp(-this.animationTime * fe.TIME_DECAY),
          s = fe.GRAVITY * r,
          n = r;
        for (let a = 1; a < t.length; a++) {
          const l = t[a],
            h = A[a];
          h.y += s;
          const u = Math.sin(this.animationTime + a * fe.WAVE_SPEED) * 2 * n;
          if (((h.x += u * 0.1), (h.x *= fe.DAMPING), (h.y *= fe.DAMPING), (l.x += h.x), (l.y += h.y), a > 0)) {
            const o = t[a - 1],
              c = l.x - o.x,
              d = l.y - o.y,
              f = Math.sqrt(c * c + d * d),
              g = fe.ROPE_SEGMENT_DISTANCE;
            if (f > 0) {
              const p = (f - g) / f,
                m = c * p * 0.5,
                S = d * p * 0.5;
              (l.x -= m), (l.y -= S);
            }
          }
        }
      }
      isOffScreen() {
        const t = this.getBounds();
        return t.x + t.width < 0;
      }
      getHitbox() {
        const t = Me - oe.GROUND_Y;
        return { x: this.x - 50, y: t - 200, width: 100, height: 200 };
      }
      get tapeBroken() {
        return this.isTapeBroken;
      }
      get tapeBreakX() {
        return this.x + fe.TAPE_BREAK_OFFSET;
      }
      destroy() {
        this.leftRope && (this.removeChild(this.leftRope), this.leftRope.destroy(), (this.leftRope = void 0)),
          this.rightRope && (this.removeChild(this.rightRope), this.rightRope.destroy(), (this.rightRope = void 0)),
          (this.leftRopePoints.length = 0),
          (this.rightRopePoints.length = 0),
          (this.leftVelocities.length = 0),
          (this.rightVelocities.length = 0),
          super.destroy();
      }
    }
    const gq =
      '[PLACEHOLDER:image/webp]',
      mq =
        '[PLACEHOLDER:image/png]',
      Sq =
        '[PLACEHOLDER:image/png]',
      qq =
        '[PLACEHOLDER:image/png]',
      Mq =
        '[PLACEHOLDER:image/png]',
      Eq =
        '[PLACEHOLDER:image/png]',
      Vq =
        '[PLACEHOLDER:image/png]';
    class Tq extends _ {
      constructor() {
        super();
        V(this, 'backgroundTiles', []);
        V(this, 'bgTexture');
        V(this, 'bgScale', 1);
        V(this, 'treesPool', []);
        V(this, 'lampsPool', []);
        V(this, 'bushesPool', []);
        // V(this, 'treeTextures', []);
        V(this, 'lampTexture');
        V(this, 'bushTextures', []);
        V(this, 'isPaused', !1);
        V(this, 'scrollOffset', 0);
        V(this, 'roadY', Me - oe.GROUND_Y);
        V(this, 'LAMP_SPACING', 800);
        V(this, 'TREE_MIN_SPACING', 300);
        V(this, 'TREE_MAX_SPACING', 500);
        V(this, 'SCREEN_BUFFER', 1200);
        this.sortableChildren = !0;
      }
      async init() {
        try {
          await this.loadTextures(), this.createTiledBackground(), this.createPropPools();
        } catch {
          await this.createFallbackBackground();
        }
      }
      async loadTextures() {
        (this.bgTexture = await te.load(gq)),
          (this.treeTextures = await te.load(Eq)),
          // (this.treeTextures = [await te.load(Eq), await te.load(Vq)]),
          (this.lampTexture = await te.load(Mq)),
          (this.bushTextures = [await te.load(mq), await te.load(Sq), await te.load(qq)]);
      }
      createTiledBackground() {
        const t = $e / this.bgTexture.width,
          A = Me / this.bgTexture.height;
        this.bgScale = Math.max(t, A);
        const r = this.bgTexture.width * this.bgScale,
          s = (Me - this.bgTexture.height * this.bgScale) / 2,
          n = 6;
        for (let a = 0; a < n; a++) {
          const l = new re(this.bgTexture);
          (l.y = s),
            (l.zIndex = me.FAR_BACKGROUND),
            l.anchor.set(0, 0),
            a % 2 === 1
              ? (l.scale.set(-this.bgScale, this.bgScale), (l.x = (a + 1) * r - r))
              : (l.scale.set(this.bgScale, this.bgScale), (l.x = a * r - r)),
            this.addChild(l),
            this.backgroundTiles.push(l);
        }
      }
      createPropPools() {
        const t = $e * 2 + this.SCREEN_BUFFER * 2,
          A = Math.ceil(t / this.LAMP_SPACING) + 1;
        for (let s = 0; s < A; s++) {
          const n = new re(this.lampTexture);
          n.anchor.set(0.5, 0), (n.y = 50), n.scale.set(1.8), (n.zIndex = me.NEAR_BACKGROUND);
          const a = s * this.LAMP_SPACING - this.SCREEN_BUFFER;
          (n.x = a),
            this.addChild(n),
            this.lampsPool.push({ sprite: n, type: 'lamp', baseX: a, speedMultiplier: Ye.PARALLAX.GROUND });
        }
        let r = -this.SCREEN_BUFFER;
        for (; r < t;) {
          const s = Math.floor(Math.random() * this.treeTextures.length),
            n = new re(this.treeTextures[s]);
          n.anchor.set(0.5, 0),
            (n.y = 0),
            n.scale.set(1.81),
            (n.zIndex = me.MID_BACKGROUND),
            (n.x = r),
            this.addChild(n),
            this.treesPool.push({ sprite: n, type: 'tree', baseX: r, speedMultiplier: Ye.PARALLAX.GROUND }),
            (r += this.TREE_MIN_SPACING + Math.random() * (this.TREE_MAX_SPACING - this.TREE_MIN_SPACING));
        }
        this.createBushGroups(t);
      }
      createBushGroups(t) {
        let s = -this.SCREEN_BUFFER + 100;
        for (; s < t;) {
          const n = Math.random() > 0.3 ? 3 : 2;
          for (let a = 0; a < n; a++) {
            if (a > 0 && Math.random() < 0.2) continue;
            const l = a % this.bushTextures.length,
              h = new re(this.bushTextures[l]);
            h.anchor.set(0.5, 1),
              (h.y = this.roadY - 305),
              h.scale.set(0.45 + Math.random() * 0.15),
              (h.zIndex = me.NEAR_BACKGROUND);
            const u = s + a * (200 / 3) + Math.random() * 30;
            (h.x = u),
              this.addChild(h),
              this.bushesPool.push({ sprite: h, type: 'bush', baseX: u, speedMultiplier: Ye.PARALLAX.GROUND });
          }
          s += 500 + Math.random() * 100;
        }
      }
      async createFallbackBackground() {
        const { Graphics: t } = await QA(
          async () => {
            const { Graphics: s } = await Promise.resolve().then(() => KS);
            return { Graphics: s };
          },
          void 0,
          import.meta.url
        ),
          A = new t();
        A.rect(0, 0, $e * 2, Me), A.fill({ color: 16573654 }), (A.zIndex = me.FAR_BACKGROUND), this.addChild(A);
        const r = new t();
        r.rect(0, Me - 180, $e * 2, 180), r.fill({ color: 4868714 }), (r.zIndex = me.GROUND), this.addChild(r);
      }
      update(t, A = Ye.BASE_SPEED) {
        if (this.isPaused) return;
        const r = (A * t) / 1e3;
        this.scrollOffset += r;
        const s = this.bgTexture.width * this.bgScale,
          n = s * this.backgroundTiles.length;
        for (const h of this.backgroundTiles) (h.x -= r), (h.scale.x < 0 ? h.x - s : h.x) < -s * 2 && (h.x += n);
        this.updatePool(this.lampsPool, r, this.LAMP_SPACING * this.lampsPool.length);
        const a =
          this.treesPool.length > 0
            ? this.treesPool[this.treesPool.length - 1].baseX - this.treesPool[0].baseX + this.TREE_MAX_SPACING
            : $e;
        this.updatePool(this.treesPool, r, a);
        const l =
          this.bushesPool.length > 0 ? this.bushesPool[this.bushesPool.length - 1].baseX - this.bushesPool[0].baseX + 500 : $e;
        this.updatePool(this.bushesPool, r, l);
      }
      updatePool(t, A, r) {
        for (const s of t) (s.sprite.x -= A), s.sprite.x < -this.SCREEN_BUFFER && (s.sprite.x += r + this.SCREEN_BUFFER);
      }
      pause() {
        this.isPaused = !0;
      }
      resume() {
        this.isPaused = !1;
      }
      getScrollOffset() {
        return this.scrollOffset;
      }
      reset() {
        if (((this.scrollOffset = 0), (this.isPaused = !1), this.bgTexture && this.backgroundTiles.length > 0)) {
          const t = this.bgTexture.width * this.bgScale;
          for (let A = 0; A < this.backgroundTiles.length; A++) {
            const r = this.backgroundTiles[A];
            A % 2 === 1 ? (r.x = (A + 1) * t - t) : (r.x = A * t - t);
          }
        }
        for (const t of [...this.lampsPool, ...this.treesPool, ...this.bushesPool]) t.sprite.x = t.baseX;
      }
    }
    class Iq {
      constructor(e) {
        V(this, 'app');
        V(this, 'gameContainer');
        V(this, 'entityContainer');
        V(this, 'parallax');
        V(this, 'player');
        V(this, 'enemies', []);
        V(this, 'obstacles', []);
        V(this, 'collectibles', []);
        V(this, 'finishLine');
        V(this, '_state', ge.LOADING);
        V(this, '_score', Gt.START_BALANCE);
        V(this, '_hp', Yi.MAX_HP);
        V(this, 'spawnIndex', 0);
        V(this, 'distanceTraveled', 0);
        V(this, 'events', new Map());
        V(this, 'isRunning', !1);
        V(this, 'tutorialEnemy', null);
        V(this, 'tutorialTriggered', !1);
        V(this, 'jumpingEnabled', !1);
        V(this, 'TUTORIAL_PAUSE_DISTANCE', 300);
        V(this, 'isDecelerating', !1);
        V(this, 'currentSpeed', Ye.BASE_SPEED);
        V(this, 'DECELERATION_RATE', 0.9);
        V(this, 'MIN_SPEED', 10);
        V(this, 'finishLineSpawned', !1);
        V(this, 'warningLabels', []);
        this.app = e;
      }
      async init() {
        (this.gameContainer = new _()),
          (this.gameContainer.sortableChildren = !0),
          this.app.stage.addChild(this.gameContainer),
          (this.parallax = new Tq()),
          await this.parallax.init(),
          (this.parallax.zIndex = me.FAR_BACKGROUND),
          this.gameContainer.addChild(this.parallax),
          (this.entityContainer = new _()),
          (this.entityContainer.sortableChildren = !0),
          (this.entityContainer.zIndex = me.GROUND),
          this.gameContainer.addChild(this.entityContainer),
          (this.player = new $S()),
          await this.player.init(),
          (this.player.zIndex = me.PLAYER),
          this.entityContainer.addChild(this.player),
          this.setState(ge.INTRO);
      }
      start() {
        this._state === ge.INTRO && ((this.isRunning = !0), this.player.run(), this.setState(ge.RUNNING), this.emit('start'));
      }
      handleTap() {
        switch (this._state) {
          case ge.INTRO:
            this.start();
            break;
          case ge.PAUSED:
            this.resumeFromTutorial();
            break;
          case ge.RUNNING:
            this.jumpingEnabled && this.player.isOnGround && !this.finishLineSpawned && (this.player.jump(), this.emit('jump'));
            break;
        }
      }
      resumeFromTutorial() {
        (this.isRunning = !0),
          (this.jumpingEnabled = !0),
          this.player.run(),
          this.parallax.resume(),
          this.enemies.forEach((e) => e.play()),
          this.setState(ge.RUNNING),
          this.player.jump(),
          this.emit('jump'),
          this.emit('tutorialComplete');
      }
      update(e) {
        this.player.update(e),
          this.isRunning &&
          (this.isDecelerating &&
            ((this.currentSpeed *= this.DECELERATION_RATE),
              this.currentSpeed < this.MIN_SPEED &&
              ((this.currentSpeed = 0), (this.isDecelerating = !1), setTimeout(() => this.handleWin(), 500))),
            this.parallax.update(e, this.currentSpeed),
            (this.distanceTraveled += (this.currentSpeed * e) / 1e3),
            this.checkSpawns(),
            this.updateEntities(e),
            this.updateWarningLabels(e),
            this.checkTutorialTrigger(),
            this.finishLine && !this.isDecelerating && this.player.x >= this.finishLine.tapeBreakX && this.startDeceleration(),
            this.checkCollisions(),
            this.cleanupEntities());
      }
      checkSpawns() {
        for (; this.spawnIndex < Gl.length;) {
          const e = Gl[this.spawnIndex],
            t = e.distance * yt;
          if (this.distanceTraveled >= t - yt) this.spawnEntity(e), this.spawnIndex++;
          else break;
        }
      }
      async spawnEntity(e) {
        const t = yt + yt * 0.5;
        switch (e.type) {
          case 'enemy': {
            const A = new sq();
            await A.init(),
              (A.x = t),
              (A.speed = Ye.BASE_SPEED),
              (A.zIndex = me.ENEMIES),
              this.enemies.push(A),
              this.entityContainer.addChild(A),
              e.pauseForTutorial && !this.tutorialTriggered && ((A.isTutorialEnemy = !0), (this.tutorialEnemy = A));
            break;
          }
          case 'obstacle': {
            const A = new oq();
            if (
              (await A.init(),
                (A.x = t),
                (A.speed = Ye.BASE_SPEED),
                (A.zIndex = me.OBSTACLES),
                this.obstacles.push(A),
                this.entityContainer.addChild(A),
                e.warningLabel)
            ) {
              const r = Me - oe.GROUND_Y - 200;
              this.createWarningLabel(t, r);
            }
            break;
          }
          case 'collectible': {
            const A = new lq(),
              r = Math.random() < 0.6 ? 'dollar' : 'paypalCard';
            await A.init(e.yOffset || 0, r),
              (A.x = t),
              (A.speed = Ye.BASE_SPEED),
              (A.zIndex = me.COLLECTIBLES),
              this.collectibles.push(A),
              this.entityContainer.addChild(A);
            break;
          }
          case 'finish': {
            const A = new pq();
            await A.init(),
              (A.x = t),
              (A.speed = Ye.BASE_SPEED),
              (A.zIndex = me.FINISH_LINE),
              (this.finishLine = A),
              this.entityContainer.addChild(A),
              (this.finishLineSpawned = !0);
            break;
          }
        }
      }
      startDeceleration() {
        (this.isDecelerating = !0), this.finishLine && this.finishLine.breakTape(), this.emit('crossedFinish');
      }
      checkTutorialTrigger() {
        if (!this.tutorialEnemy || this.tutorialTriggered) return;
        this.tutorialEnemy.x - this.player.x <= this.TUTORIAL_PAUSE_DISTANCE && this.triggerTutorialPause('enemy');
      }
      triggerTutorialPause(e) {
        (this.tutorialTriggered = !0),
          (this.isRunning = !1),
          this.player.idle(),
          this.parallax.pause(),
          this.enemies.forEach((t) => t.stop()),
          this.setState(ge.PAUSED),
          this.emit('showTutorial', { type: e });
      }
      updateEntities(e) {
        this.enemies.forEach((t) => {
          (t.speed = this.currentSpeed), t.update(e);
        }),
          this.obstacles.forEach((t) => {
            (t.speed = this.currentSpeed), t.update(e);
          }),
          this.collectibles.forEach((t) => {
            (t.speed = this.currentSpeed), t.update(e);
          }),
          this.finishLine && ((this.finishLine.speed = this.currentSpeed), this.finishLine.update(e));
      }
      checkCollisions() {
        const e = this.player.getHitbox();
        for (const t of this.enemies) {
          if (this.player.isInvincible) break;
          const A = t.getHitbox();
          if (this.rectanglesIntersect(e, A)) {
            this.handlePlayerHit();
            break;
          }
        }
        for (const t of this.obstacles) {
          if (this.player.isInvincible) break;
          const A = t.getHitbox();
          if (this.rectanglesIntersect(e, A)) {
            this.handlePlayerHit();
            break;
          }
        }
        for (let t = 0; t < this.collectibles.length; t++) {
          const A = this.collectibles[t];
          A.collected || (A.checkCollectionWithHitbox(e) && this.collectItem(A));
        }
      }
      rectanglesIntersect(e, t) {
        return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
      }
      handlePlayerHit() {
        this._hp--, this.player.hurt(), this.emit('hit', { hp: this._hp }), this._hp <= 0 && this.handleLose();
      }
      collectItem(e) {
        const t = e.getScreenPosition(),
          A = e.collectibleType;
        e.collect();
        let r;
        A === 'paypalCard'
          ? (r = Math.floor(Math.random() * (Gt.PAYPAL_CARD_MAX - Gt.PAYPAL_CARD_MIN + 1)) + Gt.PAYPAL_CARD_MIN)
          : (r = Gt.DOLLAR_VALUE),
          (this._score += r),
          this.emit('collect', { score: this._score, from: t, collectibleType: A });
      }
      handleWin() {
        (this.isRunning = !1),
          this.player.idle(),
          this.parallax.pause(),
          this.enemies.forEach((e) => e.stop()),
          this.setState(ge.END_WIN),
          this.emit('win', { score: this._score });
      }
      handleLose() {
        (this.isRunning = !1),
          this.player.idle(!0),
          this.parallax.pause(),
          this.enemies.forEach((e) => e.stop()),
          this.setState(ge.END_LOSE),
          this.emit('lose', { score: this._score });
      }
      cleanupEntities() {
        (this.enemies = this.enemies.filter((e) => (e.isOffScreen() ? (this.entityContainer.removeChild(e), !1) : !0))),
          (this.obstacles = this.obstacles.filter((e) => (e.isOffScreen() ? (this.entityContainer.removeChild(e), !1) : !0))),
          (this.collectibles = this.collectibles.filter((e) => {
            const t = e.isOffScreen(),
              A = e.collected;
            return t || A ? (this.entityContainer.removeChild(e), !1) : !0;
          })),
          this.finishLine &&
          this.finishLine.isOffScreen() &&
          (this.entityContainer.removeChild(this.finishLine), (this.finishLine = void 0));
      }
      setState(e) {
        const t = this._state;
        (this._state = e), this.emit('stateChange', { from: t, to: e });
      }
      createWarningLabel(e, t) {
        const A = new _();
        A.zIndex = me.WARNING_LABEL;
        const r = new tt({
          fontFamily: 'GameFont, sans-serif',
          fontSize: 32,
          fontWeight: '900',
          fill: '#ff0000',
          stroke: { color: '#000000', width: 4 },
          align: 'center',
        }),
          s = new id({ text: ae.warnings.avoid, style: r });
        s.anchor.set(0.5, 0.5);
        const n = 16,
          a = new Ut();
        a.roundRect(-s.width / 2 - n, -s.height / 2 - n / 2, s.width + n * 2, s.height + n, 8),
          a.fill({ color: 16770560, alpha: 0.95 }),
          a.stroke({ width: 4, color: 16763904 }),
          A.addChild(a),
          A.addChild(s),
          (A.x = e),
          (A.y = t),
          this.entityContainer.addChild(A),
          this.warningLabels.push({ container: A, gameX: e });
      }
      updateWarningLabels(e) {
        const t = this.currentSpeed;
        this.warningLabels = this.warningLabels.filter((A) => {
          (A.gameX -= (t * e) / 1e3), (A.container.x = A.gameX);
          const r = 1 + Math.sin(Date.now() * 0.008) * 0.1;
          return A.container.scale.set(r), A.gameX < -200 ? (this.entityContainer.removeChild(A.container), !1) : !0;
        });
      }
      pause() {
        this._state === ge.RUNNING && ((this.isRunning = !1), this.parallax.pause());
      }
      resume() {
        this._state === ge.RUNNING && ((this.isRunning = !0), this.parallax.resume());
      }
      reset() {
        (this._state = ge.INTRO),
          (this._score = Gt.START_BALANCE),
          (this._hp = Yi.MAX_HP),
          (this.spawnIndex = 0),
          (this.distanceTraveled = 0),
          (this.isRunning = !1),
          (this.tutorialEnemy = null),
          (this.tutorialTriggered = !1),
          (this.jumpingEnabled = !1),
          (this.finishLineSpawned = !1),
          (this.isDecelerating = !1),
          (this.currentSpeed = Ye.BASE_SPEED),
          this.parallax.reset(),
          this.player.reset(),
          this.enemies.forEach((e) => this.entityContainer.removeChild(e)),
          this.obstacles.forEach((e) => this.entityContainer.removeChild(e)),
          this.collectibles.forEach((e) => this.entityContainer.removeChild(e)),
          this.warningLabels.forEach((e) => this.entityContainer.removeChild(e.container)),
          this.finishLine && (this.entityContainer.removeChild(this.finishLine), (this.finishLine = void 0)),
          (this.enemies = []),
          (this.obstacles = []),
          (this.collectibles = []),
          (this.warningLabels = []),
          this.emit('reset');
      }
      on(e, t) {
        this.events.has(e) || this.events.set(e, []), this.events.get(e).push(t);
      }
      off(e, t) {
        const A = this.events.get(e);
        if (A) {
          const r = A.indexOf(t);
          r !== -1 && A.splice(r, 1);
        }
      }
      emit(e, t) {
        const A = this.events.get(e);
        A && A.forEach((r) => r(t));
      }
      get state() {
        return this._state;
      }
      get score() {
        return this._score;
      }
      get hp() {
        return this._hp;
      }
    }
    const bq =
      '[PLACEHOLDER:image/png]',
      yq =
        '[PLACEHOLDER:image/png]',
      xq =
        '[PLACEHOLDER:image/png]',
      vq =
        '[PLACEHOLDER:image/png]',
      Cq =
        '[PLACEHOLDER:image/png]',
      Uq =
        '[PLACEHOLDER:image/png]',
      G = {
        PARTICLE_COUNT: 50,
        LIFETIME: 5e3,
        FADE_START: 0.7,
        SCALE_MIN: 0.8,
        SCALE_MAX: 1.5,
        BURST_SPEED_MIN: 12,
        BURST_SPEED_MAX: 20,
        BURST_ANGLE_SPREAD: 30,
        SIDE_MARGIN: 50,
        SIDE_SPAWN_HEIGHT: 0.7,
        SIDE_SPAWN_SPREAD_Y: 200,
        SPAWN_SPREAD_X: 100,
        SPAWN_SPREAD_Y: 50,
        GRAVITY: 0.05,
        AIR_RESISTANCE: 0.998,
        WIND_X: 0,
        ROTATION_SPEED_MIN: 0.02,
        ROTATION_SPEED_MAX: 0.1,
      };
    class kq extends _ {
      constructor() {
        super(...arguments);
        V(this, 'particles', []);
        V(this, 'textures', []);
        V(this, 'isActive', !1);
      }
      async init() {
        const t = [bq, yq, xq, vq, Cq, Uq];
        for (const A of t) {
          const r = await te.load(A);
          this.textures.push(r);
        }
      }
      burst(t, A, r = -90) {
        const s = (r * Math.PI) / 180,
          n = (G.BURST_ANGLE_SPREAD * Math.PI) / 180;
        for (let a = 0; a < G.PARTICLE_COUNT; a++) {
          const l = this.textures[Math.floor(Math.random() * this.textures.length)],
            h = new re(l);
          h.anchor.set(0.5);
          const u = G.SCALE_MIN + Math.random() * (G.SCALE_MAX - G.SCALE_MIN);
          h.scale.set(u),
            (h.x = t + (Math.random() - 0.5) * G.SPAWN_SPREAD_X),
            (h.y = A + (Math.random() - 0.5) * G.SPAWN_SPREAD_Y);
          const o = s + (Math.random() - 0.5) * n,
            c = G.BURST_SPEED_MIN + Math.random() * (G.BURST_SPEED_MAX - G.BURST_SPEED_MIN),
            d = Math.cos(o) * c,
            f = Math.sin(o) * c,
            g = G.ROTATION_SPEED_MIN + Math.random() * (G.ROTATION_SPEED_MAX - G.ROTATION_SPEED_MIN),
            p = (Math.random() > 0.5 ? 1 : -1) * g;
          this.addChild(h), this.particles.push({ sprite: h, vx: d, vy: f, rotation: p, lifetime: 0, maxLifetime: G.LIFETIME });
        }
        this.isActive || ((this.isActive = !0), this.animate());
      }
      burstFromSides(t, A) {
        const r = A * G.SIDE_SPAWN_HEIGHT,
          s = -70,
          n = G.SIDE_MARGIN,
          a = -110,
          l = t - G.SIDE_MARGIN;
        this.burstSide(n, r, s), this.burstSide(l, r, a);
      }
      burstSide(t, A, r) {
        const s = (r * Math.PI) / 180,
          n = (G.BURST_ANGLE_SPREAD * Math.PI) / 180;
        for (let a = 0; a < G.PARTICLE_COUNT; a++) {
          const l = this.textures[Math.floor(Math.random() * this.textures.length)],
            h = new re(l);
          h.anchor.set(0.5);
          const u = G.SCALE_MIN + Math.random() * (G.SCALE_MAX - G.SCALE_MIN);
          h.scale.set(u), (h.x = t), (h.y = A + (Math.random() - 0.5) * G.SIDE_SPAWN_SPREAD_Y);
          const o = s + (Math.random() - 0.5) * n,
            c = G.BURST_SPEED_MIN + Math.random() * (G.BURST_SPEED_MAX - G.BURST_SPEED_MIN),
            d = Math.cos(o) * c,
            f = Math.sin(o) * c,
            g = G.ROTATION_SPEED_MIN + Math.random() * (G.ROTATION_SPEED_MAX - G.ROTATION_SPEED_MIN),
            p = (Math.random() > 0.5 ? 1 : -1) * g;
          this.addChild(h), this.particles.push({ sprite: h, vx: d, vy: f, rotation: p, lifetime: 0, maxLifetime: G.LIFETIME });
        }
        this.isActive || ((this.isActive = !0), this.animate());
      }
      animate() {
        let t = performance.now();
        const A = () => {
          if (this.particles.length === 0) {
            this.isActive = !1;
            return;
          }
          const r = performance.now(),
            s = r - t;
          t = r;
          for (let n = this.particles.length - 1; n >= 0; n--) {
            const a = this.particles[n],
              { sprite: l } = a;
            if (((a.lifetime += s), a.lifetime >= a.maxLifetime)) {
              this.removeChild(l), l.destroy(), this.particles.splice(n, 1);
              continue;
            }
            (a.vy += G.GRAVITY),
              (a.vx += G.WIND_X),
              (a.vx *= G.AIR_RESISTANCE),
              (a.vy *= G.AIR_RESISTANCE),
              (l.x += a.vx),
              (l.y += a.vy),
              (l.rotation += a.rotation);
            const h = a.lifetime / a.maxLifetime;
            if (h > G.FADE_START) {
              const u = (h - G.FADE_START) / (1 - G.FADE_START);
              l.alpha = 1 - u;
            }
          }
          requestAnimationFrame(A);
        };
        A();
      }
      clear() {
        this.particles.forEach((t) => {
          this.removeChild(t.sprite), t.sprite.destroy();
        }),
          (this.particles = []),
          (this.isActive = !1);
      }
      destroy() {
        this.clear(), super.destroy();
      }
    }
    var ts = {};
      /*!
       *  howler.js v2.2.4
       *  howlerjs.com
       *
       *  (c) 2013-2020, James Simpson of GoldFire Studios
       *  goldfirestudios.com
       *
       *  MIT License
       */ var Wl;
    function Rq() {
      return (
        Wl ||
        ((Wl = 1),
          (function (i) {
            (function () {
              var e = function () {
                this.init();
              };
              e.prototype = {
                init: function () {
                  var o = this || t;
                  return (
                    (o._counter = 1e3),
                    (o._html5AudioPool = []),
                    (o.html5PoolSize = 10),
                    (o._codecs = {}),
                    (o._howls = []),
                    (o._muted = !1),
                    (o._volume = 1),
                    (o._canPlayEvent = 'canplaythrough'),
                    (o._navigator = typeof window < 'u' && window.navigator ? window.navigator : null),
                    (o.masterGain = null),
                    (o.noAudio = !1),
                    (o.usingWebAudio = !0),
                    (o.autoSuspend = !0),
                    (o.ctx = null),
                    (o.autoUnlock = !0),
                    o._setup(),
                    o
                  );
                },
                volume: function (o) {
                  var c = this || t;
                  if (((o = parseFloat(o)), c.ctx || u(), typeof o < 'u' && o >= 0 && o <= 1)) {
                    if (((c._volume = o), c._muted)) return c;
                    c.usingWebAudio && c.masterGain.gain.setValueAtTime(o, t.ctx.currentTime);
                    for (var d = 0; d < c._howls.length; d++)
                      if (!c._howls[d]._webAudio)
                        for (var f = c._howls[d]._getSoundIds(), g = 0; g < f.length; g++) {
                          var p = c._howls[d]._soundById(f[g]);
                          p && p._node && (p._node.volume = p._volume * o);
                        }
                    return c;
                  }
                  return c._volume;
                },
                mute: function (o) {
                  var c = this || t;
                  c.ctx || u(),
                    (c._muted = o),
                    c.usingWebAudio && c.masterGain.gain.setValueAtTime(o ? 0 : c._volume, t.ctx.currentTime);
                  for (var d = 0; d < c._howls.length; d++)
                    if (!c._howls[d]._webAudio)
                      for (var f = c._howls[d]._getSoundIds(), g = 0; g < f.length; g++) {
                        var p = c._howls[d]._soundById(f[g]);
                        p && p._node && (p._node.muted = o ? !0 : p._muted);
                      }
                  return c;
                },
                stop: function () {
                  for (var o = this || t, c = 0; c < o._howls.length; c++) o._howls[c].stop();
                  return o;
                },
                unload: function () {
                  for (var o = this || t, c = o._howls.length - 1; c >= 0; c--) o._howls[c].unload();
                  return o.usingWebAudio && o.ctx && typeof o.ctx.close < 'u' && (o.ctx.close(), (o.ctx = null), u()), o;
                },
                codecs: function (o) {
                  return (this || t)._codecs[o.replace(/^x-/, '')];
                },
                _setup: function () {
                  var o = this || t;
                  if (((o.state = (o.ctx && o.ctx.state) || 'suspended'), o._autoSuspend(), !o.usingWebAudio))
                    if (typeof Audio < 'u')
                      try {
                        var c = new Audio();
                        typeof c.oncanplaythrough > 'u' && (o._canPlayEvent = 'canplay');
                      } catch {
                        o.noAudio = !0;
                      }
                    else o.noAudio = !0;
                  try {
                    var c = new Audio();
                    c.muted && (o.noAudio = !0);
                  } catch { }
                  return o.noAudio || o._setupCodecs(), o;
                },
                _setupCodecs: function () {
                  var o = this || t,
                    c = null;
                  try {
                    c = typeof Audio < 'u' ? new Audio() : null;
                  } catch {
                    return o;
                  }
                  if (!c || typeof c.canPlayType != 'function') return o;
                  var d = c.canPlayType('audio/mpeg;').replace(/^no$/, ''),
                    f = o._navigator ? o._navigator.userAgent : '',
                    g = f.match(/OPR\/(\d+)/g),
                    p = g && parseInt(g[0].split('/')[1], 10) < 33,
                    m = f.indexOf('Safari') !== -1 && f.indexOf('Chrome') === -1,
                    S = f.match(/Version\/(.*?) /),
                    q = m && S && parseInt(S[1], 10) < 15;
                  return (
                    (o._codecs = {
                      mp3: !!(!p && (d || c.canPlayType('audio/mp3;').replace(/^no$/, ''))),
                      mpeg: !!d,
                      opus: !!c.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
                      ogg: !!c.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
                      oga: !!c.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
                      wav: !!(c.canPlayType('audio/wav; codecs="1"') || c.canPlayType('audio/wav')).replace(/^no$/, ''),
                      aac: !!c.canPlayType('audio/aac;').replace(/^no$/, ''),
                      caf: !!c.canPlayType('audio/x-caf;').replace(/^no$/, ''),
                      m4a: !!(
                        c.canPlayType('audio/x-m4a;') ||
                        c.canPlayType('audio/m4a;') ||
                        c.canPlayType('audio/aac;')
                      ).replace(/^no$/, ''),
                      m4b: !!(
                        c.canPlayType('audio/x-m4b;') ||
                        c.canPlayType('audio/m4b;') ||
                        c.canPlayType('audio/aac;')
                      ).replace(/^no$/, ''),
                      mp4: !!(
                        c.canPlayType('audio/x-mp4;') ||
                        c.canPlayType('audio/mp4;') ||
                        c.canPlayType('audio/aac;')
                      ).replace(/^no$/, ''),
                      weba: !!(!q && c.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
                      webm: !!(!q && c.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
                      dolby: !!c.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
                      flac: !!(c.canPlayType('audio/x-flac;') || c.canPlayType('audio/flac;')).replace(/^no$/, ''),
                    }),
                    o
                  );
                },
                _unlockAudio: function () {
                  var o = this || t;
                  if (!(o._audioUnlocked || !o.ctx)) {
                    (o._audioUnlocked = !1),
                      (o.autoUnlock = !1),
                      !o._mobileUnloaded && o.ctx.sampleRate !== 44100 && ((o._mobileUnloaded = !0), o.unload()),
                      (o._scratchBuffer = o.ctx.createBuffer(1, 1, 22050));
                    var c = function (d) {
                      for (; o._html5AudioPool.length < o.html5PoolSize;)
                        try {
                          var f = new Audio();
                          (f._unlocked = !0), o._releaseHtml5Audio(f);
                        } catch {
                          o.noAudio = !0;
                          break;
                        }
                      for (var g = 0; g < o._howls.length; g++)
                        if (!o._howls[g]._webAudio)
                          for (var p = o._howls[g]._getSoundIds(), m = 0; m < p.length; m++) {
                            var S = o._howls[g]._soundById(p[m]);
                            S && S._node && !S._node._unlocked && ((S._node._unlocked = !0), S._node.load());
                          }
                      o._autoResume();
                      var q = o.ctx.createBufferSource();
                      (q.buffer = o._scratchBuffer),
                        q.connect(o.ctx.destination),
                        typeof q.start > 'u' ? q.noteOn(0) : q.start(0),
                        typeof o.ctx.resume == 'function' && o.ctx.resume(),
                        (q.onended = function () {
                          q.disconnect(0),
                            (o._audioUnlocked = !0),
                            document.removeEventListener('touchstart', c, !0),
                            document.removeEventListener('touchend', c, !0),
                            document.removeEventListener('click', c, !0),
                            document.removeEventListener('keydown', c, !0);
                          for (var E = 0; E < o._howls.length; E++) o._howls[E]._emit('unlock');
                        });
                    };
                    return (
                      document.addEventListener('touchstart', c, !0),
                      document.addEventListener('touchend', c, !0),
                      document.addEventListener('click', c, !0),
                      document.addEventListener('keydown', c, !0),
                      o
                    );
                  }
                },
                _obtainHtml5Audio: function () {
                  var o = this || t;
                  if (o._html5AudioPool.length) return o._html5AudioPool.pop();
                  var c = new Audio().play();
                  return (
                    c &&
                    typeof Promise < 'u' &&
                    (c instanceof Promise || typeof c.then == 'function') &&
                    c.catch(function () { }),
                    new Audio()
                  );
                },
                _releaseHtml5Audio: function (o) {
                  var c = this || t;
                  return o._unlocked && c._html5AudioPool.push(o), c;
                },
                _autoSuspend: function () {
                  var o = this;
                  if (!(!o.autoSuspend || !o.ctx || typeof o.ctx.suspend > 'u' || !t.usingWebAudio)) {
                    for (var c = 0; c < o._howls.length; c++)
                      if (o._howls[c]._webAudio) {
                        for (var d = 0; d < o._howls[c]._sounds.length; d++) if (!o._howls[c]._sounds[d]._paused) return o;
                      }
                    return (
                      o._suspendTimer && clearTimeout(o._suspendTimer),
                      (o._suspendTimer = setTimeout(function () {
                        if (o.autoSuspend) {
                          (o._suspendTimer = null), (o.state = 'suspending');
                          var f = function () {
                            (o.state = 'suspended'), o._resumeAfterSuspend && (delete o._resumeAfterSuspend, o._autoResume());
                          };
                          o.ctx.suspend().then(f, f);
                        }
                      }, 3e4)),
                      o
                    );
                  }
                },
                _autoResume: function () {
                  var o = this;
                  if (!(!o.ctx || typeof o.ctx.resume > 'u' || !t.usingWebAudio))
                    return (
                      o.state === 'running' && o.ctx.state !== 'interrupted' && o._suspendTimer
                        ? (clearTimeout(o._suspendTimer), (o._suspendTimer = null))
                        : o.state === 'suspended' || (o.state === 'running' && o.ctx.state === 'interrupted')
                          ? (o.ctx.resume().then(function () {
                            o.state = 'running';
                            for (var c = 0; c < o._howls.length; c++) o._howls[c]._emit('resume');
                          }),
                            o._suspendTimer && (clearTimeout(o._suspendTimer), (o._suspendTimer = null)))
                          : o.state === 'suspending' && (o._resumeAfterSuspend = !0),
                      o
                    );
                },
              };
              var t = new e(),
                A = function (o) {
                  var c = this;
                  !o.src || o.src.length === 0 || c.init(o);
                };
              A.prototype = {
                init: function (o) {
                  var c = this;
                  return (
                    t.ctx || u(),
                    (c._autoplay = o.autoplay || !1),
                    (c._format = typeof o.format != 'string' ? o.format : [o.format]),
                    (c._html5 = o.html5 || !1),
                    (c._muted = o.mute || !1),
                    (c._loop = o.loop || !1),
                    (c._pool = o.pool || 5),
                    (c._preload = typeof o.preload == 'boolean' || o.preload === 'metadata' ? o.preload : !0),
                    (c._rate = o.rate || 1),
                    (c._sprite = o.sprite || {}),
                    (c._src = typeof o.src != 'string' ? o.src : [o.src]),
                    (c._volume = o.volume !== void 0 ? o.volume : 1),
                    (c._xhr = {
                      method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
                      headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
                      withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : !1,
                    }),
                    (c._duration = 0),
                    (c._state = 'unloaded'),
                    (c._sounds = []),
                    (c._endTimers = {}),
                    (c._queue = []),
                    (c._playLock = !1),
                    (c._onend = o.onend ? [{ fn: o.onend }] : []),
                    (c._onfade = o.onfade ? [{ fn: o.onfade }] : []),
                    (c._onload = o.onload ? [{ fn: o.onload }] : []),
                    (c._onloaderror = o.onloaderror ? [{ fn: o.onloaderror }] : []),
                    (c._onplayerror = o.onplayerror ? [{ fn: o.onplayerror }] : []),
                    (c._onpause = o.onpause ? [{ fn: o.onpause }] : []),
                    (c._onplay = o.onplay ? [{ fn: o.onplay }] : []),
                    (c._onstop = o.onstop ? [{ fn: o.onstop }] : []),
                    (c._onmute = o.onmute ? [{ fn: o.onmute }] : []),
                    (c._onvolume = o.onvolume ? [{ fn: o.onvolume }] : []),
                    (c._onrate = o.onrate ? [{ fn: o.onrate }] : []),
                    (c._onseek = o.onseek ? [{ fn: o.onseek }] : []),
                    (c._onunlock = o.onunlock ? [{ fn: o.onunlock }] : []),
                    (c._onresume = []),
                    (c._webAudio = t.usingWebAudio && !c._html5),
                    typeof t.ctx < 'u' && t.ctx && t.autoUnlock && t._unlockAudio(),
                    t._howls.push(c),
                    c._autoplay &&
                    c._queue.push({
                      event: 'play',
                      action: function () {
                        c.play();
                      },
                    }),
                    c._preload && c._preload !== 'none' && c.load(),
                    c
                  );
                },
                load: function () {
                  var o = this,
                    c = null;
                  if (t.noAudio) {
                    o._emit('loaderror', null, 'No audio support.');
                    return;
                  }
                  typeof o._src == 'string' && (o._src = [o._src]);
                  for (var d = 0; d < o._src.length; d++) {
                    var f, g;
                    if (o._format && o._format[d]) f = o._format[d];
                    else {
                      if (((g = o._src[d]), typeof g != 'string')) {
                        o._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
                        continue;
                      }
                      (f = /^data:audio\/([^;,]+);/i.exec(g)),
                        f || (f = /\.([^.]+)$/.exec(g.split('?', 1)[0])),
                        f && (f = f[1].toLowerCase());
                    }
                    if (f && t.codecs(f)) {
                      c = o._src[d];
                      break;
                    }
                  }
                  if (!c) {
                    o._emit('loaderror', null, 'No codec support for selected audio sources.');
                    return;
                  }
                  return (
                    (o._src = c),
                    (o._state = 'loading'),
                    window.location.protocol === 'https:' && c.slice(0, 5) === 'http:' && ((o._html5 = !0), (o._webAudio = !1)),
                    new r(o),
                    o._webAudio && n(o),
                    o
                  );
                },
                play: function (o, c) {
                  var d = this,
                    f = null;
                  if (typeof o == 'number') (f = o), (o = null);
                  else {
                    if (typeof o == 'string' && d._state === 'loaded' && !d._sprite[o]) return null;
                    if (typeof o > 'u' && ((o = '__default'), !d._playLock)) {
                      for (var g = 0, p = 0; p < d._sounds.length; p++)
                        d._sounds[p]._paused && !d._sounds[p]._ended && (g++, (f = d._sounds[p]._id));
                      g === 1 ? (o = null) : (f = null);
                    }
                  }
                  var m = f ? d._soundById(f) : d._inactiveSound();
                  if (!m) return null;
                  if ((f && !o && (o = m._sprite || '__default'), d._state !== 'loaded')) {
                    (m._sprite = o), (m._ended = !1);
                    var S = m._id;
                    return (
                      d._queue.push({
                        event: 'play',
                        action: function () {
                          d.play(S);
                        },
                      }),
                      S
                    );
                  }
                  if (f && !m._paused) return c || d._loadQueue('play'), m._id;
                  d._webAudio && t._autoResume();
                  var q = Math.max(0, m._seek > 0 ? m._seek : d._sprite[o][0] / 1e3),
                    E = Math.max(0, (d._sprite[o][0] + d._sprite[o][1]) / 1e3 - q),
                    b = (E * 1e3) / Math.abs(m._rate),
                    T = d._sprite[o][0] / 1e3,
                    I = (d._sprite[o][0] + d._sprite[o][1]) / 1e3;
                  (m._sprite = o), (m._ended = !1);
                  var B = function () {
                    (m._paused = !1), (m._seek = q), (m._start = T), (m._stop = I), (m._loop = !!(m._loop || d._sprite[o][2]));
                  };
                  if (q >= I) {
                    d._ended(m);
                    return;
                  }
                  var y = m._node;
                  if (d._webAudio) {
                    var x = function () {
                      (d._playLock = !1), B(), d._refreshBuffer(m);
                      var O = m._muted || d._muted ? 0 : m._volume;
                      y.gain.setValueAtTime(O, t.ctx.currentTime),
                        (m._playStart = t.ctx.currentTime),
                        typeof y.bufferSource.start > 'u'
                          ? m._loop
                            ? y.bufferSource.noteGrainOn(0, q, 86400)
                            : y.bufferSource.noteGrainOn(0, q, E)
                          : m._loop
                            ? y.bufferSource.start(0, q, 86400)
                            : y.bufferSource.start(0, q, E),
                        b !== 1 / 0 && (d._endTimers[m._id] = setTimeout(d._ended.bind(d, m), b)),
                        c ||
                        setTimeout(function () {
                          d._emit('play', m._id), d._loadQueue();
                        }, 0);
                    };
                    t.state === 'running' && t.ctx.state !== 'interrupted'
                      ? x()
                      : ((d._playLock = !0), d.once('resume', x), d._clearTimer(m._id));
                  } else {
                    var C = function () {
                      (y.currentTime = q),
                        (y.muted = m._muted || d._muted || t._muted || y.muted),
                        (y.volume = m._volume * t.volume()),
                        (y.playbackRate = m._rate);
                      try {
                        var O = y.play();
                        if (
                          (O && typeof Promise < 'u' && (O instanceof Promise || typeof O.then == 'function')
                            ? ((d._playLock = !0),
                              B(),
                              O.then(function () {
                                (d._playLock = !1), (y._unlocked = !0), c ? d._loadQueue() : d._emit('play', m._id);
                              }).catch(function () {
                                (d._playLock = !1),
                                  d._emit(
                                    'playerror',
                                    m._id,
                                    'Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.'
                                  ),
                                  (m._ended = !0),
                                  (m._paused = !0);
                              }))
                            : c || ((d._playLock = !1), B(), d._emit('play', m._id)),
                            (y.playbackRate = m._rate),
                            y.paused)
                        ) {
                          d._emit(
                            'playerror',
                            m._id,
                            'Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.'
                          );
                          return;
                        }
                        o !== '__default' || m._loop
                          ? (d._endTimers[m._id] = setTimeout(d._ended.bind(d, m), b))
                          : ((d._endTimers[m._id] = function () {
                            d._ended(m), y.removeEventListener('ended', d._endTimers[m._id], !1);
                          }),
                            y.addEventListener('ended', d._endTimers[m._id], !1));
                      } catch (st) {
                        d._emit('playerror', m._id, st);
                      }
                    };
                    y.src === '[PLACEHOLDER:audio/wav]' &&
                      ((y.src = d._src), y.load());
                    var X = (window && window.ejecta) || (!y.readyState && t._navigator.isCocoonJS);
                    if (y.readyState >= 3 || X) C();
                    else {
                      (d._playLock = !0), (d._state = 'loading');
                      var L = function () {
                        (d._state = 'loaded'), C(), y.removeEventListener(t._canPlayEvent, L, !1);
                      };
                      y.addEventListener(t._canPlayEvent, L, !1), d._clearTimer(m._id);
                    }
                  }
                  return m._id;
                },
                pause: function (o) {
                  var c = this;
                  if (c._state !== 'loaded' || c._playLock)
                    return (
                      c._queue.push({
                        event: 'pause',
                        action: function () {
                          c.pause(o);
                        },
                      }),
                      c
                    );
                  for (var d = c._getSoundIds(o), f = 0; f < d.length; f++) {
                    c._clearTimer(d[f]);
                    var g = c._soundById(d[f]);
                    if (
                      g &&
                      !g._paused &&
                      ((g._seek = c.seek(d[f])), (g._rateSeek = 0), (g._paused = !0), c._stopFade(d[f]), g._node)
                    )
                      if (c._webAudio) {
                        if (!g._node.bufferSource) continue;
                        typeof g._node.bufferSource.stop > 'u' ? g._node.bufferSource.noteOff(0) : g._node.bufferSource.stop(0),
                          c._cleanBuffer(g._node);
                      } else (!isNaN(g._node.duration) || g._node.duration === 1 / 0) && g._node.pause();
                    arguments[1] || c._emit('pause', g ? g._id : null);
                  }
                  return c;
                },
                stop: function (o, c) {
                  var d = this;
                  if (d._state !== 'loaded' || d._playLock)
                    return (
                      d._queue.push({
                        event: 'stop',
                        action: function () {
                          d.stop(o);
                        },
                      }),
                      d
                    );
                  for (var f = d._getSoundIds(o), g = 0; g < f.length; g++) {
                    d._clearTimer(f[g]);
                    var p = d._soundById(f[g]);
                    p &&
                      ((p._seek = p._start || 0),
                        (p._rateSeek = 0),
                        (p._paused = !0),
                        (p._ended = !0),
                        d._stopFade(f[g]),
                        p._node &&
                        (d._webAudio
                          ? p._node.bufferSource &&
                          (typeof p._node.bufferSource.stop > 'u'
                            ? p._node.bufferSource.noteOff(0)
                            : p._node.bufferSource.stop(0),
                            d._cleanBuffer(p._node))
                          : (!isNaN(p._node.duration) || p._node.duration === 1 / 0) &&
                          ((p._node.currentTime = p._start || 0),
                            p._node.pause(),
                            p._node.duration === 1 / 0 && d._clearSound(p._node))),
                        c || d._emit('stop', p._id));
                  }
                  return d;
                },
                mute: function (o, c) {
                  var d = this;
                  if (d._state !== 'loaded' || d._playLock)
                    return (
                      d._queue.push({
                        event: 'mute',
                        action: function () {
                          d.mute(o, c);
                        },
                      }),
                      d
                    );
                  if (typeof c > 'u')
                    if (typeof o == 'boolean') d._muted = o;
                    else return d._muted;
                  for (var f = d._getSoundIds(c), g = 0; g < f.length; g++) {
                    var p = d._soundById(f[g]);
                    p &&
                      ((p._muted = o),
                        p._interval && d._stopFade(p._id),
                        d._webAudio && p._node
                          ? p._node.gain.setValueAtTime(o ? 0 : p._volume, t.ctx.currentTime)
                          : p._node && (p._node.muted = t._muted ? !0 : o),
                        d._emit('mute', p._id));
                  }
                  return d;
                },
                volume: function () {
                  var o = this,
                    c = arguments,
                    d,
                    f;
                  if (c.length === 0) return o._volume;
                  if (c.length === 1 || (c.length === 2 && typeof c[1] > 'u')) {
                    var g = o._getSoundIds(),
                      p = g.indexOf(c[0]);
                    p >= 0 ? (f = parseInt(c[0], 10)) : (d = parseFloat(c[0]));
                  } else c.length >= 2 && ((d = parseFloat(c[0])), (f = parseInt(c[1], 10)));
                  var m;
                  if (typeof d < 'u' && d >= 0 && d <= 1) {
                    if (o._state !== 'loaded' || o._playLock)
                      return (
                        o._queue.push({
                          event: 'volume',
                          action: function () {
                            o.volume.apply(o, c);
                          },
                        }),
                        o
                      );
                    typeof f > 'u' && (o._volume = d), (f = o._getSoundIds(f));
                    for (var S = 0; S < f.length; S++)
                      (m = o._soundById(f[S])),
                        m &&
                        ((m._volume = d),
                          c[2] || o._stopFade(f[S]),
                          o._webAudio && m._node && !m._muted
                            ? m._node.gain.setValueAtTime(d, t.ctx.currentTime)
                            : m._node && !m._muted && (m._node.volume = d * t.volume()),
                          o._emit('volume', m._id));
                  } else return (m = f ? o._soundById(f) : o._sounds[0]), m ? m._volume : 0;
                  return o;
                },
                fade: function (o, c, d, f) {
                  var g = this;
                  if (g._state !== 'loaded' || g._playLock)
                    return (
                      g._queue.push({
                        event: 'fade',
                        action: function () {
                          g.fade(o, c, d, f);
                        },
                      }),
                      g
                    );
                  (o = Math.min(Math.max(0, parseFloat(o)), 1)),
                    (c = Math.min(Math.max(0, parseFloat(c)), 1)),
                    (d = parseFloat(d)),
                    g.volume(o, f);
                  for (var p = g._getSoundIds(f), m = 0; m < p.length; m++) {
                    var S = g._soundById(p[m]);
                    if (S) {
                      if ((f || g._stopFade(p[m]), g._webAudio && !S._muted)) {
                        var q = t.ctx.currentTime,
                          E = q + d / 1e3;
                        (S._volume = o), S._node.gain.setValueAtTime(o, q), S._node.gain.linearRampToValueAtTime(c, E);
                      }
                      g._startFadeInterval(S, o, c, d, p[m], typeof f > 'u');
                    }
                  }
                  return g;
                },
                _startFadeInterval: function (o, c, d, f, g, p) {
                  var m = this,
                    S = c,
                    q = d - c,
                    E = Math.abs(q / 0.01),
                    b = Math.max(4, E > 0 ? f / E : f),
                    T = Date.now();
                  (o._fadeTo = d),
                    (o._interval = setInterval(function () {
                      var I = (Date.now() - T) / f;
                      (T = Date.now()),
                        (S += q * I),
                        (S = Math.round(S * 100) / 100),
                        q < 0 ? (S = Math.max(d, S)) : (S = Math.min(d, S)),
                        m._webAudio ? (o._volume = S) : m.volume(S, o._id, !0),
                        p && (m._volume = S),
                        ((d < c && S <= d) || (d > c && S >= d)) &&
                        (clearInterval(o._interval),
                          (o._interval = null),
                          (o._fadeTo = null),
                          m.volume(d, o._id),
                          m._emit('fade', o._id));
                    }, b));
                },
                _stopFade: function (o) {
                  var c = this,
                    d = c._soundById(o);
                  return (
                    d &&
                    d._interval &&
                    (c._webAudio && d._node.gain.cancelScheduledValues(t.ctx.currentTime),
                      clearInterval(d._interval),
                      (d._interval = null),
                      c.volume(d._fadeTo, o),
                      (d._fadeTo = null),
                      c._emit('fade', o)),
                    c
                  );
                },
                loop: function () {
                  var o = this,
                    c = arguments,
                    d,
                    f,
                    g;
                  if (c.length === 0) return o._loop;
                  if (c.length === 1)
                    if (typeof c[0] == 'boolean') (d = c[0]), (o._loop = d);
                    else return (g = o._soundById(parseInt(c[0], 10))), g ? g._loop : !1;
                  else c.length === 2 && ((d = c[0]), (f = parseInt(c[1], 10)));
                  for (var p = o._getSoundIds(f), m = 0; m < p.length; m++)
                    (g = o._soundById(p[m])),
                      g &&
                      ((g._loop = d),
                        o._webAudio &&
                        g._node &&
                        g._node.bufferSource &&
                        ((g._node.bufferSource.loop = d),
                          d &&
                          ((g._node.bufferSource.loopStart = g._start || 0),
                            (g._node.bufferSource.loopEnd = g._stop),
                            o.playing(p[m]) && (o.pause(p[m], !0), o.play(p[m], !0)))));
                  return o;
                },
                rate: function () {
                  var o = this,
                    c = arguments,
                    d,
                    f;
                  if (c.length === 0) f = o._sounds[0]._id;
                  else if (c.length === 1) {
                    var g = o._getSoundIds(),
                      p = g.indexOf(c[0]);
                    p >= 0 ? (f = parseInt(c[0], 10)) : (d = parseFloat(c[0]));
                  } else c.length === 2 && ((d = parseFloat(c[0])), (f = parseInt(c[1], 10)));
                  var m;
                  if (typeof d == 'number') {
                    if (o._state !== 'loaded' || o._playLock)
                      return (
                        o._queue.push({
                          event: 'rate',
                          action: function () {
                            o.rate.apply(o, c);
                          },
                        }),
                        o
                      );
                    typeof f > 'u' && (o._rate = d), (f = o._getSoundIds(f));
                    for (var S = 0; S < f.length; S++)
                      if (((m = o._soundById(f[S])), m)) {
                        o.playing(f[S]) &&
                          ((m._rateSeek = o.seek(f[S])), (m._playStart = o._webAudio ? t.ctx.currentTime : m._playStart)),
                          (m._rate = d),
                          o._webAudio && m._node && m._node.bufferSource
                            ? m._node.bufferSource.playbackRate.setValueAtTime(d, t.ctx.currentTime)
                            : m._node && (m._node.playbackRate = d);
                        var q = o.seek(f[S]),
                          E = (o._sprite[m._sprite][0] + o._sprite[m._sprite][1]) / 1e3 - q,
                          b = (E * 1e3) / Math.abs(m._rate);
                        (o._endTimers[f[S]] || !m._paused) &&
                          (o._clearTimer(f[S]), (o._endTimers[f[S]] = setTimeout(o._ended.bind(o, m), b))),
                          o._emit('rate', m._id);
                      }
                  } else return (m = o._soundById(f)), m ? m._rate : o._rate;
                  return o;
                },
                seek: function () {
                  var o = this,
                    c = arguments,
                    d,
                    f;
                  if (c.length === 0) o._sounds.length && (f = o._sounds[0]._id);
                  else if (c.length === 1) {
                    var g = o._getSoundIds(),
                      p = g.indexOf(c[0]);
                    p >= 0 ? (f = parseInt(c[0], 10)) : o._sounds.length && ((f = o._sounds[0]._id), (d = parseFloat(c[0])));
                  } else c.length === 2 && ((d = parseFloat(c[0])), (f = parseInt(c[1], 10)));
                  if (typeof f > 'u') return 0;
                  if (typeof d == 'number' && (o._state !== 'loaded' || o._playLock))
                    return (
                      o._queue.push({
                        event: 'seek',
                        action: function () {
                          o.seek.apply(o, c);
                        },
                      }),
                      o
                    );
                  var m = o._soundById(f);
                  if (m)
                    if (typeof d == 'number' && d >= 0) {
                      var S = o.playing(f);
                      S && o.pause(f, !0),
                        (m._seek = d),
                        (m._ended = !1),
                        o._clearTimer(f),
                        !o._webAudio && m._node && !isNaN(m._node.duration) && (m._node.currentTime = d);
                      var q = function () {
                        S && o.play(f, !0), o._emit('seek', f);
                      };
                      if (S && !o._webAudio) {
                        var E = function () {
                          o._playLock ? setTimeout(E, 0) : q();
                        };
                        setTimeout(E, 0);
                      } else q();
                    } else if (o._webAudio) {
                      var b = o.playing(f) ? t.ctx.currentTime - m._playStart : 0,
                        T = m._rateSeek ? m._rateSeek - m._seek : 0;
                      return m._seek + (T + b * Math.abs(m._rate));
                    } else return m._node.currentTime;
                  return o;
                },
                playing: function (o) {
                  var c = this;
                  if (typeof o == 'number') {
                    var d = c._soundById(o);
                    return d ? !d._paused : !1;
                  }
                  for (var f = 0; f < c._sounds.length; f++) if (!c._sounds[f]._paused) return !0;
                  return !1;
                },
                duration: function (o) {
                  var c = this,
                    d = c._duration,
                    f = c._soundById(o);
                  return f && (d = c._sprite[f._sprite][1] / 1e3), d;
                },
                state: function () {
                  return this._state;
                },
                unload: function () {
                  for (var o = this, c = o._sounds, d = 0; d < c.length; d++)
                    c[d]._paused || o.stop(c[d]._id),
                      o._webAudio ||
                      (o._clearSound(c[d]._node),
                        c[d]._node.removeEventListener('error', c[d]._errorFn, !1),
                        c[d]._node.removeEventListener(t._canPlayEvent, c[d]._loadFn, !1),
                        c[d]._node.removeEventListener('ended', c[d]._endFn, !1),
                        t._releaseHtml5Audio(c[d]._node)),
                      delete c[d]._node,
                      o._clearTimer(c[d]._id);
                  var f = t._howls.indexOf(o);
                  f >= 0 && t._howls.splice(f, 1);
                  var g = !0;
                  for (d = 0; d < t._howls.length; d++)
                    if (t._howls[d]._src === o._src || o._src.indexOf(t._howls[d]._src) >= 0) {
                      g = !1;
                      break;
                    }
                  return (
                    s && g && delete s[o._src], (t.noAudio = !1), (o._state = 'unloaded'), (o._sounds = []), (o = null), null
                  );
                },
                on: function (o, c, d, f) {
                  var g = this,
                    p = g['_on' + o];
                  return typeof c == 'function' && p.push(f ? { id: d, fn: c, once: f } : { id: d, fn: c }), g;
                },
                off: function (o, c, d) {
                  var f = this,
                    g = f['_on' + o],
                    p = 0;
                  if ((typeof c == 'number' && ((d = c), (c = null)), c || d))
                    for (p = 0; p < g.length; p++) {
                      var m = d === g[p].id;
                      if ((c === g[p].fn && m) || (!c && m)) {
                        g.splice(p, 1);
                        break;
                      }
                    }
                  else if (o) f['_on' + o] = [];
                  else {
                    var S = Object.keys(f);
                    for (p = 0; p < S.length; p++) S[p].indexOf('_on') === 0 && Array.isArray(f[S[p]]) && (f[S[p]] = []);
                  }
                  return f;
                },
                once: function (o, c, d) {
                  var f = this;
                  return f.on(o, c, d, 1), f;
                },
                _emit: function (o, c, d) {
                  for (var f = this, g = f['_on' + o], p = g.length - 1; p >= 0; p--)
                    (!g[p].id || g[p].id === c || o === 'load') &&
                      (setTimeout(
                        function (m) {
                          m.call(this, c, d);
                        }.bind(f, g[p].fn),
                        0
                      ),
                        g[p].once && f.off(o, g[p].fn, g[p].id));
                  return f._loadQueue(o), f;
                },
                _loadQueue: function (o) {
                  var c = this;
                  if (c._queue.length > 0) {
                    var d = c._queue[0];
                    d.event === o && (c._queue.shift(), c._loadQueue()), o || d.action();
                  }
                  return c;
                },
                _ended: function (o) {
                  var c = this,
                    d = o._sprite;
                  if (!c._webAudio && o._node && !o._node.paused && !o._node.ended && o._node.currentTime < o._stop)
                    return setTimeout(c._ended.bind(c, o), 100), c;
                  var f = !!(o._loop || c._sprite[d][2]);
                  if ((c._emit('end', o._id), !c._webAudio && f && c.stop(o._id, !0).play(o._id), c._webAudio && f)) {
                    c._emit('play', o._id), (o._seek = o._start || 0), (o._rateSeek = 0), (o._playStart = t.ctx.currentTime);
                    var g = ((o._stop - o._start) * 1e3) / Math.abs(o._rate);
                    c._endTimers[o._id] = setTimeout(c._ended.bind(c, o), g);
                  }
                  return (
                    c._webAudio &&
                    !f &&
                    ((o._paused = !0),
                      (o._ended = !0),
                      (o._seek = o._start || 0),
                      (o._rateSeek = 0),
                      c._clearTimer(o._id),
                      c._cleanBuffer(o._node),
                      t._autoSuspend()),
                    !c._webAudio && !f && c.stop(o._id, !0),
                    c
                  );
                },
                _clearTimer: function (o) {
                  var c = this;
                  if (c._endTimers[o]) {
                    if (typeof c._endTimers[o] != 'function') clearTimeout(c._endTimers[o]);
                    else {
                      var d = c._soundById(o);
                      d && d._node && d._node.removeEventListener('ended', c._endTimers[o], !1);
                    }
                    delete c._endTimers[o];
                  }
                  return c;
                },
                _soundById: function (o) {
                  for (var c = this, d = 0; d < c._sounds.length; d++) if (o === c._sounds[d]._id) return c._sounds[d];
                  return null;
                },
                _inactiveSound: function () {
                  var o = this;
                  o._drain();
                  for (var c = 0; c < o._sounds.length; c++) if (o._sounds[c]._ended) return o._sounds[c].reset();
                  return new r(o);
                },
                _drain: function () {
                  var o = this,
                    c = o._pool,
                    d = 0,
                    f = 0;
                  if (!(o._sounds.length < c)) {
                    for (f = 0; f < o._sounds.length; f++) o._sounds[f]._ended && d++;
                    for (f = o._sounds.length - 1; f >= 0; f--) {
                      if (d <= c) return;
                      o._sounds[f]._ended &&
                        (o._webAudio && o._sounds[f]._node && o._sounds[f]._node.disconnect(0), o._sounds.splice(f, 1), d--);
                    }
                  }
                },
                _getSoundIds: function (o) {
                  var c = this;
                  if (typeof o > 'u') {
                    for (var d = [], f = 0; f < c._sounds.length; f++) d.push(c._sounds[f]._id);
                    return d;
                  } else return [o];
                },
                _refreshBuffer: function (o) {
                  var c = this;
                  return (
                    (o._node.bufferSource = t.ctx.createBufferSource()),
                    (o._node.bufferSource.buffer = s[c._src]),
                    o._panner ? o._node.bufferSource.connect(o._panner) : o._node.bufferSource.connect(o._node),
                    (o._node.bufferSource.loop = o._loop),
                    o._loop &&
                    ((o._node.bufferSource.loopStart = o._start || 0), (o._node.bufferSource.loopEnd = o._stop || 0)),
                    o._node.bufferSource.playbackRate.setValueAtTime(o._rate, t.ctx.currentTime),
                    c
                  );
                },
                _cleanBuffer: function (o) {
                  var c = this,
                    d = t._navigator && t._navigator.vendor.indexOf('Apple') >= 0;
                  if (!o.bufferSource) return c;
                  if (t._scratchBuffer && o.bufferSource && ((o.bufferSource.onended = null), o.bufferSource.disconnect(0), d))
                    try {
                      o.bufferSource.buffer = t._scratchBuffer;
                    } catch { }
                  return (o.bufferSource = null), c;
                },
                _clearSound: function (o) {
                  var c = /MSIE |Trident\//.test(t._navigator && t._navigator.userAgent);
                  c || (o.src = '[PLACEHOLDER:audio/wav]');
                },
              };
              var r = function (o) {
                (this._parent = o), this.init();
              };
              r.prototype = {
                init: function () {
                  var o = this,
                    c = o._parent;
                  return (
                    (o._muted = c._muted),
                    (o._loop = c._loop),
                    (o._volume = c._volume),
                    (o._rate = c._rate),
                    (o._seek = 0),
                    (o._paused = !0),
                    (o._ended = !0),
                    (o._sprite = '__default'),
                    (o._id = ++t._counter),
                    c._sounds.push(o),
                    o.create(),
                    o
                  );
                },
                create: function () {
                  var o = this,
                    c = o._parent,
                    d = t._muted || o._muted || o._parent._muted ? 0 : o._volume;
                  return (
                    c._webAudio
                      ? ((o._node = typeof t.ctx.createGain > 'u' ? t.ctx.createGainNode() : t.ctx.createGain()),
                        o._node.gain.setValueAtTime(d, t.ctx.currentTime),
                        (o._node.paused = !0),
                        o._node.connect(t.masterGain))
                      : t.noAudio ||
                      ((o._node = t._obtainHtml5Audio()),
                        (o._errorFn = o._errorListener.bind(o)),
                        o._node.addEventListener('error', o._errorFn, !1),
                        (o._loadFn = o._loadListener.bind(o)),
                        o._node.addEventListener(t._canPlayEvent, o._loadFn, !1),
                        (o._endFn = o._endListener.bind(o)),
                        o._node.addEventListener('ended', o._endFn, !1),
                        (o._node.src = c._src),
                        (o._node.preload = c._preload === !0 ? 'auto' : c._preload),
                        (o._node.volume = d * t.volume()),
                        o._node.load()),
                    o
                  );
                },
                reset: function () {
                  var o = this,
                    c = o._parent;
                  return (
                    (o._muted = c._muted),
                    (o._loop = c._loop),
                    (o._volume = c._volume),
                    (o._rate = c._rate),
                    (o._seek = 0),
                    (o._rateSeek = 0),
                    (o._paused = !0),
                    (o._ended = !0),
                    (o._sprite = '__default'),
                    (o._id = ++t._counter),
                    o
                  );
                },
                _errorListener: function () {
                  var o = this;
                  o._parent._emit('loaderror', o._id, o._node.error ? o._node.error.code : 0),
                    o._node.removeEventListener('error', o._errorFn, !1);
                },
                _loadListener: function () {
                  var o = this,
                    c = o._parent;
                  (c._duration = Math.ceil(o._node.duration * 10) / 10),
                    Object.keys(c._sprite).length === 0 && (c._sprite = { __default: [0, c._duration * 1e3] }),
                    c._state !== 'loaded' && ((c._state = 'loaded'), c._emit('load'), c._loadQueue()),
                    o._node.removeEventListener(t._canPlayEvent, o._loadFn, !1);
                },
                _endListener: function () {
                  var o = this,
                    c = o._parent;
                  c._duration === 1 / 0 &&
                    ((c._duration = Math.ceil(o._node.duration * 10) / 10),
                      c._sprite.__default[1] === 1 / 0 && (c._sprite.__default[1] = c._duration * 1e3),
                      c._ended(o)),
                    o._node.removeEventListener('ended', o._endFn, !1);
                },
              };
              var s = {},
                n = function (o) {
                  var c = o._src;
                  if (s[c]) {
                    (o._duration = s[c].duration), h(o);
                    return;
                  }
                  if (/^data:[^;]+;base64,/.test(c)) {
                    for (var d = atob(c.split(',')[1]), f = new Uint8Array(d.length), g = 0; g < d.length; ++g)
                      f[g] = d.charCodeAt(g);
                    l(f.buffer, o);
                  } else {
                    var p = new XMLHttpRequest();
                    p.open(o._xhr.method, c, !0),
                      (p.withCredentials = o._xhr.withCredentials),
                      (p.responseType = 'arraybuffer'),
                      o._xhr.headers &&
                      Object.keys(o._xhr.headers).forEach(function (m) {
                        p.setRequestHeader(m, o._xhr.headers[m]);
                      }),
                      (p.onload = function () {
                        var m = (p.status + '')[0];
                        if (m !== '0' && m !== '2' && m !== '3') {
                          o._emit('loaderror', null, 'Failed loading audio file with status: ' + p.status + '.');
                          return;
                        }
                        l(p.response, o);
                      }),
                      (p.onerror = function () {
                        o._webAudio && ((o._html5 = !0), (o._webAudio = !1), (o._sounds = []), delete s[c], o.load());
                      }),
                      a(p);
                  }
                },
                a = function (o) {
                  try {
                    o.send();
                  } catch {
                    o.onerror();
                  }
                },
                l = function (o, c) {
                  var d = function () {
                    c._emit('loaderror', null, 'Decoding audio data failed.');
                  },
                    f = function (g) {
                      g && c._sounds.length > 0 ? ((s[c._src] = g), h(c, g)) : d();
                    };
                  typeof Promise < 'u' && t.ctx.decodeAudioData.length === 1
                    ? t.ctx.decodeAudioData(o).then(f).catch(d)
                    : t.ctx.decodeAudioData(o, f, d);
                },
                h = function (o, c) {
                  c && !o._duration && (o._duration = c.duration),
                    Object.keys(o._sprite).length === 0 && (o._sprite = { __default: [0, o._duration * 1e3] }),
                    o._state !== 'loaded' && ((o._state = 'loaded'), o._emit('load'), o._loadQueue());
                },
                u = function () {
                  if (t.usingWebAudio) {
                    try {
                      typeof AudioContext < 'u'
                        ? (t.ctx = new AudioContext())
                        : typeof webkitAudioContext < 'u'
                          ? (t.ctx = new webkitAudioContext())
                          : (t.usingWebAudio = !1);
                    } catch {
                      t.usingWebAudio = !1;
                    }
                    t.ctx || (t.usingWebAudio = !1);
                    var o = /iP(hone|od|ad)/.test(t._navigator && t._navigator.platform),
                      c = t._navigator && t._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                      d = c ? parseInt(c[1], 10) : null;
                    if (o && d && d < 9) {
                      var f = /safari/.test(t._navigator && t._navigator.userAgent.toLowerCase());
                      t._navigator && !f && (t.usingWebAudio = !1);
                    }
                    t.usingWebAudio &&
                      ((t.masterGain = typeof t.ctx.createGain > 'u' ? t.ctx.createGainNode() : t.ctx.createGain()),
                        t.masterGain.gain.setValueAtTime(t._muted ? 0 : t._volume, t.ctx.currentTime),
                        t.masterGain.connect(t.ctx.destination)),
                      t._setup();
                  }
                };
              (i.Howler = t),
                (i.Howl = A),
                typeof pA < 'u'
                  ? ((pA.HowlerGlobal = e), (pA.Howler = t), (pA.Howl = A), (pA.Sound = r))
                  : typeof window < 'u' &&
                  ((window.HowlerGlobal = e), (window.Howler = t), (window.Howl = A), (window.Sound = r));
            })();
              /*!
               *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
               *
               *  howler.js v2.2.4
               *  howlerjs.com
               *
               *  (c) 2013-2020, James Simpson of GoldFire Studios
               *  goldfirestudios.com
               *
               *  MIT License
               */ (function () {
              (HowlerGlobal.prototype._pos = [0, 0, 0]),
                (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
                (HowlerGlobal.prototype.stereo = function (t) {
                  var A = this;
                  if (!A.ctx || !A.ctx.listener) return A;
                  for (var r = A._howls.length - 1; r >= 0; r--) A._howls[r].stereo(t);
                  return A;
                }),
                (HowlerGlobal.prototype.pos = function (t, A, r) {
                  var s = this;
                  if (!s.ctx || !s.ctx.listener) return s;
                  if (
                    ((A = typeof A != 'number' ? s._pos[1] : A),
                      (r = typeof r != 'number' ? s._pos[2] : r),
                      typeof t == 'number')
                  )
                    (s._pos = [t, A, r]),
                      typeof s.ctx.listener.positionX < 'u'
                        ? (s.ctx.listener.positionX.setTargetAtTime(s._pos[0], Howler.ctx.currentTime, 0.1),
                          s.ctx.listener.positionY.setTargetAtTime(s._pos[1], Howler.ctx.currentTime, 0.1),
                          s.ctx.listener.positionZ.setTargetAtTime(s._pos[2], Howler.ctx.currentTime, 0.1))
                        : s.ctx.listener.setPosition(s._pos[0], s._pos[1], s._pos[2]);
                  else return s._pos;
                  return s;
                }),
                (HowlerGlobal.prototype.orientation = function (t, A, r, s, n, a) {
                  var l = this;
                  if (!l.ctx || !l.ctx.listener) return l;
                  var h = l._orientation;
                  if (
                    ((A = typeof A != 'number' ? h[1] : A),
                      (r = typeof r != 'number' ? h[2] : r),
                      (s = typeof s != 'number' ? h[3] : s),
                      (n = typeof n != 'number' ? h[4] : n),
                      (a = typeof a != 'number' ? h[5] : a),
                      typeof t == 'number')
                  )
                    (l._orientation = [t, A, r, s, n, a]),
                      typeof l.ctx.listener.forwardX < 'u'
                        ? (l.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, 0.1),
                          l.ctx.listener.forwardY.setTargetAtTime(A, Howler.ctx.currentTime, 0.1),
                          l.ctx.listener.forwardZ.setTargetAtTime(r, Howler.ctx.currentTime, 0.1),
                          l.ctx.listener.upX.setTargetAtTime(s, Howler.ctx.currentTime, 0.1),
                          l.ctx.listener.upY.setTargetAtTime(n, Howler.ctx.currentTime, 0.1),
                          l.ctx.listener.upZ.setTargetAtTime(a, Howler.ctx.currentTime, 0.1))
                        : l.ctx.listener.setOrientation(t, A, r, s, n, a);
                  else return h;
                  return l;
                }),
                (Howl.prototype.init = (function (t) {
                  return function (A) {
                    var r = this;
                    return (
                      (r._orientation = A.orientation || [1, 0, 0]),
                      (r._stereo = A.stereo || null),
                      (r._pos = A.pos || null),
                      (r._pannerAttr = {
                        coneInnerAngle: typeof A.coneInnerAngle < 'u' ? A.coneInnerAngle : 360,
                        coneOuterAngle: typeof A.coneOuterAngle < 'u' ? A.coneOuterAngle : 360,
                        coneOuterGain: typeof A.coneOuterGain < 'u' ? A.coneOuterGain : 0,
                        distanceModel: typeof A.distanceModel < 'u' ? A.distanceModel : 'inverse',
                        maxDistance: typeof A.maxDistance < 'u' ? A.maxDistance : 1e4,
                        panningModel: typeof A.panningModel < 'u' ? A.panningModel : 'HRTF',
                        refDistance: typeof A.refDistance < 'u' ? A.refDistance : 1,
                        rolloffFactor: typeof A.rolloffFactor < 'u' ? A.rolloffFactor : 1,
                      }),
                      (r._onstereo = A.onstereo ? [{ fn: A.onstereo }] : []),
                      (r._onpos = A.onpos ? [{ fn: A.onpos }] : []),
                      (r._onorientation = A.onorientation ? [{ fn: A.onorientation }] : []),
                      t.call(this, A)
                    );
                  };
                })(Howl.prototype.init)),
                (Howl.prototype.stereo = function (t, A) {
                  var r = this;
                  if (!r._webAudio) return r;
                  if (r._state !== 'loaded')
                    return (
                      r._queue.push({
                        event: 'stereo',
                        action: function () {
                          r.stereo(t, A);
                        },
                      }),
                      r
                    );
                  var s = typeof Howler.ctx.createStereoPanner > 'u' ? 'spatial' : 'stereo';
                  if (typeof A > 'u')
                    if (typeof t == 'number') (r._stereo = t), (r._pos = [t, 0, 0]);
                    else return r._stereo;
                  for (var n = r._getSoundIds(A), a = 0; a < n.length; a++) {
                    var l = r._soundById(n[a]);
                    if (l)
                      if (typeof t == 'number')
                        (l._stereo = t),
                          (l._pos = [t, 0, 0]),
                          l._node &&
                          ((l._pannerAttr.panningModel = 'equalpower'),
                            (!l._panner || !l._panner.pan) && e(l, s),
                            s === 'spatial'
                              ? typeof l._panner.positionX < 'u'
                                ? (l._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime),
                                  l._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime),
                                  l._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime))
                                : l._panner.setPosition(t, 0, 0)
                              : l._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)),
                          r._emit('stereo', l._id);
                      else return l._stereo;
                  }
                  return r;
                }),
                (Howl.prototype.pos = function (t, A, r, s) {
                  var n = this;
                  if (!n._webAudio) return n;
                  if (n._state !== 'loaded')
                    return (
                      n._queue.push({
                        event: 'pos',
                        action: function () {
                          n.pos(t, A, r, s);
                        },
                      }),
                      n
                    );
                  if (((A = typeof A != 'number' ? 0 : A), (r = typeof r != 'number' ? -0.5 : r), typeof s > 'u'))
                    if (typeof t == 'number') n._pos = [t, A, r];
                    else return n._pos;
                  for (var a = n._getSoundIds(s), l = 0; l < a.length; l++) {
                    var h = n._soundById(a[l]);
                    if (h)
                      if (typeof t == 'number')
                        (h._pos = [t, A, r]),
                          h._node &&
                          ((!h._panner || h._panner.pan) && e(h, 'spatial'),
                            typeof h._panner.positionX < 'u'
                              ? (h._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime),
                                h._panner.positionY.setValueAtTime(A, Howler.ctx.currentTime),
                                h._panner.positionZ.setValueAtTime(r, Howler.ctx.currentTime))
                              : h._panner.setPosition(t, A, r)),
                          n._emit('pos', h._id);
                      else return h._pos;
                  }
                  return n;
                }),
                (Howl.prototype.orientation = function (t, A, r, s) {
                  var n = this;
                  if (!n._webAudio) return n;
                  if (n._state !== 'loaded')
                    return (
                      n._queue.push({
                        event: 'orientation',
                        action: function () {
                          n.orientation(t, A, r, s);
                        },
                      }),
                      n
                    );
                  if (
                    ((A = typeof A != 'number' ? n._orientation[1] : A),
                      (r = typeof r != 'number' ? n._orientation[2] : r),
                      typeof s > 'u')
                  )
                    if (typeof t == 'number') n._orientation = [t, A, r];
                    else return n._orientation;
                  for (var a = n._getSoundIds(s), l = 0; l < a.length; l++) {
                    var h = n._soundById(a[l]);
                    if (h)
                      if (typeof t == 'number')
                        (h._orientation = [t, A, r]),
                          h._node &&
                          (h._panner || (h._pos || (h._pos = n._pos || [0, 0, -0.5]), e(h, 'spatial')),
                            typeof h._panner.orientationX < 'u'
                              ? (h._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime),
                                h._panner.orientationY.setValueAtTime(A, Howler.ctx.currentTime),
                                h._panner.orientationZ.setValueAtTime(r, Howler.ctx.currentTime))
                              : h._panner.setOrientation(t, A, r)),
                          n._emit('orientation', h._id);
                      else return h._orientation;
                  }
                  return n;
                }),
                (Howl.prototype.pannerAttr = function () {
                  var t = this,
                    A = arguments,
                    r,
                    s,
                    n;
                  if (!t._webAudio) return t;
                  if (A.length === 0) return t._pannerAttr;
                  if (A.length === 1)
                    if (typeof A[0] == 'object')
                      (r = A[0]),
                        typeof s > 'u' &&
                        (r.pannerAttr ||
                          (r.pannerAttr = {
                            coneInnerAngle: r.coneInnerAngle,
                            coneOuterAngle: r.coneOuterAngle,
                            coneOuterGain: r.coneOuterGain,
                            distanceModel: r.distanceModel,
                            maxDistance: r.maxDistance,
                            refDistance: r.refDistance,
                            rolloffFactor: r.rolloffFactor,
                            panningModel: r.panningModel,
                          }),
                          (t._pannerAttr = {
                            coneInnerAngle:
                              typeof r.pannerAttr.coneInnerAngle < 'u' ? r.pannerAttr.coneInnerAngle : t._coneInnerAngle,
                            coneOuterAngle:
                              typeof r.pannerAttr.coneOuterAngle < 'u' ? r.pannerAttr.coneOuterAngle : t._coneOuterAngle,
                            coneOuterGain:
                              typeof r.pannerAttr.coneOuterGain < 'u' ? r.pannerAttr.coneOuterGain : t._coneOuterGain,
                            distanceModel:
                              typeof r.pannerAttr.distanceModel < 'u' ? r.pannerAttr.distanceModel : t._distanceModel,
                            maxDistance: typeof r.pannerAttr.maxDistance < 'u' ? r.pannerAttr.maxDistance : t._maxDistance,
                            refDistance: typeof r.pannerAttr.refDistance < 'u' ? r.pannerAttr.refDistance : t._refDistance,
                            rolloffFactor:
                              typeof r.pannerAttr.rolloffFactor < 'u' ? r.pannerAttr.rolloffFactor : t._rolloffFactor,
                            panningModel: typeof r.pannerAttr.panningModel < 'u' ? r.pannerAttr.panningModel : t._panningModel,
                          }));
                    else return (n = t._soundById(parseInt(A[0], 10))), n ? n._pannerAttr : t._pannerAttr;
                  else A.length === 2 && ((r = A[0]), (s = parseInt(A[1], 10)));
                  for (var a = t._getSoundIds(s), l = 0; l < a.length; l++)
                    if (((n = t._soundById(a[l])), n)) {
                      var h = n._pannerAttr;
                      h = {
                        coneInnerAngle: typeof r.coneInnerAngle < 'u' ? r.coneInnerAngle : h.coneInnerAngle,
                        coneOuterAngle: typeof r.coneOuterAngle < 'u' ? r.coneOuterAngle : h.coneOuterAngle,
                        coneOuterGain: typeof r.coneOuterGain < 'u' ? r.coneOuterGain : h.coneOuterGain,
                        distanceModel: typeof r.distanceModel < 'u' ? r.distanceModel : h.distanceModel,
                        maxDistance: typeof r.maxDistance < 'u' ? r.maxDistance : h.maxDistance,
                        refDistance: typeof r.refDistance < 'u' ? r.refDistance : h.refDistance,
                        rolloffFactor: typeof r.rolloffFactor < 'u' ? r.rolloffFactor : h.rolloffFactor,
                        panningModel: typeof r.panningModel < 'u' ? r.panningModel : h.panningModel,
                      };
                      var u = n._panner;
                      u || (n._pos || (n._pos = t._pos || [0, 0, -0.5]), e(n, 'spatial'), (u = n._panner)),
                        (u.coneInnerAngle = h.coneInnerAngle),
                        (u.coneOuterAngle = h.coneOuterAngle),
                        (u.coneOuterGain = h.coneOuterGain),
                        (u.distanceModel = h.distanceModel),
                        (u.maxDistance = h.maxDistance),
                        (u.refDistance = h.refDistance),
                        (u.rolloffFactor = h.rolloffFactor),
                        (u.panningModel = h.panningModel);
                    }
                  return t;
                }),
                (Sound.prototype.init = (function (t) {
                  return function () {
                    var A = this,
                      r = A._parent;
                    (A._orientation = r._orientation),
                      (A._stereo = r._stereo),
                      (A._pos = r._pos),
                      (A._pannerAttr = r._pannerAttr),
                      t.call(this),
                      A._stereo ? r.stereo(A._stereo) : A._pos && r.pos(A._pos[0], A._pos[1], A._pos[2], A._id);
                  };
                })(Sound.prototype.init)),
                (Sound.prototype.reset = (function (t) {
                  return function () {
                    var A = this,
                      r = A._parent;
                    return (
                      (A._orientation = r._orientation),
                      (A._stereo = r._stereo),
                      (A._pos = r._pos),
                      (A._pannerAttr = r._pannerAttr),
                      A._stereo
                        ? r.stereo(A._stereo)
                        : A._pos
                          ? r.pos(A._pos[0], A._pos[1], A._pos[2], A._id)
                          : A._panner && (A._panner.disconnect(0), (A._panner = void 0), r._refreshBuffer(A)),
                      t.call(this)
                    );
                  };
                })(Sound.prototype.reset));
              var e = function (t, A) {
                (A = A || 'spatial'),
                  A === 'spatial'
                    ? ((t._panner = Howler.ctx.createPanner()),
                      (t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle),
                      (t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle),
                      (t._panner.coneOuterGain = t._pannerAttr.coneOuterGain),
                      (t._panner.distanceModel = t._pannerAttr.distanceModel),
                      (t._panner.maxDistance = t._pannerAttr.maxDistance),
                      (t._panner.refDistance = t._pannerAttr.refDistance),
                      (t._panner.rolloffFactor = t._pannerAttr.rolloffFactor),
                      (t._panner.panningModel = t._pannerAttr.panningModel),
                      typeof t._panner.positionX < 'u'
                        ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime),
                          t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime),
                          t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime))
                        : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]),
                      typeof t._panner.orientationX < 'u'
                        ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime),
                          t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime),
                          t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime))
                        : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2]))
                    : ((t._panner = Howler.ctx.createStereoPanner()),
                      t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)),
                  t._panner.connect(t._node),
                  t._paused || t._parent.pause(t._id, !0).play(t._id, !0);
              };
            })();
          })(ts)),
        ts
      );
    }
    var Ii = Rq();
    const Bq =
      '[PLACEHOLDER:audio/mpeg]',
      Nq =
        '[PLACEHOLDER:audio/mpeg]',
      Qq =
        '[PLACEHOLDER:audio/mpeg]',
      wq =
        '[PLACEHOLDER:audio/mpeg]',
      Pq =
        '[PLACEHOLDER:audio/mpeg]',
      Jq =
        '[PLACEHOLDER:audio/mpeg]',
      Gq =
        '[PLACEHOLDER:audio/mpeg]',
      Wq =
        '[PLACEHOLDER:audio/mpeg]',
      Kq = {
        jump: { url: Bq, volume: 0.5 },
        hit: { url: Nq, volume: 0.6 },
        hurt: { url: Qq, volume: 0.7 },
        collect: { url: wq, volume: 0.4 },
        step: { url: Pq, volume: 0.3 },
        win: { url: Jq, volume: 0.8 },
        lose: { url: Gq, volume: 0.8 },
        music: { url: Wq, loop: !0, volume: 0.3 },
      };
    class Fq {
      constructor() {
        V(this, 'sounds', new Map());
        V(this, 'musicId', null);
        V(this, 'isUnlocked', !1);
      }
      async init() {
        const e = [];
        for (const [t, A] of Object.entries(Kq)) {
          const r = new Promise((s) => {
            const n = new Ii.Howl({
              src: [A.url],
              loop: A.loop ?? !1,
              volume: A.volume ?? 1,
              preload: !0,
              onload: () => {
                s();
              },
              onloaderror: (a, l) => {
                s();
              },
            });
            this.sounds.set(t, n);
          });
          e.push(r);
        }
        await Promise.all(e);
      }
      unlock() {
        this.isUnlocked || (this.isUnlocked = !0);
      }
      play(e) {
        if (!this.isUnlocked) return;
        const t = this.sounds.get(e);
        if (t)
          if (e === 'music') {
            if (this.musicId !== null) return;
            this.musicId = t.play();
          } else t.play();
      }
      stop(e) {
        const t = this.sounds.get(e);
        t && (t.stop(), e === 'music' && (this.musicId = null));
      }
      stopMusic() {
        this.stop('music');
      }
      pause() {
        Ii.Howler.mute(!0);
      }
      resume() {
        this.isUnlocked && Ii.Howler.mute(!1);
      }
      setMuted(e) {
        Ii.Howler.mute(e), e && this.stopMusic();
      }
      get unlocked() {
        return this.isUnlocked;
      }
    }
    const xe = new Fq(),
      Yq =
        '[PLACEHOLDER:image/png]',
      Kl =
        '[PLACEHOLDER:image/webp]',
      Fl =
        '[PLACEHOLDER:image/webp]',
      Dq =
        '[PLACEHOLDER:image/png]',
      Oq =
        '[PLACEHOLDER:image/webp]',
      Lq =
        '[PLACEHOLDER:image/png]',
      jq =
        '[PLACEHOLDER:image/png]';
    class Zq {
      constructor() {
        V(this, 'app');
        V(this, 'adapter');
        V(this, 'gameController');
        V(this, 'overlayContainer');
        V(this, 'confettiEmitter');
        V(this, 'uiContainer');
        V(this, 'hpDisplay');
        V(this, 'scoreContainer');
        V(this, 'scoreDisplay');
        V(this, 'tutorialOverlay');
        V(this, 'tutorialText');
        V(this, 'endOverlay');
        V(this, 'endTitle');
        V(this, 'endSubtitle');
        V(this, 'endAmount');
        V(this, 'countdownContainer');
        V(this, 'countdownTime');
        V(this, 'countdownInterval');
        V(this, 'failOverlay');
        V(this, 'ctaButton');
        V(this, 'gameFooter');
        V(this, 'paypalCardContainer');
        V(this, 'lightsEffect');
        V(this, 'balanceAnimationId');
        V(this, 'collectiblesCount', 0);
        V(this, 'nextPraiseAt', 3);
        (this.app = new dn()), (this.adapter = new qp());
      }
      async init() {
        Jl(),
          await this.app.init({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 16573654,
            resolution: Math.min(window.devicePixelRatio || 1, 2),
            autoDensity: !0,
            antialias: !0,
            resizeTo: window,
          });
        const e = document.getElementById('game-container');
        e ? e.appendChild(this.app.canvas) : document.body.appendChild(this.app.canvas), this.setupResponsiveScaling();
        const t = () => {
          this.setupResponsiveScaling(), this.scoreDisplay && this.fitTextToContainer(this.scoreDisplay, 28, 12);
        };
        window.addEventListener('resize', t),
          window.addEventListener('orientationchange', () => {
            setTimeout(t, 100);
          }),
          this.createUI(),
          await xe.init(),
          (this.gameController = new Iq(this.app)),
          await this.gameController.init(),
          await this.initFinishEffects(),
          this.setupGameEvents(),
          this.setupInput(),
          this.setupMraidEvents(),
          this.app.ticker.add(() => this.update()),
          this.showTutorial('start');
      }
      async initFinishEffects() {
        (this.overlayContainer = new _()),
          (this.overlayContainer.zIndex = me.OVERLAY),
          (this.overlayContainer.visible = !1),
          this.app.stage.addChild(this.overlayContainer);
        const e = new Ut();
        e.rect(-2e3, 0, 5e3, Me),
          e.fill({ color: 0, alpha: 0.6 }),
          this.overlayContainer.addChild(e),
          (this.confettiEmitter = new kq()),
          await this.confettiEmitter.init(),
          (this.confettiEmitter.zIndex = me.CONFETTI),
          this.app.stage.addChild(this.confettiEmitter),
          (this.app.stage.sortableChildren = !0);
      }
      createUI() {
        const t = document.getElementById('ui-container');
        (this.uiContainer = t || document.createElement('div')),
          (this.uiContainer.id = 'ui-container'),
          t ? this.uiContainer.replaceChildren() : document.body.appendChild(this.uiContainer);
        const e = this.createHeader();
        this.uiContainer.appendChild(e),
          (this.tutorialOverlay = this.createTutorialOverlay()),
          this.uiContainer.appendChild(this.tutorialOverlay),
          (this.endOverlay = this.createEndOverlay()),
          this.uiContainer.appendChild(this.endOverlay),
          (this.failOverlay = this.createFailOverlay()),
          this.uiContainer.appendChild(this.failOverlay),
          (this.gameFooter = this.createFooter()),
          this.uiContainer.appendChild(this.gameFooter),
          this.addStyles();
      }
      createHeader() {
        const e = document.createElement('div');
        (e.className = 'game-header'),
          (this.hpDisplay = document.createElement('div')),
          (this.hpDisplay.className = 'hp-container'),
          (this.hpDisplay.id = 'hp-display'),
          this.renderHearts(Yi.MAX_HP),
          e.appendChild(this.hpDisplay),
          (this.scoreContainer = document.createElement('div')),
          (this.scoreContainer.className = 'paypal-counter');
        const t = document.createElement('img');
        return (
          (t.src = Oq),
          (t.alt = 'PayPal Balance'),
          (t.className = 'paypal-counter-image'),
          this.scoreContainer.appendChild(t),
          (this.scoreDisplay = document.createElement('span')),
          (this.scoreDisplay.className = 'paypal-counter-amount'),
          (this.scoreDisplay.id = 'score-display'),
          (this.scoreDisplay.textContent = `${ae.currencySymbol}0`),
          (this.scoreDisplay.style.fontSize = '28px'),
          this.scoreContainer.appendChild(this.scoreDisplay),
          e.appendChild(this.scoreContainer),
          e
        );
      }
      renderHearts(e) {
        for (; this.hpDisplay.firstChild;) this.hpDisplay.removeChild(this.hpDisplay.firstChild);
        for (let t = 0; t < Yi.MAX_HP; t++) {
          const A = document.createElement('span');
          (A.className = t < e ? 'heart filled' : 'heart empty'), (A.textContent = ''), this.hpDisplay.appendChild(A);
        }
      }
      createTutorialOverlay() {
        const e = document.createElement('div');
        (e.className = 'tutorial-overlay'),
          (this.tutorialText = document.createElement('div')),
          (this.tutorialText.className = 'tutorial-text'),
          (this.tutorialText.id = 'tutorial-text'),
          (this.tutorialText.textContent = ae.tutorial.tapToStart),
          e.appendChild(this.tutorialText);
        const t = document.createElement('div');
        t.className = 'tutorial-hand';
        const A = document.createElement('img');
        return (A.src = Yq), (A.alt = 'tap'), (A.className = 'hand-icon'), t.appendChild(A), e.appendChild(t), e;
      }
      createEndOverlay() {
        const e = document.createElement('div');
        e.className = 'end-overlay hidden';
        const t = document.createElement('div');
        (t.className = 'end-content'),
          (this.endTitle = document.createElement('h1')),
          (this.endTitle.className = 'end-title'),
          (this.endTitle.id = 'end-title'),
          (this.endTitle.textContent = ae.winScreen.title),
          t.appendChild(this.endTitle),
          (this.endSubtitle = document.createElement('h2')),
          (this.endSubtitle.className = 'end-subtitle'),
          (this.endSubtitle.id = 'end-subtitle'),
          (this.endSubtitle.textContent = ae.winScreen.subtitle),
          t.appendChild(this.endSubtitle);
        const A = document.createElement('div');
        A.className = 'paypal-card-wrapper';
        const r = document.createElement('img');
        (r.src = jq),
          (r.className = 'lights-effect'),
          (r.alt = ''),
          (this.lightsEffect = r),
          A.appendChild(this.lightsEffect),
          (this.paypalCardContainer = document.createElement('div')),
          (this.paypalCardContainer.className = 'paypal-card-container');
        const s = document.createElement('img');
        (s.src = Ep),
          (s.className = 'paypal-card-image'),
          (s.alt = 'PayPal'),
          this.paypalCardContainer.appendChild(s),
          (this.endAmount = document.createElement('span')),
          (this.endAmount.className = 'paypal-card-amount'),
          (this.endAmount.id = 'end-amount'),
          (this.endAmount.textContent = `${ae.currencySymbol}0.00`),
          this.paypalCardContainer.appendChild(this.endAmount),
          A.appendChild(this.paypalCardContainer),
          t.appendChild(A),
          (this.countdownContainer = document.createElement('div')),
          (this.countdownContainer.className = 'countdown'),
          (this.countdownTime = document.createElement('span')),
          (this.countdownTime.className = 'countdown-time'),
          (this.countdownTime.id = 'countdown-time'),
          (this.countdownTime.textContent = '00:58'),
          this.countdownContainer.appendChild(this.countdownTime);
        const n = document.createElement('span');
        return (
          (n.className = 'countdown-text'),
          (n.textContent = ae.endScreen.nextPayment),
          this.countdownContainer.appendChild(n),
          t.appendChild(this.countdownContainer),
          (this.ctaButton = document.createElement('button')),
          (this.ctaButton.className = 'cta-button'),
          (this.ctaButton.id = 'cta-button'),
          (this.ctaButton.textContent = ae.endScreen.ctaButton),
          t.appendChild(this.ctaButton),
          e.appendChild(t),
          e
        );
      }
      createFailOverlay() {
        const e = document.createElement('div');
        e.className = 'fail-overlay hidden';
        const t = document.createElement('img');
        return (t.src = Dq), (t.className = 'fail-image'), (t.alt = 'FAIL'), e.appendChild(t), e;
      }
      createFooter() {
        const e = document.createElement('div');
        (e.className = 'game-footer'),
          e.style.setProperty('--footer-landscape', `url(${Kl})`),
          e.style.setProperty('--footer-portrait', `url(${Fl})`);
        const t = document.createElement('button');
        return (t.className = 'footer-cta'), (t.id = 'footer-cta'), (t.textContent = ae.buttons.download), e.appendChild(t), e;
      }
      addStyles() {
        document.documentElement.style.setProperty('--footer-portrait', `url(${Fl})`),
          document.documentElement.style.setProperty('--footer-landscape', `url(${Kl})`);
      }
      setupGameEvents() {
        this.gameController.on('stateChange', (e) => {
          const { to: t } = e;
          this.onStateChange(t);
        }),
          this.gameController.on('hit', (e) => {
            const { hp: t } = e;
            this.updateHP(t), xe.play('hit'), xe.play('hurt');
          }),
          this.gameController.on('collect', (e) => {
            const { score: t, from: A, collectibleType: r } = e;
            this.handleCollect(A, r || 'dollar', t), xe.play('collect');
          }),
          this.gameController.on('showTutorial', (e) => {
            const { type: t } = e;
            this.showTutorial(t);
          }),
          this.gameController.on('win', (e) => {
            const { score: t } = e;
            xe.stopMusic(), xe.play('win'), this.showEndScreen(!0, t);
          }),
          this.gameController.on('lose', (e) => {
            const { score: t } = e;
            xe.stopMusic(), xe.play('lose'), this.showEndScreen(!1, t);
          }),
          this.gameController.on('crossedFinish', () => {
            this.triggerFinishEffects();
          }),
          this.gameController.on('jump', () => {
            xe.play('jump');
          });
      }
      setupInput() {
        this.app.canvas.addEventListener('pointerdown', () => {
          xe.unlock(), this.gameController.handleTap();
        }),
          document.getElementById('cta-button')?.addEventListener('click', () => {
            this.adapter.download();
          }),
          document.getElementById('footer-cta')?.addEventListener('click', () => {
            this.adapter.download();
          });
      }
      onStateChange(e) {
        switch (e) {
          case ge.RUNNING:
            this.hideTutorial(), xe.play('music');
            break;
        }
      }
      showTutorial(e) {
        (this.tutorialText.textContent = e === 'start' ? ae.tutorial.tapToStart : ae.tutorial.tapToJump),
          this.tutorialOverlay.classList.remove('hidden');
      }
      hideTutorial() {
        this.tutorialOverlay.classList.add('hidden'),
          document.querySelectorAll('.tutorial-overlay').forEach((e) => e.classList.add('hidden'));
      }
      updateHP(e) {
        this.renderHearts(e);
      }
      animateFlyingCollectible(e, t) {
        const A = this.app.stage.scale.x,
          r = this.app.stage.position.x,
          s = e.x * A + r,
          n = e.y * A,
          a = this.scoreContainer.getBoundingClientRect(),
          l = a.left + a.width / 2,
          h = a.top + a.height / 2,
          u = document.createElement('div');
        (u.className = 'flying-collectible'), u.style.setProperty('--fly-duration', '0.4s');
        const o = document.createElement('img');
        (o.src = t === 'dollar' ? Mp : Lq), u.appendChild(o), (u.style.left = `${s}px`), (u.style.top = `${n}px`);
        const c = `fly-${Date.now()}`,
          d = `
      @keyframes ${c} {
        0% {
          left: ${s}px;
          top: ${n}px;
          opacity: 1;
          transform: scale(1);
        }
        100% {
          left: ${l}px;
          top: ${h}px;
          opacity: 0.8;
          transform: scale(0.5);
        }
      }
    `,
          f = document.createElement('style');
        (f.textContent = d),
          document.head.appendChild(f),
          (u.style.animation = `${c} 0.4s ease-in forwards`),
          document.body.appendChild(u),
          u.addEventListener('animationend', () => {
            this.scoreContainer.classList.remove('pulse'),
              this.scoreContainer.offsetWidth,
              this.scoreContainer.classList.add('pulse'),
              u.remove(),
              f.remove();
          });
      }
      updateScore(e) {
        (this.scoreDisplay.textContent = `${ae.currencySymbol}${Math.floor(e)}`),
          this.fitTextToContainer(this.scoreDisplay, 28, 12);
      }
      fitTextToContainer(e, t, A) {
        let r = t;
        e.style.fontSize = `${r}px`;
        const s = e.offsetWidth;
        for (; e.scrollWidth > s && r > A;) (r -= 1), (e.style.fontSize = `${r}px`);
      }
      showPraisePopup() {
        const e = ae.praise,
          t = e[Math.floor(Math.random() * e.length)],
          A = document.createElement('div');
        (A.className = 'praise-popup'), (A.textContent = t);
        const r = window.innerWidth,
          s = window.innerHeight,
          n = (Math.random() - 0.5) * 60,
          a = (Math.random() - 0.5) * 40;
        (A.style.left = `${r / 2 + n}px`),
          (A.style.top = `${s * 0.4 + a}px`),
          document.body.appendChild(A),
          A.addEventListener('animationend', () => {
            A.remove();
          });
      }
      handleCollect(e, t, A) {
        this.animateFlyingCollectible(e, t),
          this.updateScore(A),
          this.collectiblesCount++,
          this.collectiblesCount >= this.nextPraiseAt &&
          (this.showPraisePopup(), (this.collectiblesCount = 0), (this.nextPraiseAt = 3 + Math.floor(Math.random() * 2)));
      }
      showEndScreen(e, t) {
        (this.gameFooter.style.display = 'none'),
          (this.endTitle.textContent = e ? ae.winScreen.title : ae.loseScreen.title),
          (this.endSubtitle.textContent = e ? ae.winScreen.subtitle : ae.loseScreen.subtitle),
          e ? this.ctaButton.classList.remove('lose') : this.ctaButton.classList.add('lose'),
          e
            ? (this.endOverlay.classList.remove('hidden'), this.playEndScreenAnimations(t), this.startCountdown(60))
            : this.showFailAnimation(t);
      }
      playEndScreenAnimations(e) {
        this.resetEndScreenAnimations(),
          this.paypalCardContainer.classList.add('animate-scale'),
          this.lightsEffect.classList.add('animate-lights'),
          setTimeout(() => {
            this.animateBalance(e);
          }, 600);
      }
      resetEndScreenAnimations() {
        this.balanceAnimationId && (cancelAnimationFrame(this.balanceAnimationId), (this.balanceAnimationId = void 0)),
          (this.endAmount.textContent = `${ae.currencySymbol}0.00`),
          this.paypalCardContainer.classList.remove('animate-scale'),
          this.lightsEffect.classList.remove('animate-lights'),
          this.paypalCardContainer.offsetHeight;
      }
      animateBalance(e) {
        const A = performance.now(),
          r = (s) => {
            const n = s - A,
              a = Math.min(n / 1e3, 1),
              l = 1 - Math.pow(1 - a, 3),
              h = e * l;
            (this.endAmount.textContent = `${ae.currencySymbol}${h.toFixed(2)}`),
              a < 1 && (this.balanceAnimationId = requestAnimationFrame(r));
          };
        this.balanceAnimationId = requestAnimationFrame(r);
      }
      showFailAnimation(e) {
        const t = this.failOverlay.querySelector('.fail-image');
        t && ((t.style.animation = 'none'), t.offsetHeight, (t.style.animation = '')),
          this.failOverlay.classList.remove('hidden'),
          setTimeout(() => {
            this.failOverlay.classList.add('hidden'),
              this.endOverlay.classList.remove('hidden'),
              this.playEndScreenAnimations(e),
              this.startCountdown(60);
          }, 1500);
      }
      startCountdown(e) {
        this.countdownInterval && clearInterval(this.countdownInterval);
        let t = e;
        (this.countdownContainer.style.display = 'block'),
          this.updateCountdownDisplay(t),
          (this.countdownInterval = setInterval(() => {
            t--,
              t <= 0
                ? ((this.countdownContainer.style.display = 'none'),
                  this.countdownInterval && (clearInterval(this.countdownInterval), (this.countdownInterval = void 0)))
                : this.updateCountdownDisplay(t);
          }, 1e3));
      }
      updateCountdownDisplay(e) {
        const t = Math.floor(e / 60),
          A = e % 60;
        this.countdownTime.textContent = `${t.toString().padStart(2, '0')}:${A.toString().padStart(2, '0')}`;
      }
      triggerFinishEffects() {
        (this.overlayContainer.visible = !0), this.confettiEmitter.burstFromSides($e, Me);
      }
      setupResponsiveScaling() {
        Jl();
        const e = window.innerWidth,
          A = window.innerHeight / Me;
        this.app.stage.scale.set(A);
        const r = $e * A,
          s = (e - r) / 2;
        this.app.stage.position.set(s, 0);
        const n = this.app.canvas;
        (n.style.position = 'absolute'), (n.style.left = '0'), (n.style.top = '0');
      }
      setupMraidEvents() {
        this.adapter.on('viewableChange', (e) => {
          e ? this.resume() : this.pause();
        });
      }
      pause() {
        this.app.ticker.stop(), this.gameController.pause(), xe.pause();
      }
      resume() {
        this.app.ticker.start(), this.gameController.resume(), xe.resume();
      }
      update() {
        const e = this.app.ticker.deltaMS;
        this.gameController.update(e);
      }
      destroy() {
        this.confettiEmitter.clear(), this.adapter.destroy(), this.app.destroy(!0), this.uiContainer.remove();
      }
    }
    function Xq() {
      return Promise.resolve();
    }
    async function Hq() {
      await document.fonts.ready;
    }
    async function zq() {
      await Xq(), new qp(), await Hq(), await new Zq().init();
    }
    zq().catch((i) => { });
    window.__INLINE_ASSETS__ = { Yq, Dq, Oq, jq, Ep };
    Q.add(Jh);
    Q.mixin(_, Gh);
    Q.add(fn);
    Q.add(pn);
    Q.add(wn);
    Q.mixin(_, Yu);
    Q.add(Nn);
    Q.add($a);
    Q.add(ar);
    Q.add(eo);
    Q.add(Ao);
    Q.add(io);
    Q.add(co);
    Q.add(ho);
    Q.add(no);
    Q.add(lo);
    Q.add(ao);
    Q.add(so);
    Q.add(ro);
    Q.add(Jn);
    Q.add(Pn);
    const _q = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: 'Module' })),
      $q = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: 'Module' }));
  </script>
  <style rel="stylesheet" crossorigin="">
    @font-face {
      font-family: GameFont;
      font-weight: 400;
      font-style: normal;
      font-display: block;
    }

    html,
    body,
    * {
      font-family: GameFont, sans-serif !important;
    }

    #ui-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    #ui-container * {
      pointer-events: auto;
    }

    .game-header {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
    }

    .hp-container {
      display: flex;
      gap: 5px;
    }

    .heart {
      font-size: 28px;
      filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.3));
    }

    .heart.empty {
      opacity: 0.3;
    }

    .paypal-counter {
      position: relative;
      display: inline-block;
      height: clamp(50px, 12vh, 80px);
    }

    .paypal-counter-image {
      height: 100%;
      width: auto;
      display: block;
    }

    .paypal-counter-amount {
      position: absolute;
      top: 50%;
      left: 52%;
      right: 6%;
      transform: translateY(-50%);
      text-align: center;
      font-weight: 900;
      color: #003087;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
      white-space: nowrap;
    }

    .paypal-counter.pulse {
      animation: counter-pulse 0.3s ease-out;
    }

    @keyframes counter-pulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.15);
      }

      to {
        transform: scale(1);
      }
    }

    .flying-collectible {
      position: fixed;
      width: 40px;
      height: 40px;
      pointer-events: none;
      z-index: 500;
    }

    .flying-collectible img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      animation: spin-collectible var(--fly-duration, 0.5s) linear forwards;
    }

    @keyframes spin-collectible {
      0% {
        transform: rotate(0);
      }

      to {
        transform: rotate(720deg);
      }
    }

    .tutorial-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
      pointer-events: none !important;
    }

    .tutorial-overlay * {
      pointer-events: none !important;
    }

    .tutorial-overlay.hidden {
      display: none;
    }

    .tutorial-text {
      font-size: clamp(28px, 6vw, 42px);
      color: #fff;
      font-weight: 900;
      text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, -2px 0 0 #000, 2px 0 0 #000,
        0 -2px 0 #000, 0 2px 0 #000;
      margin-bottom: 20px;
    }

    .tutorial-hand {
      position: fixed;
      bottom: -25vh;
      left: 50%;
      transform: translate(-50%);
      pointer-events: none !important;
    }

    .hand-icon {
      width: 80px;
      height: auto;
      pointer-events: none !important;
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes pulse {

      0%,
      to {
        transform: scale(1);
      }

      50% {
        transform: scale(1.1);
      }
    }

    .praise-popup {
      position: fixed;
      font-size: clamp(36px, 8vw, 56px);
      color: #fff;
      font-weight: 900;
      text-shadow: -3px -3px 0 #000, 3px -3px 0 #000, -3px 3px 0 #000, 3px 3px 0 #000, -3px 0 0 #000, 3px 0 0 #000,
        0 -3px 0 #000, 0 3px 0 #000;
      pointer-events: none;
      z-index: 400;
      animation: praise-pop 1s ease-out forwards;
    }

    @keyframes praise-pop {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }

      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }

      40% {
        transform: translate(-50%, -50%) scale(1);
      }

      80% {
        opacity: 1;
        transform: translate(-50%, -70%) scale(1);
      }

      to {
        opacity: 0;
        transform: translate(-50%, -100%) scale(0.8);
      }
    }

    .warning-label {
      position: fixed;
      font-size: clamp(24px, 6vw, 36px);
      font-weight: 900;
      color: red;
      background: #ffe600f2;
      border: 4px solid #ffcc00;
      border-radius: 8px;
      padding: 8px 20px;
      pointer-events: none;
      z-index: 350;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
      box-shadow: 0 4px 8px #0006, inset 0 2px #ffffff4d;
      animation: warning-pulse 0.5s ease-in-out infinite;
      transform: translate(-50%, -100%);
    }

    @keyframes warning-pulse {

      0%,
      to {
        transform: translate(-50%, -100%) scale(1);
        border-color: #fc0;
      }

      50% {
        transform: translate(-50%, -100%) scale(1.1);
        border-color: #fff700;
      }
    }

    .end-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 300;
      overflow: visible;
    }

    .end-overlay.hidden {
      display: none;
    }

    .end-content {
      text-align: center;
      color: #fff;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      max-height: 90vh;
      overflow: visible;
    }

    .end-title {
      font-size: 32px;
      font-weight: 900;
      margin-bottom: 10px;
      text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 3px 6px rgba(0, 0, 0, 0.5);
    }

    .end-subtitle {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 30px;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 2px 4px rgba(0, 0, 0, 0.5);
    }

    .paypal-card-wrapper {
      position: relative;
      display: inline-block;
      margin-bottom: 20px;
      overflow: visible;
    }

    .lights-effect {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 400px;
      max-width: 100vw;
      height: auto;
      transform: translate(-50%, -50%) scale(1.5);
      opacity: 0;
      z-index: 0;
      pointer-events: none;
    }

    .lights-effect.animate-lights {
      animation: lights-fade-in 0.5s ease-out forwards, lights-rotate 8s linear 0.3s infinite;
    }

    @keyframes lights-fade-in {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1);
      }

      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.5);
      }
    }

    @keyframes lights-rotate {
      0% {
        transform: translate(-50%, -50%) scale(1.5) rotate(0);
      }

      to {
        transform: translate(-50%, -50%) scale(1.5) rotate(360deg);
      }
    }

    .paypal-card-container {
      position: relative;
      display: inline-block;
      z-index: 1;
      transform: scale(0);
    }

    .paypal-card-container.animate-scale {
      animation: card-scale-bounce 0.6s cubic-bezier(0.34, 1, 0.64, 1) forwards;
    }

    @keyframes card-scale-bounce {
      0% {
        transform: scale(0);
      }

      60% {
        transform: scale(1.5);
      }

      to {
        transform: scale(1);
      }
    }

    .paypal-card-image {
      width: 280px;
      max-width: 70vw;
      height: auto;
      border-radius: 12px;
      box-shadow: 0 8px 24px #0006;
    }

    .paypal-card-amount {
      position: absolute;
      bottom: 30px;
      right: 16px;
      font-size: clamp(24px, 10vw, 48px);
      font-weight: 900;
      color: #fff;
      text-shadow: -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 2px 2px 0 #000, 0 3px 6px rgba(0, 0, 0, 0.5);
    }

    .countdown {
      margin-bottom: 20px;
    }

    .countdown-time {
      font-size: 36px;
      font-weight: 700;
      display: block;
    }

    .countdown-text {
      font-size: 14px;
      opacity: 0.8;
    }

    .cta-button {
      background: linear-gradient(180deg, #ffe44d, #ffb830, #ff9500);
      border: 3px solid #e07800;
      color: #fff;
      font-size: clamp(14px, 9vw, 26px);
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 16px 48px;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 4px #c06000, 0 6px 8px #0000004d, inset 0 2px #fff6;
      text-shadow: -1px -1px 0 #000000ff, 1px -1px 0 #000000ff, -1px 1px 0 #000000ff, 1px 1px 0 #000000ff,
        0 2px 3px rgba(0, 0, 0, 0.3);
      animation: pulse-button 1s ease-in-out infinite;
    }

    .cta-button.lose {
      background: linear-gradient(180deg, #ff6b6b, #e44, #c22);
      border-color: #a11;
      box-shadow: 0 4px #000, 0 6px 8px #0000004d, inset 0 2px #fff6;
      text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 2px 3px rgba(0, 0, 0, 0.3);
    }

    @keyframes pulse-button {

      0%,
      to {
        transform: scale(0.9);
      }

      50% {
        transform: scale(1.1);
      }
    }

    .fail-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000c;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 350;
    }

    .fail-overlay.hidden {
      display: none;
    }

    .fail-image {
      width: 60vmin;
      height: 60vmin;
      max-width: 400px;
      max-height: 400px;
      animation: fail-scale-in 0.8s ease-out forwards;
    }

    @keyframes fail-scale-in {
      0% {
        transform: scale(0);
        opacity: 0;
      }

      70% {
        transform: scale(1.2);
        opacity: 1;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .game-footer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background-image: var(--footer-portrait);
      background-size: 100% auto;
      background-position: center bottom;
      background-repeat: no-repeat;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 20px;
      aspect-ratio: 5.37 / 1;
    }

    .footer-cta {
      background: linear-gradient(180deg, #ffe44d, #ffb830, #ff9500);
      border: 3px solid #e07800;
      color: #fff;
      font-size: clamp(10px, 2.5vw, 16px);
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 1.5vh 3vw;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 4px #c06000, 0 6px 8px #0000004d, inset 0 2px #fff6;
      text-shadow: -1px -1px 0 #000000ff, 1px -1px 0 #000000ff, -1px 1px 0 #000000ff, 1px 1px 0 #000000ff,
        0 2px 3px rgba(0, 0, 0, 0.3);
      max-width: 30vw;
      white-space: nowrap;
      animation: pulse-button 1s ease-in-out infinite;
    }

    .footer-cta:active {
      transform: translateY(2px);
      box-shadow: 0 2px #c06000, 0 3px 4px #0000004d, inset 0 2px #fff6;
    }

    @media (orientation: landscape) {
      .game-footer {
        background-image: var(--footer-landscape);
        aspect-ratio: 10 / 1;
      }

      .end-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 10px;
        padding: 10px 20px;
        max-height: 100vh;
      }

      .end-title {
        font-size: clamp(18px, 4vh, 28px);
        margin-bottom: 5px;
      }

      .end-subtitle {
        font-size: clamp(12px, 2.5vh, 16px);
        margin-bottom: 10px;
      }

      .paypal-card-wrapper {
        margin-bottom: 10px;
      }

      .lights-effect {
        width: 250px;
      }

      .paypal-card-image {
        width: auto;
        height: clamp(80px, 25vh, 150px);
        max-width: 50vw;
      }

      .paypal-card-amount {
        font-size: clamp(14px, 6vh, 24px);
        bottom: 15px;
        right: 10px;
      }

      .countdown {
        margin-bottom: 10px;
      }

      .countdown-time {
        font-size: clamp(20px, 5vh, 32px);
      }

      .countdown-text {
        font-size: clamp(10px, 2vh, 14px);
      }

      .cta-button {
        font-size: clamp(12px, 2.5vh, 18px);
        padding: 10px 30px;
      }

      .fail-image {
        width: 40vmin;
        height: 40vmin;
        max-width: 250px;
        max-height: 250px;
      }
    }
  </style>
</head>

<body>
  <div id="game-container">
    <canvas width="2604" height="1966"
      style="width: 1302px; height: 983px; touch-action: none; position: absolute; left: 0px; top: 0px; cursor: inherit"></canvas>
  </div>
  <button title="select to enable accessibility for this content" style="
        width: 1px;
        height: 1px;
        position: absolute;
        top: -1000px;
        left: -1000px;
        z-index: 2;
        background-color: rgb(255, 0, 0);
      "></button>
  <div id="ui-container">
    <div class="game-header">
      <div class="hp-container" id="hp-display">
        <span class="heart filled"></span><span class="heart filled"></span><span class="heart filled"></span>
      </div>
      <div class="paypal-counter">
        <img src="" alt="PayPal Balance" class="paypal-counter-image" data-asset="Oq" /><span
          class="paypal-counter-amount" id="score-display" style="font-size: 28px">$0</span>
      </div>
    </div>
    <div class="tutorial-overlay">
      <div class="tutorial-text" id="tutorial-text">Tap to start earning!</div>
      <div class="tutorial-hand">
        <img src="" alt="tap" class="hand-icon" data-asset="Yq" />
      </div>
    </div>
    <div class="end-overlay hidden">
      <div class="end-content">
        <h1 class="end-title" id="end-title">Congratulations!</h1>
        <h2 class="end-subtitle" id="end-subtitle">Choose your reward!</h2>
        <div class="paypal-card-wrapper">
          <img src="" class="lights-effect" alt="" data-asset="jq" />
          <div class="paypal-card-container">
            <img src="" class="paypal-card-image" alt="PayPal" data-asset="Ep" /><span class="paypal-card-amount"
              id="end-amount">$0.00</span>
          </div>
        </div>
        <div class="countdown">
          <span class="countdown-time" id="countdown-time">00:58</span><span class="countdown-text">Next payment in one
            minute</span>
        </div>
        <button class="cta-button" id="cta-button">Install and Earn</button>
      </div>
    </div>
    <div class="fail-overlay hidden">
      <img src="" class="fail-image" alt="FAIL" data-asset="Dq" />
    </div>
    <div class="game-footer">
      <button class="footer-cta" id="footer-cta">DOWNLOAD</button>
    </div>
  </div>
  <script>
    (function () {
      const a = window.__INLINE_ASSETS__;
      if (!a) return;
      const map = {
        'paypal-counter-image': 'Oq',
        'hand-icon': 'Yq',
        'lights-effect': 'jq',
        'paypal-card-image': 'Ep',
        'fail-image': 'Dq',
      };
      for (const [cls, key] of Object.entries(map)) {
        const el = document.querySelector(`.${cls}[data-asset]`);
        if (el) el.src = a[key];
      }
    })();
  </script>
</body>

</html>