<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta name="robots" content="noindex, nofollow" />
    <title>runner | Playbox</title>

    <link rel="icon" type="image/png" sizes="32x32" href="https://app.plbx.ai/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="https://app.plbx.ai/favicon-16x16.png" />
    <link rel="apple-touch-icon" href="https://app.plbx.ai/apple-touch-icon.png" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <style>
      /* Reset */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        background: #121215;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }

      /* ========== PRELOADER ========== */
      .preloader {
        position: absolute;
        inset: 0;
        background: #121215;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100;
        overflow: visible;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }
      .preloader.hide {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }
      .preloader-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        overflow: visible;
      }
      /* Logo container for bounce animation */
      .preloader-logo {
        position: relative;
        width: 48px;
        height: 48px;
      }
      /* Individual circles */
      .bounce-circle {
        position: absolute;
        border-radius: 50%;
        will-change: transform, box-shadow;
        opacity: 0;
      }
      .bounce-circle.circle-1 {
        background: linear-gradient(145deg, #ffe55c 0%, #ffc700 25%, #ff9500 50%, #ff6b00 75%, #e85d04 100%);
      }
      .bounce-circle.circle-2 {
        background: linear-gradient(135deg, #c084fc 0%, #a855f7 25%, #8b5cf6 50%, #7c3aed 75%, #6d28d9 100%);
      }
      .bounce-circle.circle-3 {
        background: linear-gradient(160deg, #00cfff 0%, #00b4ff 25%, #0099ff 50%, #0085ff 75%, #3b82f6 100%);
      }
      .bounce-circle.circle-4 {
        background: linear-gradient(140deg, #ffb347 0%, #ff8c94 25%, #fc56b8 50%, #d946ef 75%, #a855f7 100%);
      }
      .preloader-text {
        font-size: 1rem;
        font-weight: 600;
        background: linear-gradient(135deg, #ff9500 0%, #ff6b9d 33%, #c850c0 66%, #6366f1 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        filter: drop-shadow(0 0 0 transparent);
        transition: filter 0.05s ease-out;
      }
      .preloader-vpn-hint {
        font-size: 0.75rem;
        color: rgba(255, 255, 255, 0.4);
        text-align: center;
        max-width: 200px;
        line-height: 1.4;
        opacity: 0;
        transition: opacity 0.5s ease;
      }
      .preloader-vpn-hint.show {
        opacity: 1;
      }

      /* ========== FULL-SCREEN IFRAME ========== */
      .mobile-container {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        background: #000;
      }
      .mobile-container iframe {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        border: none;
        background: #000;
      }

      /* Disable text selection globally */
      * {
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }

      /* ========== APP STORE CARD MODAL (Bottom Sheet) ========== */
      .store-card-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: flex-end;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.25s ease, visibility 0.25s ease;
      }
      .store-card-overlay.show {
        opacity: 1;
        visibility: visible;
      }
      .store-card {
        position: relative;
        background: #1c1c1e;
        border-radius: 16px 16px 0 0;
        padding: 16px 20px 24px;
        width: 100%;
        max-width: 100%;
        box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.4);
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
        padding-bottom: calc(24px + env(safe-area-inset-bottom, 0px));
      }
      .store-card-overlay.show .store-card {
        transform: translateY(0);
      }
      /* Drag handle indicator at top */
      .store-card::before {
        content: '';
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
        width: 36px;
        height: 4px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
      }
      .store-card-close {
        position: absolute;
        top: 20px;
        right: 16px;
        width: 28px;
        height: 28px;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 50%;
        color: rgba(255, 255, 255, 0.6);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        line-height: 1;
      }
      .store-card-header {
        display: flex;
        gap: 14px;
        align-items: flex-start;
        margin-top: 8px;
        padding-right: 36px;
      }
      .store-card-icon {
        width: 64px;
        height: 64px;
        border-radius: 14px;
        background: #2c2c2e;
        object-fit: cover;
        flex-shrink: 0;
      }
      .store-card-info {
        flex: 1;
        min-width: 0;
      }
      .store-card-title {
        font-size: 17px;
        font-weight: 600;
        color: #fff;
        margin: 0 0 4px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .store-card-developer {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.6);
        margin: 0 0 6px;
      }
      .store-card-rating {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.5);
      }
      .store-card-stars {
        color: #ffcc00;
        letter-spacing: -1px;
        display: inline-flex;
        align-items: center;
      }
      /* Half star styling - overlay approach for smooth horizontal fill */
      .half-star {
        position: relative;
        display: inline-block;
        width: 1em;
        height: 1em;
        line-height: 1;
      }
      .half-star-bg {
        color: #ffcc00;
        position: absolute;
        top: 0;
        left: 0;
      }
      .half-star-fill {
        position: absolute;
        top: 0;
        left: 0;
        width: 50%;
        overflow: hidden;
        color: #ffcc00;
      }
      /* Connect with Playbox button - Playbox gradient style (primary action) */
      .store-card-playbox {
        display: block;
        margin-top: 16px;
        width: 100%;
        padding: 12px;
        background: linear-gradient(135deg, #ff9500 0%, #ff6b9d 33%, #c850c0 66%, #6366f1 100%);
        border: none;
        border-radius: 20px;
        color: #fff;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        font-family: inherit;
        text-decoration: none;
        text-align: center;
      }
      /* Container for Playbox button */
      .store-card-playbox-wrapper {
        width: 100%;
      }
      /* GET button - secondary action */
      .store-card-get {
        display: block;
        margin: 10px auto 0;
        width: 60%;
        padding: 10px;
        background: #0a84ff;
        border: none;
        border-radius: 18px;
        color: #fff;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        font-family: inherit;
      }
      .store-card-store-badge {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        margin-top: 12px;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.4);
      }
      .store-card-store-badge svg {
        width: 14px;
        height: 14px;
      }
      .store-card-icon.loading {
        background: linear-gradient(90deg, #2c2c2e 25%, #3c3c3e 50%, #2c2c2e 75%);
        background-size: 200% 100%;
        animation: shimmer 1.5s infinite;
        /* Use color: transparent to hide alt text/broken image icon */
        color: transparent;
      }
      /* Hide the actual image content while loading */
      img.store-card-icon.loading {
        /* Make the image content invisible but keep the element visible for shimmer */
        object-position: -9999px -9999px;
      }
      /* Fade in when loaded */
      .store-card-icon {
        transition: object-position 0s, opacity 0.2s ease;
      }
      img.store-card-icon:not(.loading) {
        object-position: center center;
        opacity: 1;
      }
      @keyframes shimmer {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="mobile-container">
      <iframe
        id="playable"
        sandbox="allow-scripts allow-same-origin allow-pointer-lock"
        allow="autoplay; fullscreen"
        scrolling="no"
        style="overflow: hidden"
        src="/ref_inner.html"
      ></iframe>
    </div>

    <!-- App Store Card Modal (Mobile) -->
    <div id="store-card-overlay" class="store-card-overlay">
      <div class="store-card">
        <button id="store-card-close" class="store-card-close" aria-label="Close">×</button>
        <div class="store-card-header">
          <img
            id="store-card-icon"
            class="store-card-icon loading"
            src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
            alt=""
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
          />
          <div class="store-card-info">
            <h3 id="store-card-title" class="store-card-title">Loading...</h3>
            <p id="store-card-developer" class="store-card-developer"></p>
            <div class="store-card-rating">
              <span id="store-card-stars" class="store-card-stars"></span>
              <span id="store-card-rating-count"></span>
            </div>
          </div>
        </div>
        <div class="store-card-playbox-wrapper">
          <a id="store-card-playbox" class="store-card-playbox" href="https://plbx.ai" target="_blank" rel="noopener noreferrer"
            >Connect with Playbox</a
          >
        </div>
        <button id="store-card-get" class="store-card-get">GET</button>
        <div id="store-card-badge" class="store-card-store-badge"></div>
      </div>
    </div>
    <script>
      (function () {
        'use strict';

        var preloader = document.getElementById('preloader');
        var iframe = document.getElementById('playable');
        var playableUrl = '/ref_inner.html';
        var preloaderHidden = false;

        // ========== BOUNCE ANIMATION ==========

        // ========== BOUNCE ANIMATION CONFIG ==========
        var bounceConfig = {
          dropHeight: 280,
          groundOffset: 25,
          gravity: 0.9,
          bounceDecay: 0.85,
          bounceCount: 4,
          fallDuration: 0.6,
          staggerDelay: 0.15,
          glowDuration: 0.15,
          fadeInDuration: 0.1,
          enableGlow: true,
          enableSquash: true,
          squashAmount: 0.1,
        };

        var circleConfigs = [
          { className: 'circle-1', cx: 38.4715, cy: 13.1684, glow: 'orange' },
          { className: 'circle-2', cx: 51.3617, cy: 38.4714, glow: 'purple' },
          { className: 'circle-3', cx: 26.0587, cy: 51.3617, glow: 'blue' },
          { className: 'circle-4', cx: 13.1684, cy: 26.0587, glow: 'pink' },
        ];

        var logoSize = 48;
        var circleRadius = 12.8902;
        var bounceScale = logoSize / 65;
        var circleSize = circleRadius * 2 * bounceScale;
        var absoluteGroundY = logoSize;

        // Initialize circle sizes and positions within a specific preloader
        function initBounceCircles(preloaderEl) {
          circleConfigs.forEach(function (conf) {
            var el = preloaderEl.querySelector('.bounce-circle.' + conf.className);
            if (!el) return;
            el.style.width = circleSize + 'px';
            el.style.height = circleSize + 'px';
            var left = conf.cx * bounceScale - circleSize / 2;
            var top = conf.cy * bounceScale - circleSize / 2;
            el.style.left = left + 'px';
            el.style.top = top + 'px';
          });
        }

        // Get glow box-shadow value
        function getGlowValue(glowColor, intensity) {
          intensity = intensity || 1;
          var colors = {
            orange: 'rgba(255, 149, 0, ' + 0.8 * intensity + ')',
            purple: 'rgba(139, 92, 246, ' + 0.8 * intensity + ')',
            blue: 'rgba(0, 133, 255, ' + 0.8 * intensity + ')',
            pink: 'rgba(252, 86, 184, ' + 0.8 * intensity + ')',
          };
          var size = Math.round(30 * intensity);
          var spread = Math.round(10 * intensity);
          return '0 0 ' + size + 'px ' + spread + 'px ' + colors[glowColor];
        }

        // Fire text glow effect
        function fireTextGlow(preloaderEl, atTime, glowColor, intensity) {
          if (!bounceConfig.enableGlow) return;
          var textEl = preloaderEl.querySelector('.preloader-text');
          if (!textEl) return;
          intensity = intensity || 1;

          var colors = {
            orange: 'rgba(255, 149, 0, ',
            purple: 'rgba(139, 92, 246, ',
            blue: 'rgba(0, 133, 255, ',
            pink: 'rgba(252, 86, 184, ',
          };

          var color = colors[glowColor] || 'rgba(255, 255, 255, ';
          var glowSize = Math.round(15 * intensity);

          gsap
            .timeline({ delay: atTime })
            .to(textEl, {
              filter: 'drop-shadow(0 0 ' + glowSize + 'px ' + color + 0.8 * intensity + '))',
              duration: bounceConfig.glowDuration / 2,
              ease: 'power2.out',
            })
            .to(textEl, {
              filter: 'drop-shadow(0 0 0 transparent)',
              duration: bounceConfig.glowDuration / 2,
              ease: 'power2.in',
            });
        }

        // Fire text shake effect
        function fireTextShake(preloaderEl, atTime, intensity) {
          var textEl = preloaderEl.querySelector('.preloader-text');
          if (!textEl) return;
          intensity = intensity || 1;
          var shakeDistance = 3 * intensity;

          gsap
            .timeline({ delay: atTime })
            .to(textEl, {
              y: shakeDistance,
              duration: 0.05,
              ease: 'power2.out',
            })
            .to(textEl, {
              y: 0,
              duration: 0.15,
              ease: 'elastic.out(1, 0.5)',
            });
        }

        // Create bounce animation for a single circle
        function createCircleBounce(preloaderEl, circleIndex, delay) {
          var conf = circleConfigs[circleIndex];
          var el = preloaderEl.querySelector('.bounce-circle.' + conf.className);
          if (!el) return gsap.timeline();

          var glowColor = conf.glow;
          var tl = gsap.timeline({ delay: delay });

          var dropHeight = bounceConfig.dropHeight;
          var fallDuration = bounceConfig.fallDuration;
          var bounceDecay = bounceConfig.bounceDecay;
          var bounceCount = bounceConfig.bounceCount;
          var gravity = bounceConfig.gravity;

          var finalTop = conf.cy * bounceScale - circleSize / 2;
          var groundLevel = absoluteGroundY - finalTop - circleSize + bounceConfig.groundOffset;
          var startY = groundLevel - dropHeight;

          gsap.set(el, {
            y: startY,
            opacity: 0,
            scaleX: 1,
            scaleY: 1,
            boxShadow: 'none',
            force3D: true, // GPU acceleration
          });

          var currentTime = 0;

          // Fade in
          tl.to(el, { opacity: 1, duration: bounceConfig.fadeInDuration });
          currentTime += bounceConfig.fadeInDuration;

          // Glow effect (parallel)
          function fireGlow(atTime, intensity) {
            if (!bounceConfig.enableGlow) return;
            intensity = intensity || 1;

            gsap
              .timeline({ delay: delay + atTime })
              .to(el, {
                boxShadow: getGlowValue(glowColor, intensity),
                duration: bounceConfig.glowDuration / 2,
                ease: 'power2.out',
              })
              .to(el, {
                boxShadow: 'none',
                duration: bounceConfig.glowDuration / 2,
                ease: 'power2.in',
              });
          }

          // Squash effect (parallel)
          function fireSquash(atTime, intensity) {
            if (!bounceConfig.enableSquash) return;
            intensity = intensity || 1;
            var squash = bounceConfig.squashAmount * intensity;

            gsap
              .timeline({ delay: delay + atTime })
              .to(el, {
                scaleX: 1 + squash,
                scaleY: 1 - squash,
                duration: 0.04,
                ease: 'power2.out',
              })
              .to(el, {
                scaleX: 1,
                scaleY: 1,
                duration: 0.08,
                ease: 'elastic.out(1, 0.5)',
              });
          }

          // Initial fall
          var initialFallDuration = fallDuration / gravity;
          tl.to(el, {
            y: groundLevel,
            duration: initialFallDuration,
            ease: 'power2.in',
          });
          currentTime += initialFallDuration;

          // Impact effects
          fireGlow(currentTime - 0.02, 1);
          fireSquash(currentTime - 0.02, 1);
          fireTextGlow(preloaderEl, delay + currentTime - 0.02, glowColor, 1);
          fireTextShake(preloaderEl, delay + currentTime - 0.02, 1);

          // Bounces
          var currentHeight = dropHeight;
          for (var i = 0; i < bounceCount; i++) {
            currentHeight *= bounceDecay;
            var bounceDuration = (fallDuration / gravity) * Math.sqrt(currentHeight / dropHeight);

            // Up
            tl.to(el, {
              y: groundLevel - currentHeight,
              duration: bounceDuration,
              ease: 'power2.out',
            });
            currentTime += bounceDuration;

            // Down
            tl.to(el, {
              y: groundLevel,
              duration: bounceDuration,
              ease: 'power2.in',
            });
            currentTime += bounceDuration;

            // Impact effects (decreasing intensity)
            var intensity = currentHeight / dropHeight;
            if (intensity > 0.15) {
              fireGlow(currentTime - 0.02, intensity);
              fireSquash(currentTime - 0.02, intensity);
              fireTextGlow(preloaderEl, delay + currentTime - 0.02, glowColor, intensity);
              fireTextShake(preloaderEl, delay + currentTime - 0.02, intensity);
            }
          }

          // Settle to final position
          tl.to(el, {
            y: 0,
            duration: 0.3,
            ease: 'power2.out',
          });

          return tl;
        }

        // Play bounce animation for all circles
        function playBounceAnimation(preloaderEl) {
          if (typeof gsap === 'undefined') {
            console.warn('[Playbox] GSAP not loaded, skipping bounce animation');
            // Fallback: just show circles
            circleConfigs.forEach(function (conf) {
              var el = preloaderEl.querySelector('.bounce-circle.' + conf.className);
              if (el) {
                el.style.opacity = '1';
              }
            });
            return;
          }

          var timeline = gsap.timeline();

          circleConfigs.forEach(function (conf, index) {
            var circleTl = createCircleBounce(preloaderEl, index, index * bounceConfig.staggerDelay);
            timeline.add(circleTl, 0);
          });

          return timeline;
        }

        // Initialize and start animation
        function startPreloaderAnimation(preloaderEl) {
          initBounceCircles(preloaderEl);
          setTimeout(function () {
            playBounceAnimation(preloaderEl);
          }, 100);
        }

        // Start preloader animation
        if (preloader) {
          startPreloaderAnimation(preloader);
        }

        // Show VPN hint after 5 seconds if still loading
        setTimeout(function () {
          var hints = document.querySelectorAll('.preloader-vpn-hint');
          for (var i = 0; i < hints.length; i++) {
            hints[i].classList.add('show');
          }
        }, 5000);

        // ========== WEB WORKER LOADER ==========

        // Detect mobile/tablet devices - blob: URLs for iframes have issues in WebViews
        // iOS WKWebView and Android WebView (used by Telegram, Instagram, Facebook, etc.)
        // often don't properly support blob: iframe src. Use Worker+blob only on desktop.
        var isMobileOrTablet = (function () {
          var ua = navigator.userAgent || '';

          // Check for mobile/tablet UA patterns
          var mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|Tablet/i;
          var isMobileUA = mobileRegex.test(ua);

          // Also check for touch capability as backup (tablets without "Tablet" in UA)
          var hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

          // Consider it mobile/tablet if UA matches OR it's a touch device with small/medium screen
          var isSmallScreen = window.innerWidth <= 1024;
          var isTouchDevice = hasTouch && isSmallScreen;

          var result = isMobileUA || isTouchDevice;

          if (result) {
            console.log('[Playbox] Mobile/tablet detected, using direct loading (blob: URLs may not work in WebViews)');
          }

          return result;
        })();

        // Create Web Worker from inline code (used on desktop only)
        var workerCode = `
   // SDK detection patterns (simplified version for worker)
   var SDK_PATTERNS = {
     mraid: [/\\bmraid\\b/i, /mraid\\.js/i, /getState\\(\\)/],
     dapi: [/\\bdapi\\b/i, /dapi\\.isReady/],
     exitApi: [/ExitApi/i, /ExitApi\\.exit/],
     fbPlayable: [/FbPlayableAd/i],
     tiktok: [/TikTokApi/i, /openAppStore/],
     superHtml: [/super_html/i, /set_google_play_url/]
   };

   // Analyze HTML for SDK usage
   function analyzeHtml(html) {
     var result = {
       usesMraid: false,
       supportsAudioControl: false,
       supportsViewable: false,
       detectedSdks: [],
       fallbackStoreUrls: { apple: '', google: '' }
     };

     // Check each SDK
     for (var sdk in SDK_PATTERNS) {
       var patterns = SDK_PATTERNS[sdk];
       var matches = 0;
       for (var i = 0; i < patterns.length; i++) {
         if (patterns[i].test(html)) matches++;
       }
       if (matches > 0) {
         result.detectedSdks.push(sdk);
         if (sdk === 'mraid' || sdk === 'dapi') {
           result.usesMraid = true;
           result.supportsAudioControl = true;
           result.supportsViewable = true;
         }
       }
     }

     // Extract store URLs from HTML (anywhere in the code - variables, comments, strings)
     // App Store URL pattern: https://apps.apple.com/{country}/app/{name}/id{digits}
     var appleMatch = html.match(/https:\\/\\/apps\\.apple\\.com\\/[a-z]{2}\\/app\\/[^\\/]+\\/id\\d+/i);
     if (appleMatch) result.fallbackStoreUrls.apple = appleMatch[0];

     // Play Store URL pattern: https://play.google.com/store/apps/details?id={package}
     var googleMatch = html.match(/https:\\/\\/play\\.google\\.com\\/store\\/apps\\/details\\?id=[a-zA-Z][a-zA-Z0-9_.]+/i);
     if (googleMatch) result.fallbackStoreUrls.google = googleMatch[0];

     return result;
   }

   // Inject base tag for relative path resolution
   function injectBaseTag(html, baseUrl) {
     var baseTag = '<base href="' + baseUrl + '">';

     if (html.indexOf('<head>') !== -1) {
       return html.replace('<head>', '<head>' + baseTag);
     } else if (html.indexOf('<head ') !== -1) {
       return html.replace(/<head[^>]*>/, function(match) {
         return match + baseTag;
       });
     } else if (html.indexOf('<html') !== -1) {
       return html.replace(/<html[^>]*>/, function(match) {
         return match + '<head>' + baseTag + '</head>';
       });
     }
     return baseTag + html;
   }

   // Main worker message handler
   self.onmessage = function(e) {
     var data = e.data;
     var url = data.url;
     var baseUrl = data.baseUrl;

     console.log('[Worker] Starting fetch:', url);
     var startTime = performance.now();

     fetch(url)
       .then(function(response) {
         if (!response.ok) throw new Error('Failed to load: ' + response.status);
         return response.text();
       })
       .then(function(html) {
         console.log('[Worker] Fetched HTML:', (html.length / 1024 / 1024).toFixed(2) + 'MB');

         // Analyze HTML (heavy regex operations)
         var analysis = analyzeHtml(html);
         console.log('[Worker] Analysis complete, SDKs:', analysis.detectedSdks);

         // Inject base tag (string manipulation)
         html = injectBaseTag(html, baseUrl);

         // Create blob URL
         var blob = new Blob([html], { type: 'text/html' });
         var blobUrl = URL.createObjectURL(blob);

         var elapsed = performance.now() - startTime;
         console.log('[Worker] Prepared in ' + elapsed.toFixed(0) + 'ms');

         // Send result back to main thread
         self.postMessage({
           success: true,
           blobUrl: blobUrl,
           analysis: analysis,
           timing: elapsed
         });
       })
       .catch(function(error) {
         console.error('[Worker] Error:', error);
         self.postMessage({
           success: false,
           error: error.message,
           fallbackUrl: url
         });
       });
   };
 `;
        var workerBlob = new Blob([workerCode], { type: 'application/javascript' });
        var workerUrl = URL.createObjectURL(workerBlob);
        var playableWorker = null;

        // Don't use Worker+blob for mobile/tablet - WebViews have issues with blob: iframe src
        if (!isMobileOrTablet) {
          try {
            playableWorker = new Worker(workerUrl);
            console.log('[Playbox] Web Worker created for playable loading');
          } catch (e) {
            console.warn('[Playbox] Web Worker not supported, using main thread');
          }
        }

        // Load playable via Web Worker (offloads heavy ops from main thread)
        function loadPlayableAsync(iframe, url, callback) {
          // Build absolute URLs (Worker can't use relative URLs)
          var absoluteUrl = new URL(url, window.location.origin).href;
          var baseUrl = absoluteUrl;
          if (!baseUrl.endsWith('/')) baseUrl = baseUrl + '/';

          if (playableWorker) {
            // Use worker for heavy lifting
            playableWorker.onmessage = function (e) {
              var result = e.data;
              if (result.success) {
                console.log('[Playbox] Worker prepared playable in ' + result.timing.toFixed(0) + 'ms');

                // Store analysis in iframe dataset
                iframe.dataset.usesMraid = result.analysis.usesMraid ? 'true' : 'false';
                iframe.dataset.supportsAudioControl = result.analysis.supportsAudioControl ? 'true' : 'false';
                iframe.dataset.supportsViewable = result.analysis.supportsViewable ? 'true' : 'false';
                iframe.dataset.fallbackAppleUrl = result.analysis.fallbackStoreUrls.apple || '';
                iframe.dataset.fallbackGoogleUrl = result.analysis.fallbackStoreUrls.google || '';

                // Set iframe src (this will still cause some freeze during HTML parsing)
                iframe.src = result.blobUrl;

                if (callback) callback(result.analysis);
              } else {
                console.warn('[Playbox] Worker failed, falling back:', result.error);
                iframe.src = result.fallbackUrl || url;
              }
            };

            playableWorker.onerror = function (e) {
              console.error('[Playbox] Worker error:', e);
              iframe.src = url;
            };

            // Start worker with absolute URL
            playableWorker.postMessage({ url: absoluteUrl, baseUrl: baseUrl });
          } else {
            // Fallback: load directly (old behavior)
            iframe.src = url;
          }
        }

        // Load playable via Web Worker
        loadPlayableAsync(iframe, playableUrl, function (analysis) {
          console.log('[Playbox] Mobile playable ready');
        });

        // Hide preloader function
        function hidePreloader() {
          if (preloaderHidden) return;
          preloaderHidden = true;

          if (preloader) {
            preloader.classList.add('hide');
            setTimeout(function () {
              if (preloader && preloader.parentNode) {
                preloader.parentNode.removeChild(preloader);
              }
            }, 300);
          }
        }

        // Hide preloader when iframe loads
        iframe.addEventListener('load', function () {
          hidePreloader();
          injectCTAInterception(iframe);
        });

        // Fallback: hide preloader after 10 seconds
        setTimeout(hidePreloader, 10000);

        // ========== CASUAL PROTECTION ==========
        document.addEventListener('contextmenu', function (e) {
          e.preventDefault();
          return false;
        });

        document.addEventListener('dragstart', function (e) {
          e.preventDefault();
          return false;
        });

        // ========== DEBUG LOGGING ==========
        function debugLog(message, data) {
          console.log('[Playbox CTA Debug]', message, data || '');
          try {
            var debugEl = document.getElementById('playbox-debug-log');
            if (debugEl) {
              var time = new Date().toLocaleTimeString();
              debugEl.textContent = time + ': ' + message + '\n' + debugEl.textContent;
            }
          } catch (e) {}
        }

        // ========== IFRAME CTA INJECTION ==========
        function injectCTAInterception(iframe) {
          debugLog('Attempting to inject CTA interception', { iframe: !!iframe });

          try {
            var iframeWin = iframe.contentWindow;
            debugLog('Got contentWindow', { hasContentWindow: !!iframeWin });

            var iframeDoc = null;
            try {
              iframeDoc = iframe.contentDocument || iframeWin.document;
              debugLog('Got contentDocument', { hasContentDocument: !!iframeDoc });
            } catch (docError) {
              debugLog('Failed to access contentDocument (cross-origin)', { error: docError.message });
            }

            if (!iframeWin || !iframeDoc) {
              debugLog('Cannot inject - cross-origin iframe detected');
              debugLog('Playable must use postMessage manually for CTA to work');
              return;
            }

            debugLog('Same-origin iframe - proceeding with injection');

            // Store original window.open
            var originalOpen = iframeWin.open;

            // Override window.open
            iframeWin.open = function (url, target, features) {
              debugLog('window.open intercepted', { url: url });
              window.parent.postMessage({ type: 'CTA_CLICK', url: url || '' }, '*');
              return null;
            };

            debugLog('window.open override installed');

            // Intercept link clicks
            iframeDoc.addEventListener(
              'click',
              function (e) {
                var link = e.target.closest ? e.target.closest('a') : null;
                if (!link) {
                  var el = e.target;
                  while (el && el.tagName !== 'A') el = el.parentNode;
                  link = el;
                }

                if (link && link.href && (link.target === '_blank' || link.href.indexOf('http') === 0)) {
                  debugLog('Link click intercepted', { url: link.href });
                  e.preventDefault();
                  e.stopPropagation();
                  window.parent.postMessage({ type: 'CTA_CLICK', url: link.href }, '*');
                }
              },
              true
            );

            debugLog('Click listener installed');
          } catch (e) {
            debugLog('Injection failed', { error: e.message });
            debugLog('Fallback: Playable must use postMessage directly');
          }
        }

        // ========== STORE CARD MODAL ==========
        var storeCardOverlay = document.getElementById('store-card-overlay');
        var storeCardIcon = document.getElementById('store-card-icon');
        var storeCardTitle = document.getElementById('store-card-title');
        var storeCardDeveloper = document.getElementById('store-card-developer');
        var storeCardStars = document.getElementById('store-card-stars');
        var storeCardRatingCount = document.getElementById('store-card-rating-count');
        var storeCardGet = document.getElementById('store-card-get');
        var storeCardClose = document.getElementById('store-card-close');
        var storeCardBadge = document.getElementById('store-card-badge');
        var currentStoreUrl = null;

        // ========== HELPER FUNCTIONS ==========
        // Render star rating using DOM methods (no innerHTML for security)
        function renderStars(container, rating) {
          if (!container) return;

          var safeRating = parseFloat(rating) || 0;
          if (safeRating < 0) safeRating = 0;
          if (safeRating > 5) safeRating = 5;

          var fullStars = Math.floor(safeRating);
          var hasHalf = safeRating - fullStars >= 0.25;
          var emptyStars = 5 - fullStars - (hasHalf ? 1 : 0);

          // Clear container
          container.textContent = '';

          // Add full stars
          for (var i = 0; i < fullStars; i++) {
            container.appendChild(document.createTextNode('★'));
          }

          // Add half star using DOM
          if (hasHalf) {
            var halfStar = document.createElement('span');
            halfStar.className = 'half-star';

            var bgStar = document.createElement('span');
            bgStar.className = 'half-star-bg';
            bgStar.textContent = '☆';
            halfStar.appendChild(bgStar);

            var fillStar = document.createElement('span');
            fillStar.className = 'half-star-fill';
            fillStar.textContent = '★';
            halfStar.appendChild(fillStar);

            container.appendChild(halfStar);
          }

          // Add empty stars
          for (var i = 0; i < emptyStars; i++) {
            container.appendChild(document.createTextNode('☆'));
          }
        }

        function formatCount(num) {
          if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
          if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
          return num.toString();
        }

        // ========== PLAYBOX FALLBACK UI ==========
        function showPlayboxFallback(reason) {
          debugLog('Showing Playbox fallback UI', { reason: reason });

          if (storeCardIcon) {
            storeCardIcon.src = 'https://app.plbx.ai/playbox-logo.png';
            storeCardIcon.classList.remove('loading');
          }
          if (storeCardTitle) storeCardTitle.textContent = 'Demo Playable';
          if (storeCardDeveloper) {
            var message =
              reason === 'no-url'
                ? 'App Store link not configured for this playable. Connect with Playbox to publish your game.'
                : reason === 'invalid-url'
                ? 'Invalid store link. This may be a demo or test playable. Connect with Playbox to publish your game.'
                : 'Store metadata unavailable. Connect with Playbox to publish your game.';

            storeCardDeveloper.textContent = message;
            storeCardDeveloper.style.whiteSpace = 'normal';
            storeCardDeveloper.style.lineHeight = '1.4';
          }
          if (storeCardStars) storeCardStars.textContent = '';
          if (storeCardRatingCount) storeCardRatingCount.textContent = '';
          if (storeCardBadge) storeCardBadge.textContent = 'Playbox Platform';
          if (storeCardGet) storeCardGet.style.display = 'none';
        }

        // ========== STORE CARD SHOW/HIDE ==========
        function showStoreCard(url) {
          debugLog('showStoreCard called', { url: url });

          if (!storeCardOverlay) {
            debugLog('Store card overlay not found - opening URL directly');
            if (url && url !== '') window.open(url, '_blank', 'noopener,noreferrer');
            return;
          }

          var hasValidUrl = url && url !== '' && url !== 'undefined';
          currentStoreUrl = hasValidUrl ? url : 'https://plbx.ai';

          if (!hasValidUrl) {
            showPlayboxFallback('no-url');
            storeCardOverlay.classList.add('show');
            return;
          }

          // Reset to loading state
          if (storeCardIcon) {
            storeCardIcon.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            storeCardIcon.classList.add('loading');
          }
          if (storeCardTitle) storeCardTitle.textContent = 'Loading...';
          if (storeCardDeveloper) {
            storeCardDeveloper.textContent = '';
            storeCardDeveloper.style.whiteSpace = '';
            storeCardDeveloper.style.lineHeight = '';
          }
          if (storeCardStars) storeCardStars.textContent = '';
          if (storeCardRatingCount) storeCardRatingCount.textContent = '';
          if (storeCardGet) storeCardGet.style.display = '';
          if (storeCardBadge) storeCardBadge.textContent = '';

          // Detect store type
          var isAppStore = url.indexOf('apps.apple.com') !== -1 || url.indexOf('itunes.apple.com') !== -1;
          var isPlayStore = url.indexOf('play.google.com') !== -1;

          if (isAppStore) {
            if (storeCardBadge) storeCardBadge.textContent = 'App Store';
            fetchAppStoreMetadata(url);
          } else if (isPlayStore) {
            if (storeCardBadge) storeCardBadge.textContent = 'Google Play';
            fetchPlayStoreMetadata(url);
          } else {
            if (storeCardIcon) storeCardIcon.classList.remove('loading');
            if (storeCardTitle) storeCardTitle.textContent = 'Open Link';
            if (storeCardDeveloper) storeCardDeveloper.textContent = url.substring(0, 50) + (url.length > 50 ? '...' : '');
          }

          storeCardOverlay.classList.add('show');
        }

        function hideStoreCard() {
          if (storeCardOverlay) storeCardOverlay.classList.remove('show');
          currentStoreUrl = null;
        }

        // ========== APP STORE METADATA (via proxy to avoid CORS issues) ==========
        function fetchAppStoreMetadata(url) {
          debugLog('fetchAppStoreMetadata called', { url: url });

          var appIdMatch = url.match(/id(\d+)/);
          if (!appIdMatch) {
            debugLog('Failed to extract app ID from URL');
            showPlayboxFallback('invalid-url');
            return;
          }

          var appId = appIdMatch[1];

          // Extract country code from URL (e.g., /in/ from apps.apple.com/in/app/...)
          var countryMatch = url.match(/apps\.apple\.com\/([a-z]{2})\//i);
          var country = countryMatch ? countryMatch[1] : 'us';
          debugLog('Extracted app ID and country', { appId: appId, country: country });

          // Use server-side proxy to avoid CORS issues with iTunes API
          var apiUrl = '/_api/app-store?id=' + appId + '&country=' + country;
          debugLog('Fetching App Store API via proxy', { apiUrl: apiUrl });

          fetch(apiUrl)
            .then(function (response) {
              debugLog('App Store API response', { status: response.status, ok: response.ok });
              if (!response.ok) throw new Error('HTTP ' + response.status);
              return response.json();
            })
            .then(function (data) {
              debugLog('App Store API data received', data);

              if (data && data.trackName) {
                debugLog('App found', { name: data.trackName, developer: data.artistName });

                var iconUrl = data.artworkUrl100 || '';

                if (storeCardIcon) {
                  if (iconUrl) {
                    storeCardIcon.onload = function () {
                      storeCardIcon.classList.remove('loading');
                    };
                    storeCardIcon.onerror = function () {
                      storeCardIcon.classList.remove('loading');
                    };
                    storeCardIcon.src = iconUrl;
                  } else {
                    storeCardIcon.classList.remove('loading');
                  }
                }
                if (storeCardTitle) storeCardTitle.textContent = data.trackName || 'App';
                if (storeCardDeveloper) storeCardDeveloper.textContent = data.artistName || '';
                if (data.averageUserRating) {
                  renderStars(storeCardStars, data.averageUserRating);
                  if (storeCardRatingCount)
                    storeCardRatingCount.textContent = data.userRatingCount ? '(' + formatCount(data.userRatingCount) + ')' : '';
                }
              } else {
                debugLog('No data in App Store API response');
                showPlayboxFallback('fetch-error');
              }
            })
            .catch(function (error) {
              debugLog('App Store API fetch error', { error: error.message });
              showPlayboxFallback('fetch-error');
            });
        }

        // ========== PLAY STORE METADATA (PROXY) ==========
        function fetchPlayStoreMetadata(url) {
          var packageIdMatch = url.match(/[?&]id=([a-zA-Z][a-zA-Z0-9_.]+)/);
          if (!packageIdMatch) {
            showPlayboxFallback('invalid-url');
            return;
          }

          var packageId = packageIdMatch[1];

          fetch('/_api/play-store?id=' + encodeURIComponent(packageId))
            .then(function (response) {
              if (!response.ok) throw new Error('Not found');
              return response.json();
            })
            .then(function (data) {
              if (data && data.name) {
                var iconUrl = data.logo || 'https://www.gstatic.com/android/market_images/web/favicon_v3.ico';

                if (storeCardIcon) {
                  storeCardIcon.onload = function () {
                    storeCardIcon.classList.remove('loading');
                  };
                  storeCardIcon.onerror = function () {
                    storeCardIcon.classList.remove('loading');
                  };
                  storeCardIcon.src = iconUrl;
                }
                if (storeCardTitle) storeCardTitle.textContent = data.name;
                if (storeCardDeveloper) storeCardDeveloper.textContent = data.developer || '';
                if (data.rating) {
                  renderStars(storeCardStars, data.rating);
                  if (storeCardRatingCount)
                    storeCardRatingCount.textContent = data.noOfUsersRated ? '(' + data.noOfUsersRated + ')' : '';
                } else {
                  if (storeCardStars) storeCardStars.textContent = '';
                  if (storeCardRatingCount) storeCardRatingCount.textContent = '';
                }
              } else {
                showPlayboxFallback('fetch-error');
              }
            })
            .catch(function () {
              showPlayboxFallback('fetch-error');
            });
        }

        // ========== EVENT LISTENERS ==========
        if (storeCardClose) {
          storeCardClose.addEventListener('click', hideStoreCard);
        }
        if (storeCardOverlay) {
          storeCardOverlay.addEventListener('click', function (e) {
            if (e.target === storeCardOverlay) hideStoreCard();
          });
        }
        if (storeCardGet) {
          storeCardGet.addEventListener('click', function () {
            if (currentStoreUrl) window.open(currentStoreUrl, '_blank', 'noopener,noreferrer');
            hideStoreCard();
          });
        }

        // ========== MESSAGE LISTENER ==========
        debugLog('Installing postMessage listener for CTA_CLICK events');

        // Get fallback store URL from iframe dataset (extracted from HTML during analysis)
        function getFallbackStoreUrl() {
          var iframe = document.getElementById('playable-desktop') || document.getElementById('playable');
          if (!iframe) return '';

          var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
          var fallbackUrl = isIOS ? iframe.dataset.fallbackAppleUrl : iframe.dataset.fallbackGoogleUrl;

          // If platform-specific URL not found, try the other one
          if (!fallbackUrl) {
            fallbackUrl = iframe.dataset.fallbackAppleUrl || iframe.dataset.fallbackGoogleUrl || '';
          }

          debugLog('Fallback URL lookup', { isIOS: isIOS, fallbackUrl: fallbackUrl || '(none)' });
          return fallbackUrl;
        }

        window.addEventListener('message', function (event) {
          if (event.data && event.data.type) {
            debugLog('postMessage received', {
              type: event.data.type,
              origin: event.origin,
              hasUrl: !!event.data.url,
            });
          }

          if (event.data && event.data.type === 'CTA_CLICK') {
            debugLog('CTA_CLICK message received', { url: event.data.url });
            var url = event.data.url;

            // If no URL provided, try to use fallback URL extracted from HTML
            if (!url || url === '' || url === 'undefined' || url === 'null') {
              debugLog('No URL in CTA - checking for fallback');
              url = getFallbackStoreUrl();
            }

            if (url && url !== '') {
              var isStoreUrl =
                url.indexOf('apps.apple.com') !== -1 ||
                url.indexOf('itunes.apple.com') !== -1 ||
                url.indexOf('play.google.com') !== -1;

              if (isStoreUrl) {
                debugLog('Store URL detected - showing store card', { url: url });
                showStoreCard(url);
              } else {
                debugLog('Non-store URL - opening in new tab');
                window.open(url, '_blank', 'noopener,noreferrer');
              }
            } else {
              debugLog('No URL and no fallback found - showing Playbox fallback');
              showStoreCard('');
            }
          }
        });
      })();
    </script>
  </body>
</html>
